<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Concepts of Programming Languages</title>
<link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Alex+Brush">
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/styles/vs.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/highlight.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/languages/haskell.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/languages/javascript.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/languages/python.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/languages/sql.min.js"></script>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script type="text/javascript" src="sheaf/protoql.js"></script>
<link rel="stylesheet" href="sheaf/sheaf.css">
<script type="text/javascript" src="sheaf/sheaf.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
<div id="sheaf"><h1>Concepts of Programming Languages<span>Parsing, Interpretation, Compilation, Type Systems, and Programming Paradigms</span></h1><div id="toc"><ul> <li>1. <a href="#1">Introduction, Background, and Motivation</a>
  <ul>  <li>1.1. <a href="#1.1">Overview</a></li>  <li>1.2. <a href="#1.2">Background and prerequisites</a></li>
  </ul>
 </li> <li>2. <a href="#2">Defining Programming Languages</a>
  <ul>  <li>2.1. <a href="#2.1">Sets of character strings</a></li>  <li>2.2. <a href="#2.2">Regular expressions</a></li>  <li>2.3. <a href="#2.3">Sets of token sequences</a></li>  <li>2.4. <a href="#2.4">Language syntax and Backus-Naur Form (BNF) notation</a></li>
  </ul>
 </li> <li>3. <a href="#3">Parsing</a>
  <ul>  <li>3.1. <a href="#3.1">Concrete and abstract syntaxes</a></li>  <li>3.2. <a href="#3.2">Lexing (a.k.a., tokenizing) and parsing</a></li>  <li>3.3. <a href="#3.3">More parsing examples and building parsers for other classes of grammar</a></li>
  </ul>
 </li> <li>4. <a href="#4">Semantics, Evaluation, and Interpretation</a>
  <ul>  <li>4.1. <a href="#4.1">Formally defining an abstract syntax</a></li>  <li>4.2. <a href="#4.2">Denotational semantics and operational semantics</a></li>  <li>4.3. <a href="#4.3">Evaluation of expressions</a></li>  <li>4.4. <a href="#4.4">Execution of sequences of statements</a></li>  <li>4.5. <a href="#4.5">Interpreters</a></li>
  </ul>
 </li> <li>5. <a href="#5">Compilation</a>
  <ul>  <li>5.1. <a href="#5.1">History, background, and context</a></li>  <li>5.2. <a href="#5.2">Transformations between abstract syntaxes</a></li>  <li>5.3. <a href="#5.3">Machine languages and bytecodes</a></li>  <li>5.4. <a href="#5.4">Compiling expressions to a machine language or bytecode</a></li>  <li>5.5. <a href="#5.5">Compiling statement sequences and procedures to a machine language or bytecode</a></li>  <li>5.6. <a href="#5.6">Common compiler optimizations and register allocation</a></li>  <li>5.7. <a href="#5.7">Correctness of compilation algorithms</a></li>
  </ul>
 </li> <li>6. <a href="#6">Static Analysis and Abstract Interpretation</a>
  <ul>  <li>6.1. <a href="#6.1">Monomorphic type systems and type checking</a></li>  <li>6.2. <a href="#6.2">Abstract interpretation</a></li>
  </ul>
 </li> <li>7. <a href="#7">Declarative (and Functional) Programming Language Paradigms</a>
  <ul>  <li>7.1. <a href="#7.1">Programming language paradigms</a></li>  <li>7.2. <a href="#7.2">Substitution and unification</a></li>  <li>7.3. <a href="#7.3">Declarative programming languages</a></li>  <li>7.4. <a href="#7.4">Algebraic data types</a></li>  <li>7.5. <a href="#7.5">Type system of the typed declarative language Haskell</a></li>  <li>7.6. <a href="#7.6">Defining and working with infinite data type instances using lazy evaluation</a></li>  <li>7.7. <a href="#7.7">Functions and higher-order functions in a typed functional language</a></li>  <li>7.8. <a href="#7.8">Logic programming</a></li>  <li>7.9. <a href="#7.9">Data encapsulation using algebraic data types</a></li>  <li>7.10. <a href="#7.10">Predefined Haskell type classes, user-defined operators, and embedded languages</a></li>  <li>7.11. <a href="#7.11">Additional useful Haskell language features and examples</a></li>  <li>7.12. <a href="#7.12">List comprehensions and pattern matching unification</a></li>  <li>7.13. <a href="#7.13">Modeling and exploring state spaces in a typed declarative/functional language</a></li>  <li>7.14. <a href="#7.14">Ad Hoc and Parametric Polymorphism</a></li>  <li>7.15. <a href="#7.15">Folds, Unfolds, and Algebraic Properties of Functional Programs</a></li>  <li>7.16. <a href="#7.16">Folds, Monads, and Algebraic Properties of Programs</a></li>
  </ul>
 </li> <li>Review 1. <a href="#R.1">Programming Language Concepts</a>
  <ul>
  </ul>
 </li> <li>Appendix A. <a href="#A">Using gsubmit</a>
  <ul>  <li>A.1. <a href="#A.1">Register for a CS account</a></li>  <li>A.2. <a href="#A.2">Download SSH/SCP client software</a></li>  <li>A.3. <a href="#A.3">Submitting assignments using gsubmit</a></li>
  </ul>
 </li> <li>Appendix B. <a href="#B">Python Reference</a>
  <ul>  <li>B.1. <a href="#B.1">Obtaining Python</a></li>  <li>B.2. <a href="#B.2">Assembling a Python module</a></li>  <li>B.3. <a href="#B.3">Common data structures (i.e., Python expressions)</a></li>  <li>B.4. <a href="#B.4">Function, procedure, and method invocations</a></li>  <li>B.5. <a href="#B.5">Comprehensions</a></li>  <li>B.6. <a href="#B.6">Other useful built-in functions</a></li>  <li>B.7. <a href="#B.7">Common Python definition and control constructs (i.e., Python statements)</a></li>
  </ul>
 </li> <li>Appendix C. <a href="#C">Haskell Reference</a>
  <ul>  <li>C.1. <a href="#C.1">Obtaining Haskell</a></li>  <li>C.2. <a href="#C.2">Haskell modules and declarations</a></li>  <li>C.3. <a href="#C.3">Common data structures (i.e., Haskell expressions)</a></li>
  </ul>
 </li></ul></div>
<a name="1"></a>
<div class="section"><hr /><h2 class="linked"><span class="link-title">[<a href="#1">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">1.</span> Introduction, Background, and Motivation</h2>
  <a name="1.1"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#1.1">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">1.1.</span> Overview</h3>
<span class="text top">A large variety of modern technology, from mobile devices and personal computers to datacenters and entire infrastructures, are programmable. These entities are controlled, operated, maintained, and monitored using a variety of interfaces and languages, which might take the form of graphical user interfaces, libraries, APIs, embedded languages, domain-specific languages, and general-purpose programming languages.</span>
<span class="text top">Many of these interfaces and languages are defined and designed according to principles and conventions that have been developed over the last several decades.</span>
<span class="text top">There are three major themes around which this course is organized. Each of the concepts, examples, and problems discussed in this course will relate to one or more of these themes:</span><ol><li><b>Defining and working with programming languages: </b>We will define and become familiar with the basic concepts that underlie the definition and design of common programming languages, and we will learn to identify and implement the common components found in static analysis tools, interpreters, and compilers.</li><li><b>Programming paradigms: </b>You should now be familiar with the imperative and object-oriented programming paradigms. In this course, we will provide a high-level picture of the landscape of different programming paradigms, and will focus in particular on the declarative and functional programming paradigms. We will learn to identify problems that can be solved more efficiently, more concisely, and with greater generality using programming languages that support the functional and declarative paradigms. This includes gaining experience taking advantage of features such as comprehensions, algebraic data types, static type checking, and higher-order functions, and techniques such as recursion.</li><li><b>Languages as solutions: </b>The purpose of a programming language is to provide a data representation and storage format, a communication protocol, or a control interface that can be used across time and space, between different humans and/or devices. Thus, as with any language, any programming language can be viewed as a solution to a representation, communication, or control problem. We will learn to identify when a programming language may be an appropriate solution for a problem, what trade-offs should be considered when deciding whether to design a point solution or a language, and what are some of the appropriate mathematical concepts and software tools for doing so.</li></ol>
<span class="text top">Throughout this course, we use formal mathematical conventions and notations developed by the community of computer scientists and mathematicians to communicate with one another about the definitions and implementations of programming languages. Some of these notations are used throughout mathematics and computer science, while others are more obscure and are used primarily by the community of programming language theorists. Throughout your career, you will be required to learn a variety of new notations for a variety of new technologies. This course provides an opportunity to <i>practice learning new notations</i> quickly. This is a valuable skill to possess even if your area of expertise lies or will lie outside the topics covered in this course.</span></div>
  <a name="1.2"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#1.2">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">1.2.</span> Background and prerequisites</h3><div class="paragraph"><b>Basic logic.</b> 
It is expected that the reader is familiar with the basic concepts of mathematical logic, including formulas, predicates, relational operators, and terms.
      </div><div class="paragraph"><b>Basic set theory.</b> 
It is expected that the reader is familiar with the notion of a set (both finite and infinite), set size, and the set comprehension notation, e.g.,
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">  {1,2,3,4} is a set
</td></tr></table></td></tr></table>
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">  { <i>x</i> | <i>x</i> <span style="font-size:12px;">&#8712;</span> &#8484;, <i>x</i> > 0 } <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> {1, 2, 3, ...}
</td></tr></table></td></tr></table>
and the membership and subset relations between elements and sets, e.g.,
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">  1 <td></tr></table></td><td style="text-align:center;"> <span style="font-size:12px;">&#8712;</span> </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { 1, 2, 3 } </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
  {2, 3} <td></tr></table></td><td style="text-align:center;"> &sub; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { 1, 2, 3 }
</td></tr></table></td></tr></table>
      </div><div class="paragraph"><b>Programming using imperative and object-oriented language.</b> 
It is expected that the reader is familiar with at least one imperative, object-oriented language, such as Java, C++, or Python.
      </div></div>
</div>
<a name="2"></a>
<div class="section"><hr /><h2 class="linked"><span class="link-title">[<a href="#2">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">2.</span> Defining Programming Languages</h2>
<span class="text top">In order to define and reason about programming languages, and in order to write automated tools and algorithms that can operate on programs written using programming languagues, we must be able to define formally (i.e., mathematically) what is a programming language and what is a program.</span>
  <a name="2.1"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#2.1">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">2.1.</span> Sets of character strings</h3>
<span class="text top">In computer science, one common way to mathematically model a formal language is to introduce a finite set of symbols (an <i>alphabet</i>). A <i>language</i> is then any subset of the set of all strings consisting of symbols from that alphabet.</span>
<a name="95e72ad05e66427281549720c9ed975f"></a><div class="linked block"><div class="link-block">[<a href="#95e72ad05e66427281549720c9ed975f">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
An <i>alphabet</i> is a finite set <i>A</i>. We will call elements <i>a</i> <span style="font-size:12px;">&#8712;</span> <i>A</i> of the set <i>characters</i>. The typical alphabet we will use in this course is the set of 128 <a href="http://en.wikipedia.org/wiki/Ascii">ASCII</a> characters. However, any finite set can be an alphabet.
      </div></div></div>
<a name="3822c49489b942f59671177f1ada70ca"></a><div class="linked block"><div class="link-block">[<a href="#3822c49489b942f59671177f1ada70ca">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
Given an alphabet <i>A</i>, a <i>character string</i> or <i>string</i> is any ordered finite sequence of characters from that alphabet. We will denote the empty string (containing no characters) using the symbol &epsilon;, and we will denote the length of a string <i>s</i> using the notation |<i>s</i>|.
      </div></div></div>
<a name="daa30c4fc2be458baf5bff14cd632cd9"></a><div class="linked block"><div class="link-block">[<a href="#daa30c4fc2be458baf5bff14cd632cd9">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
The set <i>A</i> = {<b>A</b>,<b>B</b>,<b>C</b>} is an alphabet. <b>A</b><b>A</b><b>A</b>, <b>A</b><b>B</b>, <b>B</b>, <b>C</b><b>B</b><b>A</b>, and &epsilon; are all examples of strings built using the alphabet <i>A</i>.
      </div></div></div>
<a name="d1e9fd2dc4724ef58c57cd881340e32d"></a><div class="linked block"><div class="link-block">[<a href="#d1e9fd2dc4724ef58c57cd881340e32d">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
Given an alphabet <i>A</i>, let <i>U</i> be the set of all finite strings that can be built using characters from <i>A</i> (including the empty string, which we will call &epsilon;). In other words, we can say:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">  <i>U</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { <i>s</i> | <i>s</i> is a finite string of characters from alphabet <i>A</i> }
</td></tr></table></td></tr></table>
Any subset <i>L</i> &sub; <i>U</i> is a <i>language</i>. That is, any set of character strings (whether the set is finite or infinite) is a language.
      </div></div></div>
<a name="a32c619802234e94a307d71f676e3186"></a><div class="linked block"><div class="link-block">[<a href="#a32c619802234e94a307d71f676e3186">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
The set <i>A</i> = {<b>X</b>, <b>Y</b>, <b>Z</b>} is an alphabet. The set of strings { &epsilon;, <b>X</b>, <b>Y</b>, <b>Z</b> } is one example of a language. The infinite set of strings { &epsilon;, <b>X</b>, <b>X</b><b>X</b>, <b>X</b><b>X</b><b>X</b>, <b>X</b><b>X</b><b>X</b><b>X</b>, ... } is also a language. The infinite set of strings { <b>Y</b><b>Z</b>, <b>Y</b><b>Z</b><b>Y</b><b>Z</b>, <b>Y</b><b>Z</b><b>Y</b><b>Z</b><b>Y</b><b>Z</b>, ... } is also a language.
      </div></div></div>
<a name="fc5990b5b76040539c931b1ca279e222"></a><div class="linked block"><div class="link-block">[<a href="#fc5990b5b76040539c931b1ca279e222">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
The set <i>A</i> = {<b>0</b>, <b>1</b>, <b>2</b>, <b>3</b>, <b>4</b>, <b>5</b>, <b>6</b>, <b>7</b>, <b>8</b>, <b>9</b>} is an alphabet. The following set of strings can be a language for representing positive integers between 1 and 9999 (inclusive):
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">  <i>L</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { <i>s</i> | <i>s</i> is a string of characters from <i>A</i>, <i>s</i> does not begin with <b>0</b>, 1 &le; |<i>s</i>| &le; 4 }
</td></tr></table></td></tr></table>
      </div></div></div></div>
  <a name="2.2"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#2.2">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">2.2.</span> Regular expressions</h3>
<span class="text top">If languages are merely subsets of the set of all finite character strings that can be built using the characters in an alphabet, then we can always specify any finite subset (and thus language) by simply writing down every string in the language. However, what if we want to write down the definition of that subset using a shorter representation, or we want to specify an infinitely large subset of character strings (e.g., all strings consisting of one or more copies of the character <b>a</b>: {<b>a</b>, <b>a</b><b>a</b>, <b>a</b><b>a</b><b>a</b>, ...})?</span><div class="paragraph">
Regular expressions are a notation for precisely and concisely defining certain sets of character strings.
      </div>
<a name="06defac822974dd688904a07cf4f6f18"></a><div class="linked block"><div class="link-block">[<a href="#06defac822974dd688904a07cf4f6f18">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
        
<span class="text">Given an alphabet <i>A</i>, a regular expression over <i>A</i> can contain any of the characters in <i>A</i> as well as any number of the following special characters:</span>
        <ul><li>the "or" symbol <b>|</b> consisting of single vertical bar;</li><li>the grouping symbols <b>(</b> and <b>)</b>, which must always be balanced the same way that parentheses must be balanced in arithmetic expressions;</li><li>the <b>+</b> and <b>*</b> symbols.</li></ul>
        
<span class="text">The subset of character strings that a regular expression defines can be determined in the following way:</span>
        <ul><li>a regular expression <i>r</i> that contains no special characters defines a set of strings containin just one string: {<i>r</i>};</li><li>if a regular expression <i>r</i><sub>1</sub> defines a set <i>S</i><sub>1</sub> and a regular expression <i>r</i><sub>2</sub> defines a set <i>S</i><sub>2</sub>, then the regular expression <i>r</i><sub>1</sub> <b>|</b> <i>r</i><sub>2</sub> defines the set of character strings <i>S</i><sub>1</sub> &cup; <i>S</i><sub>2</sub>;</li><li>if a regular expression <i>r</i> defines a set <i>S</i>, then the regular expression <b>(</b><i>r</i><b>)</b> defines the set of character strings <i>S</i> (i.e., there is no difference);</li><li>if a regular expression <i>r</i> defines a set <i>S</i>, then the regular expression <i>r</i><b>+</b> defines the set of character strings <i>S</i>' that consists of all possible concatenations of any of the strings in <i>S</i>;</li><li>if a regular expression <i>r</i> defines a set <i>S</i>, then the regular expression <i>r</i><b>*</b> defines the set of character strings <i>S</i>' that consists of all possible concatenations of any of the strings in <i>S</i>, as well as the empty string.</li></ul>
      </div></div></div>
<a name="1deeccf7a0e5426db9bd875b3b727e49"></a><div class="linked block"><div class="link-block">[<a href="#1deeccf7a0e5426db9bd875b3b727e49">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Assume that our alphabet consists of all alphanumeric characters. For each of the following regular expressions, describe verbally what set of character strings they define:</span>
        <ul><li><b>a</b><b>b</b><b>c</b><b>d</b></li><li><b>(</b><b>a</b><b>b</b><b>c</b><b>d</b><b>)</b>+</li><li><b>red | green | blue</b></li><li><b>(</b><b>red | green | blue</b><b>)</b>+</li><li><b>(0+) | (1+)</b></li><li><b>(0 | 1)</b>+</li></ul>
      </div></div></div>
<a name="98592789a35440a8ac6d28bbc97e0302"></a><div class="linked block"><div class="link-block">[<a href="#98592789a35440a8ac6d28bbc97e0302">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Assume that our alphabet consists of all alphanumeric characters. For each of the following verbal descriptions of sets of character strings, find a regular expression that defines the described set:</span>
        <ul><li>the set of character strings that consist entirely of vowels;</li><li>the set of all integers (negative and positive);</li><li>the set of all arithmetic expressions involving binary numbers, addition, and subtraction;</li><li>the set of all words that begin with a vowel and end with a vowel;</li><li>the set of all numbers of even length.</li></ul>
      </div></div></div>
<a name="791effdeab954f668592fa5324aff657"></a><div class="linked block"><div class="link-block">[<a href="#791effdeab954f668592fa5324aff657">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">In practice, programming languages that provide libraries of functions and procedures for working with regular expressions also support other special characters. For example, Python regular expressions may contain some of the following special characters:</span>
        <ul><li>the <code>\(</code>, <code>\)</code> special characters make it possible to include parentheses in expressions in a way that does not cause them to interpreted as regular expression grouping symbols;</li><li>the special symbol <code>\s</code> matches a single whitespace character;</li><li>the special symbol <code>[0-9]</code> matches a single numeric digit;</li><li>the special symbol <code>[a-z]</code> matches a single lowercase letter;</li><li>the special symbol <code>[A-Z]</code> matches a single uppercase letter;</li><li>the special symbol <code>[a-zA-Z]</code> matches a single letter;</li><li>the special symbol <code>[a-zA-Z0-9]</code> matches a single alphanumeric character.</li></ul>
      </div></div></div>
<a name="71f7125be5124059a51f065d1950e6e8"></a><div class="linked block"><div class="link-block">[<a href="#71f7125be5124059a51f065d1950e6e8">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">In the Python programming language, the <code>re</code> module provides functionality for automatically checking whether a string matches a particular regular expression. In order to check whether a string exactly matches a regular expression, it is necessary to wrap the regular expression in parentheses and then add special markers to ensure that the regular expression matches from the beginning of the string to the end of the string.</span>
        <div class="paragraph">
If a match succeeds, a match object is returned that contains additional information (e.g., the position of the match); otherwise, <code>None</code> is returned.
        </div>
        
<div class="code"><div class="source"><pre><code class="py">
>>> import re

>>> re.match(r"^(a|b|c)$", "a")   # Succeeds.
<_sre.SRE_Match object; span=(0, 1), match='a'>

>>> re.match(r"^(a|b|c)$", "def") # Fails.
None

>>> re.match(r"^((red|green|blue)+)$", "redgreenblueredblue")
<_sre.SRE_Match object; span=(0, 19), match='redgreenblueredblue'>

>>> re.match(r"^([a-zA-Z0-9]+)$", "redgreenblueredblue")
<_sre.SRE_Match object; span=(0, 19), match='redgreenblueredblue'>

>>> re.match(r"^([a-zA-Z0-9]+)$", "!@#$")
None
        </code></pre></div></div>   
      </div></div></div>
<a name="174fccbd604846ad92d764daf2393aa3"></a><div class="linked block"><div class="link-block">[<a href="#174fccbd604846ad92d764daf2393aa3">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="fact true_required"><span class="block_label">Fact:</span> 
        
<span class="text">Regular expressions are not powerful enough to describe many common languages in which we may be interested. Examples of sets of character strings that cannot be defined using regular expression include:</span>
        <ul><li>the set of arithmetic expressions with balanced parentheses;</li><li>the set of all palindromes;</li><li>the set of all strings in which the same string is repeated exactly two times in a row.</li></ul>
        
<span class="text">For languages such as the above, a more powerful tool for describing sets of character strings is needed.</span>
      </div></div></div></div>
  <a name="2.3"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#2.3">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">2.3.</span> Sets of token sequences</h3>
<span class="text top">Unlike human languagues, programming languages usually have a relatively small collection of symbol strings (e.g., commands or instructions) that are used to construct programs. Thus, we can adjust the definition of what constitutes a language to account for this.</span>
<a name="fe3a9fbf541445de977ab5df0e57621f"></a><div class="linked block"><div class="link-block">[<a href="#fe3a9fbf541445de977ab5df0e57621f">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
Given an alphabet <i>A</i>, a <i>token</i> is a finite, non-empty (usually short) string of characters from that alphabet.
      </div></div></div>
<a name="8f78a2be462e425da6c87339850e7f8b"></a><div class="linked block"><div class="link-block">[<a href="#8f78a2be462e425da6c87339850e7f8b">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
Given a set of tokens <i>T</i>, let <i>U</i> be the set of all finite sequences that can be built using tokens from <i>T</i> (including the empty sequence, which we will call &epsilon;). In other words, we can say:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">  <i>U</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { <i>s</i> | <i>s</i> is a finite sequence of tokens from <i>T</i> }
</td></tr></table></td></tr></table>
Any subset <i>L</i> &sub; <i>U</i> is a <i>language</i>. That is, any set of token sequences (whether the set is finite or infinite) is a language.
      </div></div></div>
<a name="06d4c9d409dc44ad8c1dccbef3412163"></a><div class="linked block"><div class="link-block">[<a href="#06d4c9d409dc44ad8c1dccbef3412163">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
Consider the following set of tokens:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>T</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { <b>true</b>, <b>false</b>, <b>or</b>, <b>and</b>, <b>not</b>, <b>(</b>, <b>)</b>, <b>,</b> }
</td></tr></table></td></tr></table>
The set of token sequences that represent valid boolean formulas is a language:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>L</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { <td></tr></table></td><td style="text-align:center;"> &nbsp;&nbsp;&nbsp;&nbsp; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>or ( false , and ( true , false ) )</b>, </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
   <td></tr></table></td><td style="text-align:center;"> &nbsp;&nbsp;&nbsp;&nbsp; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;">  <td></tr></table></td><td style="text-align:center;"> &nbsp;&nbsp;&nbsp;&nbsp; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>and ( true , false )</b>, </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
   <td></tr></table></td><td style="text-align:center;"> &nbsp;&nbsp;&nbsp;&nbsp; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;">  <td></tr></table></td><td style="text-align:center;"> &nbsp;&nbsp;&nbsp;&nbsp; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>not</b> <b>(</b> <b>false</b> <b>)</b>, </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
   <td></tr></table></td><td style="text-align:center;"> &nbsp;&nbsp;&nbsp;&nbsp; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;">  <td></tr></table></td><td style="text-align:center;"> &nbsp;&nbsp;&nbsp;&nbsp; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b>, </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
   <td></tr></table></td><td style="text-align:center;"> &nbsp;&nbsp;&nbsp;&nbsp; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;">  <td></tr></table></td><td style="text-align:center;"> &nbsp;&nbsp;&nbsp;&nbsp; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>false</b>, </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
   <td></tr></table></td><td style="text-align:center;"> &nbsp;&nbsp;&nbsp;&nbsp; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;">  <td></tr></table></td><td style="text-align:center;"> &nbsp;&nbsp;&nbsp;&nbsp; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> ... }
</td></tr></table></td></tr></table>
      </div></div></div>
<span class="text top">If a language is just a subset of the set of all possible token sequences, how do we mathematically specify interesting subsets?</span></div>
  <a name="2.4"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#2.4">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">2.4.</span> Language syntax and Backus-Naur Form (BNF) notation</h3>
<span class="text top">If a language is just a set of finite token strings, then defining a language amounts to defining this set. How can we define this set? By introducing a collection of rules or constraints governing how characters and/or tokens can be assembled to form strings or sequences in the language.</span>
<a name="7e82906541a4467faea16807f380dd44"></a><div class="linked block"><div class="link-block">[<a href="#7e82906541a4467faea16807f380dd44">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
Given a token set <i>T</i> and a language <i>L</i> consisting of finite sequences of tokens from <i>T</i>, the <i>syntax</i> of <i>L</i> is the set of rules defining <i>exactly</i> which token sequences are in <i>L</i>.
These rules are sometimes also called <i>syntactic rules</i>, a <i>formal grammar</i>, or simply a <i>grammar</i>.
      </div></div></div>
<span class="text top">There are many possible ways by which we could represent syntactic rules, and these rules can be classified, or stratified, according to their expressive power. A more extensive coverage of this topic is beyond the scope of this course, and is normally presented in courses on the theory of computation and automata. In this course, we will focus on two particular kinds of grammar: regular grammars and context-free grammars. The most common representation for such grammars is Backus-Naur Form, abbreviated henceforward as <i>BNF</i>.</span>
<a name="2075c983aff44402b4e5467cdd450d53"></a><div class="linked block"><div class="link-block">[<a href="#2075c983aff44402b4e5467cdd450d53">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
A grammar definition consists of one or more <i>productions</i> (or <i>production rules</i>). Each production has the following form:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>non-terminal</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>terminal_or_non-terminal</i>  ...  <i>terminal_or_non-terminal</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                    <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>terminal_or_non-terminal</i> ... <i>terminal_or_non-terminal</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                    <td></tr></table></td><td style="text-align:center;"> &#8942; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                    <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>terminal_or_non-terminal</i> ... <i>terminal_or_non-terminal</i>
</td></tr></table></td></tr></table>
The left-hand side (to the left of the ::= symbol) in each production is called a <i>non-terminal</i>. The right-hand side of each production is an unordered collection of <i>choices</i> separated by the | symbol. Each choice is a <i>sequence</i> of non-terminals (which must appear once on the left-hand side of a production) or <i>terminals</i> (a terminal is a token).
      </div></div></div>
<span class="text top">These production rules in a grammar's BNF representation can be viewed both as a way to construct an element (i.e., a token sequence that is a program) in the language, or as a way to break down a token sequence piece by piece until nothing is left.</span>
<a name="16147b7c6f904109b9900322be8ad838"></a><div class="linked block"><div class="link-block">[<a href="#16147b7c6f904109b9900322be8ad838">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
Let <i>T</i> be a token set:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>T</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { <b>true</b> }
</td></tr></table></td></tr></table>
The following is a very simple programming language that contains only a single possible token sequence consisting of the single token <b>true</b>:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b>
</td></tr></table></td></tr></table>
In this case, the language is finite and small, so we can actually write it down as a set:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>L</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { <b>true</b> }
</td></tr></table></td></tr></table>
      </div></div></div>
<a name="b8f92b53cb7449998112583773b3d97c"></a><div class="linked block"><div class="link-block">[<a href="#b8f92b53cb7449998112583773b3d97c">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
We can extend the language by adding another token:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>T</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { <b>true</b>, <b>false</b> }
</td></tr></table></td></tr></table>
The following BNF grammar definition now contains two choices (each choice is a sequence consisting of a single terminal):
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>false</b>
</td></tr></table></td></tr></table>
This programming language now contains two token sequences:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>L</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { <b>true</b>, <b>false</b> }
</td></tr></table></td></tr></table>
      </div></div></div>
<a name="9380e58ddbde4fe88ddb2daff5bd4617"></a><div class="linked block"><div class="link-block">[<a href="#9380e58ddbde4fe88ddb2daff5bd4617">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
We can extend the language definition further:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>T</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { <b>true</b>, <b>false</b>, <b>or</b>, <b>and</b>, <b>not</b>, <b>(</b>, <b>)</b>, <b>,</b> }
</td></tr></table></td></tr></table>
The following BNF grammar definition now contains five choices (each choice is a sequence consisting of non-terminals and terminals):
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>false</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>and (</b> <i>program</i> <b>,</b> <i>program</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>or (</b> <i>program</i> <b>,</b> <i>program</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>not (</b> <i>program</i> <b>)</b>
</td></tr></table></td></tr></table>
This programming language now contains infinitely many finite token sequences:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>L</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { <td></tr></table></td><td style="text-align:center;"> &nbsp;&nbsp;&nbsp;&nbsp; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>or ( false , and ( true , false ) )</b>, </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
   <td></tr></table></td><td style="text-align:center;"> &nbsp;&nbsp;&nbsp;&nbsp; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;">  <td></tr></table></td><td style="text-align:center;"> &nbsp;&nbsp;&nbsp;&nbsp; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>and ( true , false )</b>, </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
   <td></tr></table></td><td style="text-align:center;"> &nbsp;&nbsp;&nbsp;&nbsp; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;">  <td></tr></table></td><td style="text-align:center;"> &nbsp;&nbsp;&nbsp;&nbsp; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>not</b> <b>(</b> <b>false</b> <b>)</b>, </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
   <td></tr></table></td><td style="text-align:center;"> &nbsp;&nbsp;&nbsp;&nbsp; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;">  <td></tr></table></td><td style="text-align:center;"> &nbsp;&nbsp;&nbsp;&nbsp; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b>, </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
   <td></tr></table></td><td style="text-align:center;"> &nbsp;&nbsp;&nbsp;&nbsp; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;">  <td></tr></table></td><td style="text-align:center;"> &nbsp;&nbsp;&nbsp;&nbsp; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>false</b>, </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
   <td></tr></table></td><td style="text-align:center;"> &nbsp;&nbsp;&nbsp;&nbsp; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;">  <td></tr></table></td><td style="text-align:center;"> &nbsp;&nbsp;&nbsp;&nbsp; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> ... }
</td></tr></table></td></tr></table>
      </div></div></div>
<a name="8c1203dd65bb49868abc64ad5353725f"></a><div class="linked block"><div class="link-block">[<a href="#8c1203dd65bb49868abc64ad5353725f">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
Let us consider another example: a language of positive integers.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>T</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { <b>0</b>, <b>1</b>, <b>2</b>, <b>3</b>, <b>4</b>, <b>5</b>, <b>6</b>, <b>7</b>, <b>8</b>, <b>9</b> }
</td></tr></table></td></tr></table>
We can define the following grammar:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>number</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>0</b> | <b>1</b> | <b>2</b> | <b>3</b> | <b>4</b> | <b>5</b> | <b>6</b> | <b>7</b> | <b>8</b> | <b>9</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
  <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>1</b> <i>number</i> | <b>2</b> <i>number</i> | <b>3</b> <i>number</i> | <b>4</b> <i>number</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
  <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>5</b> <i>number</i> | <b>6</b> <i>number</i> | <b>7</b> <i>number</i> | <b>8</b> <i>number</i> | <b>9</b> <i>number</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
</td></tr></table></td></tr></table>
However, the above does not allow us to have a <b>0</b> in any number with more than one digit. One way to fix this (there are many other ways) is to introduce more productions into the grammar:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>nozero</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>1</b> | <b>2</b> | <b>3</b> | <b>4</b> | <b>5</b> | <b>6</b> | <b>7</b> | <b>8</b> | <b>9</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>digit</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>0</b> | <i>nozero</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>digits</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>digit</i> | <i>digit</i> <i>digits</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>number</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>digit</i> | <i>nozero</i> <i>digits</i>
</td></tr></table></td></tr></table>
      </div></div></div>
<span class="text top">Note that the grammar may contain multiple productions. Any non-terminal defined in a production can appear on the right-hand side of any of the productions.</span>
<a name="19dc317f45ec4ae18018ca5b17fce114"></a><div class="linked block"><div class="link-block">[<a href="#19dc317f45ec4ae18018ca5b17fce114">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
We can extend the language by adding a production for statements, and allowing a program to be a sequence of one or more statements.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>T</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { <b>true</b>, <b>false</b>, <b>or</b>, <b>and</b>, <b>not</b>, <b>(</b>, <b>)</b>, <b>,</b>, <b>print</b>, <b>skip</b>, <b>;</b> }
</td></tr></table></td></tr></table>
The following is the new grammar definition for this language.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>statement</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>statement</i> <i>program</i>  </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>statement</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>print</b> <i>formula</i> <b>;</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>skip</b> <b>;</b>  </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>formula</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>false</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>not (</b> <i>formula</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>and (</b> <i>formula</i> <b>,</b> <i>formula</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>or (</b> <i>formula</i> <b>,</b> <i>formula</i> <b>)</b>
</td></tr></table></td></tr></table>
      </div></div></div></div>
</div>
<a name="3"></a>
<div class="section"><hr /><h2 class="linked"><span class="link-title">[<a href="#3">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">3.</span> Parsing</h2>
<span class="text top">Given a programming language definition, we want to have the ability to operate on programs written in that language using a computer. To do so, we need to convert the character string representations of programs in that programming language into instances of a data structure; each data structure instance would then be a representation of the program as data.</span>
  <a name="3.1"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#3.1">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">3.1.</span> Concrete and abstract syntaxes</h3>
<a name="e601deb568ed46a1a1d741907a6dcfa9"></a><div class="linked block"><div class="link-block">[<a href="#e601deb568ed46a1a1d741907a6dcfa9">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
Given an alphabet, token set, and grammar definition (e.g., represented using BNF notation), we define the <i>concrete syntax</i> to be the set of all character strings that conform to the grammar definition. We call a particular character string that conforms to the grammar definition a <i>concrete syntax instance</i>.
      </div></div></div>
<a name="db9e874ec6b6475a93bc3ef4db0f2066"></a><div class="linked block"><div class="link-block">[<a href="#db9e874ec6b6475a93bc3ef4db0f2066">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
For a particular programming language definition, we define the <i>abstract syntax</i> to be the set of all data structure instances that correspond to a character string that conforms to the grammar definition for that language. An instance of the abstract syntax is sometimes called a <i>parse tree</i>.
      </div></div></div>
<a name="4ba33545333f48e88baddfa4507a1db0"></a><div class="linked block"><div class="link-block">[<a href="#4ba33545333f48e88baddfa4507a1db0">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Consider again the language that conforms to the following grammar:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> | <b>false</b> | <b>not (</b> <i>program</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>and (</b> <i>program</i> <b>,</b> <i>program</i> <b>)</b> | <b>or (</b> <i>program</i> <b>,</b> <i>program</i> <b>)</b> 
</td></tr></table></td></tr></table>
The following is the character string of one possible program in the language. This character string is an instance of the concrete syntax of the language.</span>
        
<div class="code"><div class="source"><pre><code class="py">
and (or (and (true, false), not(false)), or (true, false))
        </code></pre></div></div>
        
<span class="text">The above character string might be converted into a structured representation of the program within some host language (i.e., the programming language being used to operate on these programs: checking for errors, interpreting, or compiling the program). Below, we present one possible Python representation of the instance of the abstract syntax (i.e., the parse tree) corresponding to the concrete syntax instance above. This representation uses nested Python dictionaries to represent the parse tree, with strings being used to represent node labels and leaves.</span>
        
<div class="code"><div class="source"><pre><code class="py">
{ "And": [
    { "Or": [
        { "And": ["True","False"]}, 
        { "Not": ["False"]}
      ]
    }, 
    { "Or": ["True","False"]}
  ]
}
        </code></pre></div></div>
      </div></div></div></div>
  <a name="3.2"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#3.2">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">3.2.</span> Lexing (a.k.a., tokenizing) and parsing</h3>
<a name="3f625b68bc8a426c80fe1c774e04c362"></a><div class="linked block"><div class="link-block">[<a href="#3f625b68bc8a426c80fe1c774e04c362">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
A <i>lexer</i> or <i>tokenizer</i> is an algorithm that converts an instance of the concrete syntax of a language (i.e., a character string that conforms to the grammar definition for the language) into a sequence of tokens.
      </div></div></div>
<a name="2c7cc0e69813454eafc7128e5ac57055"></a><div class="linked block"><div class="link-block">[<a href="#2c7cc0e69813454eafc7128e5ac57055">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Consider again the language that conforms to the following grammar:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> | <b>false</b> | <b>not (</b> <i>program</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>and (</b> <i>program</i> <b>,</b> <i>program</i> <b>)</b> | <b>or (</b> <i>program</i> <b>,</b> <i>program</i> <b>)</b> 
</td></tr></table></td></tr></table>
The following Python implementation of a tokenizing algorithm for this language uses regular expressions to split a character string into a sequence of individual tokens from the token set.</span>
        
<div class="code"><div class="source"><pre><code class="py">
import re
def tokenize(s):
    # Use a regular expression to split the string into
    # tokens or sequences of zero or more spaces.
    tokens = [t for t in re.split(r"(\s+|true|false|and|or|not|,|\(|\))", s)]

    # Throw out the spaces and return the result.
    return [t for t in tokens if not t.isspace() and not t == ""]
        </code></pre></div></div>
        
<span class="text">Below is an example input and output.</span>
        
<div class="code"><div class="source"><pre><code class="py">
>>> tokenize("and (or (and (true, false), not(false)), or (true, false))")

['and', '(', 'or', '(', 'and', '(', 'true', ',', 'false', ')', ',', 'not', 
 '(', 'false', ')', ')', ',', 'or', '(', 'true', ',', 'false', ')', ')']
        </code></pre></div></div>
      </div></div></div>
<a name="3c944fff48f246aba9409f76e48ccef4"></a><div class="linked block"><div class="link-block">[<a href="#3c944fff48f246aba9409f76e48ccef4">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
A <i>parser</i> is an algorithm that converts a token sequence into an instance of the abstract syntax (i.e., a parse tree).
      </div></div></div>
<span class="text top">The tokenizer and parser are then composed to transform a character string into a parse tree.</span>
<a name="a928f667dad647659519275ac46bbe29"></a><div class="linked block"><div class="link-block">[<a href="#a928f667dad647659519275ac46bbe29">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="diagram other">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">character string<br/>(concrete syntax)</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">lexer/<br/>tokenizer</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">token<br/>sequence</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">parser</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">parse tree<br/>(abstract syntax)</td>
  </tr>
</table>
      </div></div></div>
<span class="text top">Often, the tokenizer and parser are together called a <i>parser</i>. In situations where this can cause confusion, we will refer to the actual process that converts token sequences into parse trees as the <i>parsing algorithm</i>.</span>
<a name="60d3952f533a4306a9c3167d6a33bae1"></a><div class="linked block"><div class="link-block">[<a href="#60d3952f533a4306a9c3167d6a33bae1">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="diagram other">
<table class="container">
  <tr>
  <td class="box" style="background-color:powderblue;">character string<br/>(concrete syntax)</td>
  <td><span style="font-size:20px;">&#8658;</span></td>
  <td class="box" style="background-color:#EFEFEF;">
  <table class="container">
    <tr>
    <td class="box" style="background-color:lightyellow;">lexer/<br/>tokenizer</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">token<br/>sequence</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">parsing<br/>algorithm</td>
    </tr>
  </table>
  <br/>parser
  </td>
  <td><span style="font-size:20px;">&#8658;</span></td>
  <td class="box" style="background-color:powderblue;">parse tree<br/>(abstract syntax)</td>
  </tr>
</table>
      </div></div></div>
<span class="text top">The BNF representation of a grammar can be converted into a parsing algorithm that turns a token sequence into an abstract syntax data structure instance (i.e., a parse tree). How easily this can be done depends on the properties of the grammar.</span>
<a name="47254608df414ace8d04c630a2b15689"></a><div class="linked block"><div class="link-block">[<a href="#47254608df414ace8d04c630a2b15689">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="fact true_required"><span class="block_label">Fact:</span> 
Given a BNF representation of a grammar, if for every production in the grammar, each choice begins with a unique terminal (i.e., a terminal that is <i>not</i> the first terminal in any other choice within that production), then we say the grammar is in <i>LL(1)</i> form, and we can implement a <i>predictive recursive descent</i> parsing algorithm to parse any token sequence that conforms to this grammar (note that these are only <i>sufficient</i> conditions for the grammar to be in LL(1) form; less restrictive conditions also exist).
      </div></div></div>
<span class="text top">A predictive recursive descent parser can effectively run in linear time; it decomposes the token sequence from left to right while assembling a parse tree.</span>
<a name="2cd418f2876c42d59a57e34bd6288f22"></a><div class="linked block"><div class="link-block">[<a href="#2cd418f2876c42d59a57e34bd6288f22">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Consider again the language that conforms to the following grammar:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> | <b>false</b> | <b>not (</b> <i>program</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>and (</b> <i>program</i> <b>,</b> <i>program</i> <b>)</b> | <b>or (</b> <i>program</i> <b>,</b> <i>program</i> <b>)</b> 
</td></tr></table></td></tr></table>
The following Python implementation of a predictive recursive descent parsing algorithm for this language builds a parse tree using the nested dictionary representation seen in <a href="#4ba33545333f48e88baddfa4507a1db0">a previous example</a>. This recursive algorithm takes a single argument: a sequence of tokens. It returns two results: a parse tree, and the remainder of the token sequence. <b>Note that the order in which the choices in the production are being handled is not determined by the order of the choices in the production.</b> The choices in a production are unordered; any parser implementation that captures all the possible choices conforms to the grammar definition.</span>
        
<div class="code"><div class="source"><pre><code class="py">
def parse(tokens):
    if tokens[0] == 'true':
        return ('True', tokens[1:])

    if tokens[0] == 'false':
        return ('False', tokens[1:])

    if tokens[0] == 'not' and tokens[1] == '(':
        (e1, tokens) = parse(tokens[2:])
        if tokens[0] == ')':
          return ({'Not':[e1]}, tokens[1:])

    if tokens[0] == 'or' and tokens[1] == '(':
        (e1, tokens) = parse(tokens[2:])
        if tokens[0] == ',':
            (e2, tokens) = parse(tokens[1:])
            if tokens[0] == ')':
                return ({'Or':[e1,e2]}, tokens[1:])

    if tokens[0] == 'and' and tokens[1] == '(':
        (e1, tokens) = parse(tokens[2:])
        if tokens[0] == ',':
            (e2, tokens) = parse(tokens[1:])
            if tokens[0] == ')':
                return ({'And':[e1,e2]}, tokens[1:])
        </code></pre></div></div>
        
<span class="text">Below is an example input and output. Notice that no tokens are left in the token sequence once the result is returned.</span>
        
<div class="code"><div class="source"><pre><code class="py">
>>> import json
>>> (tree, tokens) =\
      parse(tokenize(\
        "and (or (and (true, false), not(false)), or (true, false))"\
        )\
      )
>>> print(json.dumps(tree, sort_keys=True, indent=2))
{
  "And": [
    {
      "Or": [
        {
          "And": [
            "True", 
            "False"
          ]
        }, 
        {
          "Not": [
            "False"
          ]
        }
      ]
    }, 
    {
      "Or": [
        "True", 
        "False"
      ]
    }
  ]
}
>>> print(tokens)
[]
        </code></pre></div></div>
      </div></div></div>
<a name="95cb72f5b4d24ddba2c8081c7b42618a"></a><div class="linked block"><div class="link-block">[<a href="#95cb72f5b4d24ddba2c8081c7b42618a">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="fact true_required"><span class="block_label">Fact:</span> 
If we relax the conditions on the grammar definition that make it LL(1) by dropping the requirement that the first terminal in each sequence within a production must be unique, we can no longer use predictive recursive descent parsing algorithm to parse a language corresponding to this grammar because the first terminal in each sequence within a production no longer uniquely determines which choice within a production should be used to continue parsing a token sequence. However, as long as every sequence within every production starts with a terminal, we can implement a <i>backtracking recursive descent</i> parsing algorithm to parse token sequence in the language.
      </div></div></div>
<a name="5917f6f5de7c46079190f4b6c4961ca3"></a><div class="linked block"><div class="link-block">[<a href="#5917f6f5de7c46079190f4b6c4961ca3">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">In the previus example, the grammar only allowed prefix logical operators. Suppose we wanted to parse token sequences for a grammar with infix operators.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> | <b>false</b> | <b>not (</b> <i>program</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>(</b> <i>program</i> <b>and</b> <i>program</i> <b>)</b> | <b>(</b> <i>program</i> <b>or</b> <i>program</i> <b>)</b> 
</td></tr></table></td></tr></table>
It is no longer possible to implement a predictive recursive descent parser. We must instead employ backtracking, and we must also keep track of whether we have consumed all the tokens.</span>
        
<div class="code"><div class="source"><pre><code class="py">
def parse(tmp, top = True):
    tokens = tmp[0:]
    if tokens[0] == 'true':
        tokens = tokens[1:]
        if not top or len(tokens) == 0:
            return ('True', tokens)

    tokens = tmp[0:]
    if tokens[0] == 'false':
        tokens = tokens[1:]
        if not top or len(tokens) == 0:
            return ('False', tokens)

    tokens = tmp[0:]
    if tokens[0] == 'not' and tokens[1] == '(':
        tokens = tokens[2:]
        r = parse(tokens, False)
        if not r is None:
            (e1, tokens) = r
            if tokens[0] == ')':
                tokens = tokens[1:]
                if not top or len(tokens) == 0:
                    return ({'Not':[e1]}, tokens)

    tokens = tmp[0:]
    if tokens[0] == '(':
        tokens = tokens[1:]
        r = parse(tokens, False)
        if not r is None:
            (e1, tokens) = r
            if tokens[0] == 'or':
                tokens = tokens[1:]
                r = parse(tokens, False)
                if not r is None:
                    (e2, tokens) = r
                    if tokens[0] == ')':
                        tokens = tokens[1:]
                        if not top or len(tokens) == 0:
                            return ({'Or':[e1,e2]}, tokens)

    tokens = tmp[0:]
    if tokens[0] == '(':
        tokens = tokens[1:]
        r = parse(tokens, False)
        if not r is None:
            (e1, tokens) = r
            if tokens[0] == 'and':
                tokens = tokens[1:]
                r = parse(tokens, False)
                if not r is None:
                    (e2, tokens) = r
                    if tokens[0] == ')':
                        tokens = tokens[1:]
                        if not top or len(tokens) == 0:
                            return ({'And':[e1,e2]}, tokens)
        </code></pre></div></div>
        
<span class="text">The above code is far too repetitive. However, we can take the parts that repeat and turn them into a loop body that loops over all the possible choices in the production.</span>
        
<div class="code"><div class="source"><pre><code class="py">
def parse(tmp, top = True):
    seqs = [\
        ('True', ['true']), \
        ('False', ['false']), \
        ('Not', ['not', '(', parse, ')']), \
        ('And', ['(', parse, 'and', parse, ')']), \
        ('Or', ['(', parse, 'or', parse, ')']) \
        ]

    # Try each choice sequence.
    for (label, seq) in seqs:
        tokens = tmp[0:]
        ss = [] # To store matched terminals.
        es = [] # To collect parse trees from recursive calls.
        
        # Walk through the sequence and either
        # match terminals to tokens or make
        # recursive calls depending on whether
        # the sequence entry is a terminal or
        # parsing function.
        for x in seq:
            if type(x) == type(""): # Terminal.

                if tokens[0] == x: # Does terminal match token?
                    tokens = tokens[1:]
                    ss = ss + [x]
                else:
                    break # Terminal did not match token.

            else: # Parsing function.

                # Call parsing function recursively
                r = x(tokens, False) 
                if not r is None:
                    (e, tokens) = r
                    es = es + [e]

        # Check that we got either a matched token
        # or a parse tree for each sequence entry.
        if len(ss) + len(es) == len(seq):
            if not top or len(tokens) == 0:
                return ({label:es} if len(es) > 0 else label, tokens)
        </code></pre></div></div>
      </div></div></div></div>
  <a name="3.3"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#3.3">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">3.3.</span> More parsing examples and building parsers for other classes of grammar</h3>
<a name="7c9969979aa04b03a4fbecdaca21880e"></a><div class="linked block"><div class="link-block">[<a href="#7c9969979aa04b03a4fbecdaca21880e">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="exercise task_required"><span class="block_label">Exercise:</span> 
        
<span class="text">Consider the following grammar definition:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>command</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>start</b>  </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>suspend</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>wake</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>terminate</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>reboot</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>if</b> <i>condition</i> <b>then</b> <i>command</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>if</b> <i>condition</i> <b>then</b> <i>command</i> <b>else</b> <i>command</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>repeat</b> <i>command</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>while</b> <i>condition</i> <b>then</b> <i>command</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>condition</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>power low</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>temperature high</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>temperature very low</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>user input</b>
</td></tr></table></td></tr></table>
Suppose we want to implement a parser for the above grammar. A partial implementation of a parser for the above grammar (what has been presented in lecture so far) is provided below.</span>
        
<div class="code"><div class="source"><pre><code class="py">
def command(tokens, top = True):
    seqs = {\
       ("Start", "start"),\
       ("Suspend", "suspend"),\
       ("Wake", "wake"),\
       ("Terminate", "terminate"),\
       ("Reboot", "reboot")\
       }
    for (key, value) in seqs:
        if tokens[0] == value:
            tokens = tokens[1:]
            if not top or len(tokens) == 0:
                return (key, tokens)
    
    if tokens[0] == 'repeat':
        r = command(tokens[1:], False)
        if not r is None:
            (e, tokens) = r
            if not top or len(tokens) == 0:
                return ({"Repeat": [e]}, tokens)

    if tokens[0] == 'while':
        r = condition(tokens[1:], False)
        if not r is None:
            (e1, tokens) = r
            if tokens[0] == 'then':
                 r = command(tokens[1:], False)
                 if not r is None:
                     (e2, tokens) = r           
                     if not top or len(tokens) == 0:
                         return ({"While": [e1,e2]}, tokens)

def condition(tokens, top = True):
    seqs = [\
       ("PowerLow", ["power", "low"]),\
       ("TempHigh", ["temperature", "high"]),\
       ("UserInput", ["user", "input"])\
       ]
    for (key, seq) in seqs:
        if tokens[0] == seq[0]:
            if tokens[1] == seq[1]:
                tokens = tokens[2:]
                if not top or len(tokens) == 0:
                    return (key, tokens)
        </code></pre></div></div>
        
<span class="text">It is possible to replace the <code>condition()</code> function with a generic parser for base cases that contain an arbitrary number of terminals in each sequence.
Any call to <code>condition(...)</code> can then be replaced with a call to <code>parseBaseCases(seqsCondition, ...)</code>.</span>
        
<div class="code"><div class="source"><pre><code class="py">
seqsCondition = [\
       ("PowerLow", ["power", "low"]),\
       ("TempHigh", ["temperature", "high"]),\
       ("TempVeryLow", ["temperature", "very", "low"]),\
       ("UserInput", ["user", "input"])\
       ]

def parseBaseCases(seqs, tokens, top = True):
    for (key, seq) in seqs:
         # Check if token sequence matches sequence.
        i = 0
        for terminal in seq:
            if terminal == tokens[i]:
                pass
            else:
                break
            i = i + 1
                
        # Check if the previous loop succeeded.
        if i == len(seq):
            tokens = tokens[len(seq):]
            if not top or len(tokens) == 0:
                return (key, tokens)
        </code></pre></div></div>
      </div></div></div>
<a name="b1e8bae08f134922b2bdc85fd206cbe4"></a><div class="linked block"><div class="link-block">[<a href="#b1e8bae08f134922b2bdc85fd206cbe4">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Consider the following grammar definition:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>formula</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>false</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>not</b> <i>formula</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>(</b> <i>formula</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>formula</i> <b>and</b> <i>formula</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>formula</i> <b>or</b> <i>formula</i> 
</td></tr></table></td></tr></table>
Implementing a naive recursive descent parser, predictive or backtracking, would not work for this grammar. Consider what would happen if we ran the following code on any input:</span>
        
<div class="code"><div class="source"><pre><code class="py"> 
def parse(tokens):
    if tokens[0] == 'true':
        return ('True', tokens[1:])

    if tokens[0] == 'false':
        return ('False', tokens[1:])

    # ...

    # Recursive call, but no tokens consumed.
    (e1, tokens) = parse(tokens) 
      if tokens[0] == 'and':
        (e2, tokens) = parse(tokens[1:])
        return ({'And':[e1,e2]}, tokens[1:])

    # ...
        </code></pre></div></div>
        
<span class="text">The above code never terminates, and after a large number of recursive calls are made, the Python interpreter returns an error indicating it is out of stack space.
To get around this problem, one option is to perform <i>left-recursion elimination</i> on the grammar so that a recursive call never occurs first for any of the choices.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>formula</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>left</i> <b>and</b> <i>formula</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>left</i> <b>or</b> <i>formula</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>left</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>left</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>false</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>not</b> <i>formula</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>(</b> <i>formula</i> <b>)</b>
</td></tr></table></td></tr></table>
The above is usually acceptable if the operator, such as <b>and</b>, is commutative or right-associative. However, if the operator is left-associative, the above strategy would not necessarily lead to a correct parse tree. Can you explain why? In such a scenario, other techniques would need to be employed. If the operator is indeed associative or right-associative, however, the parser implementation could then look something like the following:</span>
        
<div class="code"><div class="source"><pre><code class="py"> 
def formula(tmp):
    tokens = tmp[0:]
    (e1, tokens) = left(tokens)
      if tokens[0] == 'and':
        (e2, tokens) = formula(tokens[1:])
        return ({'And':[e1,e2]}, tokens[1:])

    # ...

def left(tokens):
    if tokens[0] == 'true':
        return ('True', tokens[1:])

    if tokens[0] == 'false':
        return ('False', tokens[1:])

    # ...
        </code></pre></div></div>
        
<span class="text">Note that performing left-recursion elimination does <i>not</i> necessarily change the definition of the concrete syntax, the definition of the abstract syntax of a language (i.e., the set of parse trees), or the meaning of a language. Left-recursion elimination is a strategy for converting a grammar definition into a definition that is easier to implement using a recursive descent parser; it is an implementation strategy. Thus, the resulting parse trees should contain no record or indication that left-recursion elimination was performed on the grammar before the parser was implemented.</span>
        <div class="paragraph"> 
Also note that the resulting parser implementation <code>formula()</code> uses backtracking because the <i>formula</i> production rule has three choices that all begin with the same non-terminal <i>left</i>. It would be possible to perform left factoring on the <i>formula</i> production rule as follows, which would then make it possible to implement <code>formula()</code> as a predictive parser:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>formula</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>left</i> <i>rest</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>rest</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>and</b> <i>formula</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>or</b> <i>formula</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;">
</td></tr></table></td></tr></table>
        </div>
      </div></div></div></div>
</div>
<a name="4"></a>
<div class="section"><hr /><h2 class="linked"><span class="link-title">[<a href="#4">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">4.</span> Semantics, Evaluation, and Interpretation</h2>
  <a name="4.1"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#4.1">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">4.1.</span> Formally defining an abstract syntax</h3>
<span class="text top">While the abstract syntax of a programming language is the set of data structure instances that represent programs, it is also useful to model the abstract syntax as a mathematical object in its own right. This makes it possible to define formally (i.e., mathematically, independently of any implementation language, platform, operating system, and so on) the meaning of a language, and how programs can be run. It also makes it possible to formally define analyses on programs, as well as properties of transformations over programs.</span><div class="paragraph">
Typically, an abstract syntax definition will closely match a concrete syntax definition, except that there is no need to specify the token set, and redundant syntactic constructs and syntactic sugar will be eliminated. For example, parentheses are a syntactic convention that is not necessary if one is working with parse trees because parse trees are already grouped implicitly due to the tree structure of the abstract syntax instance.
      </div>
<a name="7bf280c88ee14a299c3490762a33e4dd"></a><div class="linked block"><div class="link-block">[<a href="#7bf280c88ee14a299c3490762a33e4dd">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">The following is an example of an abstract syntax definition.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>formula</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> | <b>false</b> | <b>not</b> <i>formula</i> | <i>formula</i> <b>and</b> <i>formula</i> | <i>formula</i> <b>or</b> <i>formula</i>
</td></tr></table></td></tr></table>
Notice the omission of the parentheses. Also, there is no need to be concerned with the fixity (i.e., infix vs. prefix) of binary operators, since this definition is not being used to implement a parsing algorithm.</span>
      </div></div></div></div>
  <a name="4.2"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#4.2">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">4.2.</span> Denotational semantics and operational semantics</h3>
<span class="text top">The abstract syntax of a programming language is a set of symbolic objects (i.e., the abstract syntax instances, such as programs) that have no meaning unless a meaning is assigned to them. There are two ways in which we can assign meaning to these objects. We can choose to assign a mathematical object to each abstract syntax instance, or we can define a collection of deterministic transformations that specify how we can convert each abstract syntax instance into another abstract syntax instance. Roughly speaking, assigning a mathematical object to each program tells us what it <i>means</i>, while specifying symbolic converion rules tells us how to <i>run</i> the program.</span>
<a name="41aa3d27c2754fa880cb8c2280322f63"></a><div class="linked block"><div class="link-block">[<a href="#41aa3d27c2754fa880cb8c2280322f63">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
The <i>denotational semantics</i> of an abstract syntax is a mapping from the set of abstract syntax instances <i>A</i> to some mathematical set of objects <i>D</i>, which is often called a <i>semantic domain</i> or just <i>domain</i>. The mapping from <i>A</i> to <i>D</i> itself is often denoted using the circumfix Oxford double bracket notation [[ ... ]], and the definition of a denotational semantics of <i>A</i> (i.e., the definition of this mapping [[ ... ]]) is often specified using a collection of inference rules.
      </div></div></div>
<a name="63092f7e13d44b0cac8bde679e6f2c6d"></a><div class="linked block"><div class="link-block">[<a href="#63092f7e13d44b0cac8bde679e6f2c6d">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
Let <i>A</i> be an abstract syntax of a programming language. The <i>operational semantics</i> of an abstract syntax is a set of rules that specify how each abstract syntax instance <i>a</i> <span style="font-size:12px;">&#8712;</span> <i>A</i> can be transformed some kind of object that represents the result of performing the computation described by <i>A</i>.
      </div></div></div>
<span class="text top">There are distinct kinds of operational semantics, such as <i>small-step semantics</i> and <i>big-step semantics</i> (also known as <i>natural semantics</i>). In this course, the operational semantics we will be using is closest to big-step semantics, with some simplifications. We adopt this particular approach to defining operational semantics because it corresponds more closely to a functional, recursive implementation of an algorithm for interpreting programs.
<br/><br/>
The operational semantics for a programming language represents a <i>contract</i>, a set of <i>constraints</i>, or a set of <i>requirements</i> that an algorithm that implementing an interpreter or compiler of that language must respect in order to be considered correct. However, whoever builds an implementation of an interpreter or compiler for a language has full freedom and flexibility in how they choose to implement the interpreter in all other aspects as long as it conforms to the operational semantics. This is what makes it possible to introduce optimizations into interpreters and compilers (such as optimizations to improve performance or reduce use of memory) while preserving the correctness of their behavior. The operational semantics for a programming language is defined using a collection of <i>inference rules</i>.</span>
<a name="9af40ca04b2f44c795bbb02e7bed83ef"></a><div class="linked block"><div class="link-block">[<a href="#9af40ca04b2f44c795bbb02e7bed83ef">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
        
<span class="text">An <i>inference rule</i> is a notation used within mathematics and computer science to define relationships between mathematical facts and formulas. Each inference rule consists of a horizontal line with zero or more logical formulas above the line and one logial formula below the line. The logical formulas above the line are called <i>premises</i>, and the formula below the line is called the <i>conclusion</i>.</span>
        <div class="inferences"><table class="inference"><tr><td class="title">[Name-of-Inference-Rule]</td><td><table><tr><td class="premises">&nbsp;<i>premise</i> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>premise</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>conclusion</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Example]</td><td><table><tr><td class="premises">&nbsp;<b>sun is out</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <b>sky is clear</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>it is not raining</b>&nbsp;</td></tr></table></td></tr></table></div>
        
<span class="text">An inference rule can be interpreted as a portion of a larger algorithm. The premises specify the recursive calls, or calls to other functions, that may need to be made, and the results that are obtained from those invocations. The conclusion specifies what inputs can be handled by that inference rule, and what outputs should be returned given those inputs and the premises.</span>
        <div class="inferences"><table class="inference"><tr><td class="title">[Algorithm-Case]</td><td><table><tr><td class="premises">&nbsp;<i>input<sub>1</sub></i> &dArr; <i>output<sub>1</sub></i> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>input<sub>2</sub></i> &dArr; <i>output<sub>2</sub></i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>input<sub>0</sub></i> &dArr; <i>output<sub>0</sub></i>&nbsp;</td></tr></table></td></tr></table></div>
        
<span class="text">Note that in the above, <i>input<sub>1</sub></i> and <i>input<sub>2</sub></i> may depend on <i>input<sub>0</sub></i>, and <i>output<sub>0</sub></i> may depend on <i>output<sub>1</sub></i> and <i>output<sub>2</sub></i>. In other words, one could rewrite an inference rule in the following way using natural language:</span>
        <div class="inferences"><table class="inference"><tr><td class="title">[Algorithm-Case]</td><td><table><tr><td class="premises">&nbsp;<b>invoking this or another algorithm with</b> <i>input<sub>1</sub></i> <b>yields</b> <i>output<sub>1</sub></i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>given</b> <i>input<sub>0</sub></i>, <b> and if premises above are true, then output</b> <i>output<sub>0</sub></i>&nbsp;</td></tr></table></td></tr></table></div>
       </div></div></div></div>
  <a name="4.3"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#4.3">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">4.3.</span> Evaluation of expressions</h3>
<span class="text top">The abstract syntax, or a subset of the abstract syntax, of a programming language is considered to be a set of <i>expressions</i> if the language's operational semantics do not impose any restrictions on the <i>order</i> in which a computation can operate on the expression to produce a result, called a <i>value</i>. This is possible because expressions usually represent operations with no <i>side effects</i>, such as emitting output to a screen, reading or writing files, looking at a clock, controlling a device, and so on.</span>
<a name="b16e887dc1bc430da525e124a5f603b1"></a><div class="linked block"><div class="link-block">[<a href="#b16e887dc1bc430da525e124a5f603b1">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
Let <i>A</i> be an abstract syntax of a programming language, and let <i>V</i> be some subset of <i>A</i> that we will call the <i>value set</i>. This set will represent the possible meanings of parse trees in <i>A</i>, and it will represent the possible results of evaluating parse trees in <i>A</i>. Values that can occur directly within abstract syntax trees of the language (e.g., numeric and string literals, constructors, and so on) are usually called <i>constants</i>.
      </div></div></div>
<a name="53f0258543cc4f4592e7dc534bdfff60"></a><div class="linked block"><div class="link-block">[<a href="#53f0258543cc4f4592e7dc534bdfff60">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
An <i>evaluation algorithm</i> converts any abstract syntax tree that represents an expression into an abstract syntax tree that represents a value.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">expressions<br/>(abstract syntax)</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">evaluation<br/>algorithm</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">values<br/>(abstract syntax)</td>
  </tr>
</table>
</div>
      </div></div></div>
<a name="634d9dc447034b4abc749a6713b63c19"></a><div class="linked block"><div class="link-block">[<a href="#634d9dc447034b4abc749a6713b63c19">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Define the abstract syntax according to the following grammar, with <i>A</i> consisting of all formula abstract syntax instances, and <i>V</i> = {<b>true</b>, <b>false</b>} consisting of all value abstract syntax instances:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>formula</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>value</i> | <b>not</b> <i>formula</i> | <i>formula</i> <b>and</b> <i>formula</i> | <i>formula</i> <b>or</b> <i>formula</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>value</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> | <b>false</b>
</td></tr></table></td></tr></table>
The following is a definition of an operational semantics for this language.</span>
        <div class="inferences"><table class="inference"><tr><td class="title">[True]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>true</b> &dArr; <b>true</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[False]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>false</b> &dArr; <b>false</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Not-True]</td><td><table><tr><td class="premises">&nbsp;<i>f</i> &dArr; <b>true</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>not</b> <i>f</i> &dArr; <b>false</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Not-False]</td><td><table><tr><td class="premises">&nbsp;<i>f</i> &dArr; <b>false</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>not</b> <i>f</i> &dArr; <b>true</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[And-True-True]</td><td><table><tr><td class="premises">&nbsp;<i>f</i><sub>1</sub> &dArr; <b>true</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>f</i><sub>2</sub> &dArr; <b>true</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>f</i><sub>1</sub> <b>and</b> <i>f</i><sub>2</sub> &dArr; <b>true</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[And-True-False]</td><td><table><tr><td class="premises">&nbsp;<i>f</i><sub>1</sub> &dArr; <b>true</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>f</i><sub>2</sub> &dArr; <b>false</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>f</i><sub>1</sub> <b>and</b> <i>f</i><sub>2</sub> &dArr; <b>false</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[And-False-True]</td><td><table><tr><td class="premises">&nbsp;<i>f</i><sub>1</sub> &dArr; <b>false</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>f</i><sub>2</sub> &dArr; <b>true</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>f</i><sub>1</sub> <b>and</b> <i>f</i><sub>2</sub> &dArr; <b>false</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[And-False-False]</td><td><table><tr><td class="premises">&nbsp;<i>f</i><sub>1</sub> &dArr; <b>false</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>f</i><sub>2</sub> &dArr; <b>false</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>f</i><sub>1</sub> <b>and</b> <i>f</i><sub>2</sub> &dArr; <b>false</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Or-True-True]</td><td><table><tr><td class="premises">&nbsp;<i>f</i><sub>1</sub> &dArr; <b>true</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>f</i><sub>2</sub> &dArr; <b>true</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>f</i><sub>1</sub> <b>or</b> <i>f</i><sub>2</sub> &dArr; <b>true</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Or-True-False]</td><td><table><tr><td class="premises">&nbsp;<i>f</i><sub>1</sub> &dArr; <b>true</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>f</i><sub>2</sub> &dArr; <b>false</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>f</i><sub>1</sub> <b>or</b> <i>f</i><sub>2</sub> &dArr; <b>true</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Or-False-True]</td><td><table><tr><td class="premises">&nbsp;<i>f</i><sub>1</sub> &dArr; <b>false</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>f</i><sub>2</sub> &dArr; <b>true</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>f</i><sub>1</sub> <b>or</b> <i>f</i><sub>2</sub> &dArr; <b>true</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Or-False-False]</td><td><table><tr><td class="premises">&nbsp;<i>f</i><sub>1</sub> &dArr; <b>false</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>f</i><sub>2</sub> &dArr; <b>false</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>f</i><sub>1</sub> <b>or</b> <i>f</i><sub>2</sub> &dArr; <b>false</b>&nbsp;</td></tr></table></td></tr></table></div>
      </div></div></div>
<a name="60b6dc0bb16b498594677f3bb08ccc82"></a><div class="linked block"><div class="link-block">[<a href="#60b6dc0bb16b498594677f3bb08ccc82">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">The rules in the above example are numerous, and having this many rules in a definition becomes impractical (especially with more complex operators and language constructs). To address this, we can define a meta-language on the set of values <i>V</i> = {<b>true</b>, <b>false</b>}.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">&not; <b>true</b> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>false</b></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
&not; <b>false</b> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<b>true</b> &and; <b>true</b> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<b>true</b> &and; <b>false</b> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>false</b></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<b>false</b> &and; <b>true</b> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>false</b></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<b>false</b> &and; <b>false</b> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>false</b></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<b>true</b> &or; <b>true</b> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<b>true</b> &or; <b>false</b> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<b>false</b> &or; <b>true</b> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<b>false</b> &or; <b>false</b> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>false</b>
</td></tr></table></td></tr></table>
The definition then becomes more concise.</span>
        <div class="inferences"><table class="inference"><tr><td class="title">[True]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>true</b> &dArr; <b>true</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[False]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>false</b> &dArr; <b>false</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Not]</td><td><table><tr><td class="premises">&nbsp;<i>f</i> &dArr; <i>v</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>not</b> <i>f</i> &dArr; &not; <i>v</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[And]</td><td><table><tr><td class="premises">&nbsp;<i>f</i><sub>1</sub> &dArr; <i>v</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>f</i><sub>2</sub> &dArr; <i>v</i><sub>2</sub>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>f</i><sub>1</sub> <b>and</b> <i>f</i><sub>2</sub> &dArr; <i>v</i><sub>1</sub> &and; <i>v</i><sub>2</sub>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Or]</td><td><table><tr><td class="premises">&nbsp;<i>f</i><sub>1</sub> &dArr; <i>v</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>f</i><sub>2</sub> &dArr; <i>v</i><sub>2</sub>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>f</i><sub>1</sub> <b>or</b> <i>f</i><sub>2</sub> &dArr; <i>v</i><sub>1</sub> &or; <i>v</i><sub>2</sub>&nbsp;</td></tr></table></td></tr></table></div>
        
<span class="text">We can convert the above operational semantics inference rules into a Python implementation of an interpreter for this simple language. The functions <code>vnot</code>, <code>vand</code>, and <code>vor</code> correspond to &not;, &and;, and &or;, respectively, in the operational semantics.</span>
        
<div class="code"><div class="source"><pre><code class="py">
def vnot(v):
    if v == 'True':  return 'False'
    if v == 'False': return 'True'

def vand(v1, v2):
    if v1 == 'True'  and v2 == 'True':  return 'True'
    if v1 == 'True'  and v2 == 'False': return 'False'
    if v1 == 'False' and v2 == 'True':  return 'False'
    if v1 == 'False' and v2 == 'False': return 'False'

def vor(v1, v2):
    if v1 == 'True'  and v2 == 'True':  return 'True'
    if v1 == 'True'  and v2 == 'False': return 'True'
    if v1 == 'False' and v2 == 'True':  return 'True'
    if v1 == 'False' and v2 == 'False': return 'False'

Node = dict
Leaf = str

def evaluate(e):
    if type(e) == Node:
        for label in e:
            children = e[label]
            if label == 'Not':
                f = children[0]
                v = evaluate(f)
                return vnot(v)
            elif label == 'And':
                # Notice that we can make the recursive calls
                # below in any order we like; the order of the
                # calls is not specified by the operational
                # semantics.
                f1 = children[0]
                v1 = evaluate(f1)
                f2 = children[1]
                v2 = evaluate(f2)
                return vand(v1, v2)
            elif label == 'Or':
                f2 = children[1]
                v2 = evaluate(f2)
                f1 = children[0]
                v1 = evaluate(f1)
                return vor(v1, v2)
    elif type(e) == Leaf:
        if e == 'True':
            return 'True'
        if e == 'False':
            return 'False'
        </code></pre></div></div>
        
<span class="text">In fact, we could convert the above so that it returns a Python value directly, rather than an abstract syntax tree corresponding to a value.</span>
        
<div class="code"><div class="source"><pre><code class="py">
def evaluate(e):
    if type(e) == Node:
        for label in e:
            children = e[label]
            if label == 'Not':
                f = children[0]
                v = evaluate(f)
                return not v # Use the Python not operator.
            elif label == 'And':
                f1 = children[0]
                v1 = evaluate(f1)
                f2 = children[1]
                v2 = evaluate(f2)
                return v1 and v2 # Use the Python and operator.
            elif label == 'Or':
                f2 = children[1]
                v2 = evaluate(f2)
                f1 = children[0]
                v1 = evaluate(f1)
                return v1 or v2 # Use the Python or operator.
    elif type(e) == Leaf:
        if e == 'True':
            return True # Use the Python True constant.
        if e == 'False':
            return False # Use the Python False constant.
        </code></pre></div></div>
      </div></div></div></div>
  <a name="4.4"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#4.4">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">4.4.</span> Execution of sequences of statements</h3>
<span class="text top">The abstract syntax, or a subset of the abstract syntax, of a programming language is considered to be a set of <i>statements</i> if the operational semantics for that syntax impose a sequential ordering on the computation they represent. This usually corresponds to the notion of a single point of <i>control flow</i> traversing the program's abstract syntax as the program is executed (which is a good model of a computer architecture that contains only a single processor that can perform one instruction at a time).
<br/><br/>
Languages that have statements and a notion of control flow are called <i>imperative</i>. Languages that have only expressions and no statements can be called <i>pure</i> or <i>functional</i>, although that terminology will often have additional meanings in such a context that we will go over in subsequent sections.</span>
<a name="db57dc0684174cd097ebf73d733dc9bc"></a><div class="linked block"><div class="link-block">[<a href="#db57dc0684174cd097ebf73d733dc9bc">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
Let <i>A</i> be an abstract syntax of a programming language, and let <i>V</i> be some subset of <i>A</i>. Let <i>O</i> be a set of possible outputs (e.g., a text terminal or file).
        <ul>
          <li>In this course, we will denote a possible output in <i>O</i> using the symbol <i>o</i>.</li>
          <li>We denote the empty output using <i>o</i><sub>0</sub>.</li>
          <li>We denote an output <i>o</i> <b>preceded</b> by the value <i>v</i> as <i>v</i>;<i>o</i> (that is, <i>v</i> is the first value in the output <i>v</i>;<i>o</i>, and <i>o</i> is the rest).</li>
          <li>Given two outputs <i>o</i><sub>1</sub> and <i>o</i><sub>2</sub>, <i>o</i><sub>1</sub>;<i>o</i><sub>2</sub> represents two outputs in sequence: <i>o</i><sub>1</sub> followed by <i>o</i><sub>2</sub>.</li>
        </ul>
      </div></div></div>
<a name="28221c6d8fdd4748bd22545462178e97"></a><div class="linked block"><div class="link-block">[<a href="#28221c6d8fdd4748bd22545462178e97">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
An <i>execution algorithm</i> converts any abstract syntax tree that represents a sequence of statements into an abstract syntax tree that represents an output.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">statement sequence<br/>(abstract syntax)</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">execution<br/>algorithm</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">output<br/>(record of side effects)</td>
  </tr>
</table>
</div>
      </div></div></div>
<span class="text top">Thus, we can represent an output in Python using, for example, a list of values.</span>
<a name="5dead3e1ed524b24a68fc4f4b393eb8a"></a><div class="linked block"><div class="link-block">[<a href="#5dead3e1ed524b24a68fc4f4b393eb8a">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">We present an operational semantics for a simple programming language with statements. 
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>print</b> <i>formula</i> <b>;</b> <i>program</i> | <b>end</b> <b>;</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>formula</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>value</i> | <b>not</b> <i>formula</i> | <i>formula</i> <b>and</b> <i>formula</i> | <i>formula</i> <b>or</b> <i>formula</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>value</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> | <b>false</b>
</td></tr></table></td></tr></table>
Recall that <i>O</i> represents the set of outputs (e.g., to the terminal), with <i>o</i><sub>0</sub> representing the empty output and <i>v</i>;<i>o</i> representing a terminal <i>o</i> with the value <i>v</i> as its first output.</span>
        <div class="inferences"><table class="inference"><tr><td class="title">[Statement-Print]</td><td><table><tr><td class="premises">&nbsp;<i>p</i> &dArr; <i>o</i> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>f</i> &dArr; <i>v</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>print</b> <i>f</i> <b>;</b> <i>p</i> &dArr; <i>v</i>;<i>o</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-End]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>end ;</b> &dArr; <i>o</i><sub>0</sub>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-True]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>true</b> &dArr; <b>true</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-False]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>false</b> &dArr; <b>false</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-Not]</td><td><table><tr><td class="premises">&nbsp;<i>f</i> &dArr; <i>v</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>not</b> <i>f</i> &dArr; &not; <i>v</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-And]</td><td><table><tr><td class="premises">&nbsp;<i>f</i><sub>1</sub> &dArr; <i>v</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>f</i><sub>2</sub> &dArr; <i>v</i><sub>2</sub>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>f</i><sub>1</sub> <b>and</b> <i>f</i><sub>2</sub> &dArr; <i>v</i><sub>1</sub> &and; <i>v</i><sub>2</sub>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-Or]</td><td><table><tr><td class="premises">&nbsp;<i>f</i><sub>1</sub> &dArr; <i>v</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>f</i><sub>2</sub> &dArr; <i>v</i><sub>2</sub>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>f</i><sub>1</sub> <b>or</b> <i>f</i><sub>2</sub> &dArr; <i>v</i><sub>1</sub> &or; <i>v</i><sub>2</sub>&nbsp;</td></tr></table></td></tr></table></div>
        
<span class="text">We can convert the above operational semantics inference rules into a Python implementation of an interpreter for this simple language. We represent outputs in <i>O</i> as Python lists of values, because lists preserve order. Note that we refer to the implementation of <code>evaluate()</code> from a <a href="#60b6dc0bb16b498594677f3bb08ccc82">previous example</a>.</span>
        
<div class="code"><div class="source"><pre><code class="py">
def execute(s):
    if type(s) == Leaf:
        if s == 'End':
            return []
    elif type(s) == Node:
        for label in s:
            if label == 'Print':
                children = s[label]
                f = children[0]
                p = children[1]
                v = evaluate(f) # Implemented elsewhere.
                o = execute(p)
                return [v] + o
        </code></pre></div></div>
        
<span class="text">As before, we can actually use the Python <code>print()</code> function and turn this into an interpreter that uses the Python runtime system directly to interpret the program. However, we must be careful about where we put the call to <code>print()</code>: it must be invoked in a way that conforms to a <i>pre-order</i> traversal of the syntax tree.</span>
        
<div class="code"><div class="source"><pre><code class="py">
def execute(s):
    if type(s) == Leaf:
        if s == 'End':
            return []
    elif type(s) == Node:
        for label in s:
            if label == 'Print':
                children = s[label]
                f = children[0]
                p = children[1]
                v = evaluate(f)
                print(v) # Must appear before recursive call.
                o = execute(p)
                return [v] + o
        </code></pre></div></div>
      </div></div></div>
<span class="text top">In an operational semantics for a language with variables and variable assignment, a data structure called an <i>environment</i> is usually used to represent what variables are in scope, as well as the values assigned to variables. We introduce a mathematical definition of an environment so that we can employ it within our operational semantics definitions.</span>
<a name="e1a5053a93d54ad4b02da10e4981b810"></a><div class="linked block"><div class="link-block">[<a href="#e1a5053a93d54ad4b02da10e4981b810">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
        Given a programming language definition with a set of values <i>V</i> and a set of possible variable names <i>X</i> (as defined by the concrete syntax), an <i>environment</i> or <i>context</i> is a mapping from a subset of the variables <i>X</i> to the set of values <i>V</i>.      
        <ul>
          <li>In this course, we will usually denote an environment using the symbol &Sigma;.</li>
          <li>Given a variable name <i>x</i> <span style="font-size:12px;">&#8712;</span> <i>X</i>, we denote by &Sigma;(<i>x</i>) the value that the environment &Sigma; assigns to <i>x</i>.</li>
          <li>An empty environment (one that does not map any variable names to any values) is denoted using &Sigma;<sub>0</sub>.</li>
          <li>Given an environment &Sigma;, a variable <i>x</i> <span style="font-size:12px;">&#8712;</span> <i>X</i>, and a value <i>v</i> <span style="font-size:12px;">&#8712;</span> <i>V</i>, we denote by &Sigma; &#8846; {<i>x</i> &#x21A6; <i>v</i>} the extension of the environment &Sigma; with a new mapping from <i>x</i> to <i>v</i> (i.e., if &Sigma;' = &Sigma; &#8846; {<i>x</i> &#x21A6; <i>v</i>} then &Sigma;'(<i>x</i>) = <i>v</i>).</li>
        </ul>
      </div></div></div>
<span class="text top">We can update our diagram for an execution algorithm.</span>
<a name="3adff7747f5d4a438385244a02161161"></a><div class="linked block"><div class="link-block">[<a href="#3adff7747f5d4a438385244a02161161">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="diagram other">
<table class="container">
  <tr>
    <td class="box" style="background-color:#ECECEC;">
      <table class="container">
        <tr>
          <td class="box" style="background-color:powderblue;">environment</td>
          <td class="box" style="background-color:powderblue;">statement sequence<br/>(abstract syntax)</td>
        </tr>
      </table>
    </td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">execution<br/>algorithm</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">output<br/>(record of side effects)</td>
  </tr>
</table>
      </div></div></div>
<span class="text top">Within implementations of interpreters and compilers, environments will often be represented with finite maps, associative lists, dictionary, or stacks, depending on the structure and semantics of the language.</span>
<a name="cbfa02d3624d42b08704d6a4c4fb9e03"></a><div class="linked block"><div class="link-block">[<a href="#cbfa02d3624d42b08704d6a4c4fb9e03">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">We present an operational semantics for a simple programming language with variables and variable assignment.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>print</b> <i>formula</i> <b>;</b> <i>program</i> | <b>assign</b> <i>variable</i> <b>:=</b> <i>formula</i> <b>;</b> <i>program</i> | <b>end</b> <b>;</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>formula</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>value</i> | <i>variable</i> | <b>not</b> <i>formula</i> | <i>formula</i> <b>and</b> <i>formula</i> | <i>formula</i> <b>or</b> <i>formula</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>variable</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid variable name as defined by the concrete syntax</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>value</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> | <b>false</b>
</td></tr></table></td></tr></table>
Notice the use of an environment &Sigma;, also known as a context, that maps variable names to values.</span>
        <div class="inferences"><table class="inference"><tr><td class="title">[Statement-Assign]</td><td><table><tr><td class="premises">&nbsp;&Sigma; &#8846; {<i>x</i> &#x21A6; <i>v</i>}, <i>p</i> &dArr; <i>o</i> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;, <i>f</i> &dArr; <i>v</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <b>assign</b> <i>x</i> <b>:=</b> <i>f</i> <b>;</b> <i>p</i> &dArr; <i>o</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-Print]</td><td><table><tr><td class="premises">&nbsp;&Sigma;, <i>p</i> &dArr; <i>o</i> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;, <i>f</i> &dArr; <i>v</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <b>print</b> <i>f</i> <b>;</b> <i>p</i> &dArr; <i>v</i>;<i>o</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-End]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <b>end ;</b> &dArr; <i>o</i><sub>0</sub>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-True]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <b>true</b> &dArr; <b>true</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-False]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <b>false</b> &dArr; <b>false</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-Not]</td><td><table><tr><td class="premises">&nbsp;&Sigma;, <i>f</i> &dArr; <i>v</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <b>not</b> <i>f</i> &dArr; &not; <i>v</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-And]</td><td><table><tr><td class="premises">&nbsp;&Sigma;, <i>f</i><sub>1</sub> &dArr; <i>v</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;, <i>f</i><sub>2</sub> &dArr; <i>v</i><sub>2</sub>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <i>f</i><sub>1</sub> <b>and</b> <i>f</i><sub>2</sub> &dArr; <i>v</i><sub>1</sub> &and; <i>v</i><sub>2</sub>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-Or]</td><td><table><tr><td class="premises">&nbsp;&Sigma;, <i>f</i><sub>1</sub> &dArr; <i>v</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;, <i>f</i><sub>2</sub> &dArr; <i>v</i><sub>2</sub>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <i>f</i><sub>1</sub> <b>or</b> <i>f</i><sub>2</sub> &dArr; <i>v</i><sub>1</sub> &or; <i>v</i><sub>2</sub>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-Variable]</td><td><table><tr><td class="premises">&nbsp;&Sigma;(<i>x</i>) = <i>v</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <i>x</i> &dArr; <i>v</i>&nbsp;</td></tr></table></td></tr></table></div>
        
<span class="text">We can convert the above operational semantics inference rules into a Python implementation of an interpreter for this language. We represent environments as dictionaries in which variable names are labels, and these labels map to values in the language. The functions <code>vnot</code>, <code>vand</code>, and <code>vor</code> are the same as those in a <a href="#60b6dc0bb16b498594677f3bb08ccc82">previous example</a>.</span>
        
<div class="code"><div class="source"><pre><code class="py">
def evaluate(env, e):
    if type(e) == Node:
        for label in e:
            children = e[label]
            if label == 'Not':
                f = children[0]
                v = evaluate(env, f)
                return vnot(v)
            elif label == 'And':
                f1 = children[0]
                v1 = evaluate(env, f1)
                f2 = children[1]
                v2 = evaluate(env, f2)
                return vand(v1, v2)
            elif label == 'Or':
                f2 = children[1]
                v2 = evaluate(env, f2)
                f1 = children[0]
                v1 = evaluate(env, f1)
                return vor(v1, v2)
            elif label == 'Variable':
                x = children[0]
                if x in env:
                    return env[x]
                else:
                    print(x + " is unbound.")
                    exit()
    elif type(e) == Leaf:
        if e == 'True':
            return 'True'
        if e == 'False':
            return 'False'

def execute(env, s):
    if type(s) == Leaf:
        if s == 'End':
            return []
    elif type(s) == Node:
        for label in s:
            if label == 'Print':
                children = s[label]
                f = children[0]
                p = children[1]
                v = evaluate(env, f)
                o = execute(env, p)
                return [v] + o
            if label == 'Assign':
                children = s[label]
                x = children[0]['Variable'][0]
                f = children[1]
                p = children[2]
                v = evaluate(env, f)
                env[x] = v
                o = execute(env, p)
                return o
        </code></pre></div></div>
      </div></div></div>
<span class="text top">If an abstract syntax parse tree node for a statement can have two or more children that are also statement sequences, and if the operational semantics of the language require that statements must be executed consecutively (i.e., not in parallel), then the execution algorithm must also return a new copy of the environment, modified to reflect the variable assignments that might have occurred in the statement sequence.</span>
<a name="ae6395c019454af5ba5ed127504291e4"></a><div class="linked block"><div class="link-block">[<a href="#ae6395c019454af5ba5ed127504291e4">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="diagram other">
<table class="container">
  <tr>
    <td class="box" style="background-color:#ECECEC;">
      <table class="container">
        <tr>
          <td class="box" style="background-color:powderblue;">environment</td>
          <td class="box" style="background-color:powderblue;">statement sequence<br/>(abstract syntax)</td>
        </tr>
      </table>
    </td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">execution<br/>algorithm</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:#ECECEC;">
      <table class="container">
        <tr>
          <td class="box" style="background-color:powderblue;">environment</td>
          <td class="box" style="background-color:powderblue;">output<br/>(record of side effects)</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
      </div></div></div>
<a name="c09ab939e50b40428d392867c00b4710"></a><div class="linked block"><div class="link-block">[<a href="#c09ab939e50b40428d392867c00b4710">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">We present an operational semantics for an extension of a language in a <a href="#cbfa02d3624d42b08704d6a4c4fb9e03">previous example</a>.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>print</b> <i>formula</i> <b>;</b> <i>program</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
  <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>assign</b> <i>variable</i> <b>:=</b> <i>formula</i> <b>;</b> <i>program</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
  <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>repeat</b> <b>twice</b> <b>{</b> <i>program</i> <b>}</b> <i>program</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
  <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>end</b> <b>;</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
    <td></tr></table></td><td style="text-align:center;"> &#8942; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> 
</td></tr></table></td></tr></table>
An example of a program in this language is presented below:</span>
        
<div class="code"><div class="source"><pre><code>
print true;
repeat twice {
  print false;
  end;
}
print true;
end;
        </code></pre></div></div>
        
<span class="text">The operational semantics inference rules are the same as those in a <a href="#cbfa02d3624d42b08704d6a4c4fb9e03">previous example</a>. However, we must modify the inference rules for statements. In particular, the predicate &dArr; that defines execution of statements must also specify the new environment that exists after a statement is executed. This is to capture the fact that a program may have variable assignments in a block of code that may be executed multiple times (or, in other languages with branching constructs, may be executed conditionally).</span>
        <div class="inferences"><table class="inference"><tr><td class="title">[Statement-Assign]</td><td><table><tr><td class="premises">&nbsp;&Sigma;<sub>1</sub> &#8846; {<i>x</i> &#x21A6; <i>v</i>}, <i>p</i> &dArr; &Sigma;<sub>2</sub>, <i>o</i> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;<sub>1</sub>, <i>f</i> &dArr; <i>v</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;<sub>1</sub>, <b>assign</b> <i>x</i> <b>:=</b> <i>f</i> <b>;</b> <i>p</i> &dArr; &Sigma;<sub>2</sub>, <i>o</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-Print]</td><td><table><tr><td class="premises">&nbsp;&Sigma;<sub>1</sub>, <i>p</i> &dArr; &Sigma;<sub>2</sub>, <i>o</i> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;<sub>1</sub>, <i>f</i> &dArr; <i>v</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;<sub>1</sub>, <b>print</b> <i>f</i> <b>;</b> <i>p</i> &dArr; &Sigma;<sub>2</sub>, <i>v</i>;<i>o</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-Repeat-Twice]</td><td><table><tr><td class="premises">&nbsp;
              &Sigma;<sub>1</sub>, <i>p</i><sub>1</sub> &dArr; &Sigma;<sub>2</sub>, <i>o</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;<sub>2</sub>, <i>p</i><sub>1</sub> &dArr; &Sigma;<sub>3</sub>, <i>o</i><sub>2</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;<sub>3</sub>, <i>p</i><sub>2</sub> &dArr; &Sigma;<sub>4</sub>, <i>o</i><sub>3</sub>
            &nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;<sub>1</sub>, <b>repeat twice</b> <b>{</b> <i>p</i><sub>1</sub> <b>}</b> <i>p</i><sub>2</sub> &dArr; &Sigma;<sub>4</sub>, <i>o</i><sub>1</sub>;<i>o</i><sub>2</sub>;<i>o</i><sub>3</sub>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-End]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <b>end ;</b> &dArr; &Sigma;, <i>o</i><sub>0</sub>&nbsp;</td></tr></table></td></tr></table></div>
        
<span class="text">We can convert the above operational semantics inference rules into a Python implementation of an interpreter for this language. The implementation of <code>evaluate()</code> is the same as the one in a <a href="#cbfa02d3624d42b08704d6a4c4fb9e03">previous example</a>, while the implementation of <code>execute()</code> from <a href="#cbfa02d3624d42b08704d6a4c4fb9e03">that example</a> must be modified so that it also returns an updated version of the environment data structure.</span>
        
<div class="code"><div class="source"><pre><code class="py">
def execute(env, s):
    if type(s) == Leaf:
        if s == 'End':
            return (env, [])
    elif type(s) == Node:
        for label in s:
            if label == 'Print':
                children = s[label]
                f = children[0]
                p = children[1]
                v = evaluate(env, f)
                (env, o) = execute(env, p)
                return (env, [v] + o)
            if label == 'Assign':
                children = s[label]
                x = children[0]['Variable'][0]
                f = children[1]
                p = children[2]
                v = evaluate(env, f)
                env[x] = v
                (env, o) = execute(env, p)
                return (env, o)
            if label == 'RepeatTwice':
                children = s[label]
                body = children[0]
                rest = children[1]
                env1 = env
                (env2, o1) = execute(env1, body)
                (env3, o2) = execute(env2, body)
                (env4, o3) = execute(env3, rest)
                return (env4, o1 + o2 + o3)
        </code></pre></div></div>
      </div></div></div>
<a name="4ebc67e9336c475a939d6c8c0dcedc36"></a><div class="linked block"><div class="link-block">[<a href="#4ebc67e9336c475a939d6c8c0dcedc36">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">We consider inference rules for a few common looping constructs.</span>
        <div class="inferences"><table class="inference"><tr><td class="title">[Statement-While-False]</td><td><table><tr><td class="premises">&nbsp;&Sigma;<sub>1</sub>, <i>p</i><sub>2</sub> &dArr; &Sigma;<sub>2</sub>, <i>o</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;<sub>1</sub>, <i>e</i> &dArr; <b>false</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;<sub>1</sub>, <b>while</b> <i>e</i> <b>{</b> <i>p</i><sub>1</sub> <b>}</b> <i>p</i><sub>2</sub> &dArr; &Sigma;<sub>2</sub>, <i>o</i><sub>1</sub>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-While-True]</td><td><table><tr><td class="premises">&nbsp;
              &Sigma;<sub>1</sub>, <i>p</i><sub>1</sub> &dArr; &Sigma;<sub>2</sub>, <i>o</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;<sub>2</sub>, <b>while</b> <i>e</i> <b>{</b> <i>p</i><sub>1</sub> <b>}</b> <i>p</i><sub>2</sub> &dArr; &Sigma;<sub>3</sub>, <i>o</i><sub>2</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;<sub>1</sub>, <i>e</i> &dArr; <b>true</b>
            &nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;<sub>1</sub>, <b>while</b> <i>e</i> <b>{</b> <i>p</i><sub>1</sub> <b>}</b> <i>p</i><sub>2</sub> &dArr; &Sigma;<sub>3</sub>, <i>o</i><sub>1</sub>;<i>o</i><sub>2</sub>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-Until-True]</td><td><table><tr><td class="premises">&nbsp;&Sigma;<sub>1</sub>, <i>p</i><sub>2</sub> &dArr; &Sigma;<sub>2</sub>, <i>o</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;<sub>1</sub>, <i>e</i> &dArr; <b>true</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;<sub>1</sub>, <b>until</b> <i>e</i> <b>{</b> <i>p</i><sub>1</sub> <b>}</b> <i>p</i><sub>2</sub> &dArr; &Sigma;<sub>2</sub>, <i>o</i><sub>1</sub>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-Until-False]</td><td><table><tr><td class="premises">&nbsp;
              &Sigma;<sub>1</sub>, <i>p</i><sub>1</sub> &dArr; &Sigma;<sub>2</sub>, <i>o</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;<sub>2</sub>, <b>until</b> <i>e</i> <b>{</b> <i>p</i><sub>1</sub> <b>}</b> <i>p</i><sub>2</sub> &dArr; &Sigma;<sub>3</sub>, <i>o</i><sub>2</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;<sub>1</sub>, <i>e</i> &dArr; <b>false</b>
            &nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;<sub>1</sub>, <b>until</b> <i>e</i> <b>{</b> <i>p</i><sub>1</sub> <b>}</b> <i>p</i><sub>2</sub> &dArr; &Sigma;<sub>3</sub>, <i>o</i><sub>1</sub>;<i>o</i><sub>2</sub>&nbsp;</td></tr></table></td></tr></table></div>
        
<span class="text">The following code snippet illustrates one way to implement the [Statement-While-True] and [Statement-While-False] rules.</span>
        
<div class="code"><div class="source"><pre><code class="py">
if label == 'While':
    [cond, body, rest] = s[label]
    env1 = env
    v = evaluate(env1, cond)
    if v == 'False':
        (env2, o1) = execute(env1, rest)
        return (env2, o1)
    if v == 'True':
        (env2, o1) = execute(env1, body)
        (env3, o2) = execute(env2, {'While':[cond, body, rest]})
        return (env3, o1 + o2)
        </code></pre></div></div>
      </div></div></div></div>
  <a name="4.5"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#4.5">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">4.5.</span> Interpreters</h3>
<span class="text top">An interpreter is an algorithm that invokes evaluation and execution algorithms as required by the operational semantics for a language.</span>
<a name="2691e94473434ef5b07c14a531b53d25"></a><div class="linked block"><div class="link-block">[<a href="#2691e94473434ef5b07c14a531b53d25">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="diagram other">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">program<br/>(abstract syntax)</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:#ECECEC;">
      <table class="container">
        <tr>
          <td class="box" style="background-color:lightyellow;">evaluation<br/>algorithm</td>
          <td class="box" style="background-color:lightyellow;">execution<br/>algorithm</td>
        </tr>
      </table>
    </td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">output and/or<br/>value(s)<br/></td>
  </tr>
</table>
      </div></div></div>
<span class="text top">Often, the term <i>interpreter</i> will refer to the entire toolchain of components that make it possible to convert the character string (i.e., concrete syntax) representation of a program in the source language into value(s) and/or a record of the side effects of a program. In these cases, we will refer to the individual component that performs interpretation as the <i>interpretation algorithm</i> or <i>interpretation component</i>.</span>
<a name="96668dc9084942278a983fcbfe52c7f5"></a><div class="linked block"><div class="link-block">[<a href="#96668dc9084942278a983fcbfe52c7f5">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="diagram other">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">character string<br/>(concrete syntax)</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:#EFEFEF;">
      <table class="container">
        <tr>
        <td class="box" style="background-color:lightyellow;">parser</td>
        <td><span style="font-size:20px;">&#8658;</span></td>
        <td class="box" style="background-color:powderblue;">abstract<br/>syntax</td>
        <td><span style="font-size:20px;">&#8658;</span></td>
        <td class="box" style="background-color:lightyellow;">interpretation<br/>algorithm</td>
        </tr>
      </table>
      <br/>interpreter
    </td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">output and/or<br/>value(s)<br/></td>
    <td></td>
    <td></td>
  </tr>
</table>
      </div></div></div>
<span class="text top">It is important to consider the relationship between the interpreted language and the underlying language used to implement the interpreter.</span>
<a name="8bd325c4321943f1ac368f4a8a0ab8be"></a><div class="linked block"><div class="link-block">[<a href="#8bd325c4321943f1ac368f4a8a0ab8be">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="diagram other">
<table class="container">
  <tr>
    <td class="box" style="background-color:#ECECEC;">
      <table class="container">
        <tr>
          <td class="box" style="background-color:lightyellow;">abstract syntax<br/>trees</td>
          <td class="box" style="background-color:lightyellow;">boolean<br/>values</td>
          <td class="box" style="background-color:lightyellow;">outputs<br/>over time</td>
        </tr>
        <tr>
          <td class="box" style="background-color:powderblue;">nested<br/>dictionaries</td>
          <td class="box" style="background-color:powderblue;">strings</td>
          <td class="box" style="background-color:powderblue;">ordered<br/>list</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
      </div></div></div>
<a name="c27d5cd468f6449188ecf0f99ffdc2ed"></a><div class="linked block"><div class="link-block">[<a href="#c27d5cd468f6449188ecf0f99ffdc2ed">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="diagram other">
<table class="container">
  <tr>
    <td class="box" style="background-color:#ECECEC;">
      <table class="container">
        <tr>
          <td class="box" style="background-color:lightyellow;">abstract syntax<br/>trees</td>
          <td class="box" style="background-color:lightyellow;">boolean<br/>values</td>
          <td class="box" style="background-color:lightyellow;">outputs<br/>over time</td>
          <td class="box" style="background-color:lightyellow;">unbounded<br/>integers</td>
        </tr>
        <tr>
          <td class="box" style="background-color:powderblue;">nested<br/>dictionaries</td>
          <td class="box" style="background-color:powderblue;">boolean<br/>values</td>
          <td class="box" style="background-color:powderblue;">outputs<br/>over time</td>
          <td class="box" style="background-color:powderblue;">lists of<br/>bounded integers</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
      </div></div></div></div>
</div>
<a name="5"></a>
<div class="section"><hr /><h2 class="linked"><span class="link-title">[<a href="#5">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">5.</span> Compilation</h2>
<span class="text top">Compilation involves translating or transforming one programming language (sometimes called the <i>source</i> language) into another (often called the <i>target</i> language). It is often the case that the target language is a more "low-level" language that more closely corresponds to the capabilities of a physical (i.e., electronic) device, such as the central processor (CPU), memory, and other devices that constitute a modern computer. However, today, compilation could also refer to any transformation from one programming language to another. For example, it might be necessary to compile PHP to ASP, which are both server-side web application scripting languages, in order to migrate software from one operating system to another.</span>
  <a name="5.1"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#5.1">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">5.1.</span> History, background, and context</h3>
<span class="text top">One way to summarize a very thin slice of the history of general-purpose computers and their relationship with programming languages is to consider how the increasingly complex structure of a computer both enabled and required increasingly abstract programming languages and programming language features.
<br/><br/>
The three major categories of concept involved are the program, the computing device, and the physical laws upon which the computing device is based. As long as the physical laws being used are predictable (i.e., consistent across time and space), we can build computing devices that behave the same way even if they are operated in different places or at different times. We can then interpret what that device does in some meaningful way (e.g., as arithmetic operations). To perform different kinds of tasks using the device, we would need some kind of way to change its initial configuration (i.e., to "program" it).</span>
<a name="b6e0dcf63432494dbc176f5111ea6272"></a><div class="linked block"><div class="link-block">[<a href="#b6e0dcf63432494dbc176f5111ea6272">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="diagram other">
<table class="container">
  <tr><td class="box" style="background-color:lightyellow;">program (e.g., input/configuration, instructions, etc.)</td></tr>
  <tr><td class="box" style="background-color:orange;">computing device (e.g., difference engine, modern CPU, quantum computer, etc.)</td></tr>
  <tr><td class="box" style="background-color:powderblue;">physical laws (mechanics, electricity, chemistry, biology, quantum mechanics, etc.)</td></tr>
</table>
      </div></div></div>
<span class="text top">Until the 1940s, all artifacts that could be considered computing devices (e.g., an abacus, <a href="http://en.wikipedia.org/wiki/Difference_engine">Babbage's difference engine</a>, etc.) were single-purpose machines that could only perform the same operation (but possibly on different inputs, which corresponded to different initial configurations of the device). In the early 1940s, a number of computers were built (such as the <a href="http://en.wikipedia.org/wiki/ENIAC">ENIAC</a> and <a href="http://en.wikipedia.org/wiki/Colossus_computer">Colossus</a>) that could be physically reconfigured to perform different operations. Arguably, the "program" was the machine's physical configuration. In the late 1940s, computers were developed (or improved, as in the case of ENIAC) that could operate according to a program stored in a memory device. At this point, both the program and the input were stored in a single, unified memory component; the program told the central processing unit (CPU) what operations to perform, and what modifications to make to memory. This characteristic is part of what's known as the <a href="http://en.wikipedia.org/wiki/Von_Neumann_architecture">Von Neumann architecture</a>.</span>
<a name="055c21ec3b2646d8b99675d84976ab11"></a><div class="linked block"><div class="link-block">[<a href="#055c21ec3b2646d8b99675d84976ab11">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="diagram other">
<table class="container">
  <tr>
    <td class="box" style="background-color:#EEEEEE;">memory
      <table class="container">
        <tr>
          <td class="box" style="background-color:lightyellow;">input</td>
          <td class="box" style="background-color:lightyellow;">program</td>
        </tr>
      </table>
    </td>
  </tr>
  <tr><td class="box" style="background-color:orange;">central processing unit (CPU)</td></tr>
</table>
      </div></div></div>
<span class="text top">Subsequent improvements to computing device components in the 1950s and onward primarily served to make the components smaller, cheaper, faster, and more reliable while still conforming to the Von Neumann architecture. However, the programs controlling these devices continued to become more and more sophisticated.
<br/><br/>
Machine languages were developed in the 1940s (particularly in the very late 1940s) and the 1950s. These consisted of small collections of instructions that corresponded to operations that could be performed by the CPU. A program was then a list of machine language instructions, and the abstraction this supplied to the programmer was that of a block of memory indexed by an integer range, and a single processor that could perform a sequence of operations on memory. The diagram below provides a stylized depiction of the view from a user's or programmer's perspective.</span>
<a name="ce88673bd93a4d1f98f59da033d4853b"></a><div class="linked block"><div class="link-block">[<a href="#ce88673bd93a4d1f98f59da033d4853b">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="diagram other">
<table class="container">
  <tr><td class="box" style="background-color:lightyellow;">machine program</td></tr>
  <tr><td class="box" style="background-color:#ECECEC;">machine languauge</td></tr>
  <tr>
    <td class="box" style="background-color:#CCCCCC;">
      <table class="container">
        <tr>
          <td class="box" style="background-color:orange;">CPU</td>
          <td class="box" style="background-color:orange;">memory</td>
        </tr>
      </table>
      hardware
    </td>
  </tr>
</table>
      </div></div></div>
<span class="text top">In part because using machine languages to specify the desired behavior of computers was time-consuming and error-prone, more human-friendly and legible languages were developed in the mid and late 1950s, such as FORTRAN, LISP, and COBOL. These programs were mechanically transformed into machine language programs using a compiler, which was itself a program. For example, after a human wrote a FORTRAN program, it could be compiled once into a machine language program by running the compiler once. The machine language program this produced could then be run any number of times or copied and reused later.</span>
<a name="e5fbf53c0feb4c5c821c1b0ba08d9409"></a><div class="linked block"><div class="link-block">[<a href="#e5fbf53c0feb4c5c821c1b0ba08d9409">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="diagram other">
<table class="container">
  <tr><td class="box" style="background-color:#ECECEC;">FORTRAN program</td></tr>
  <tr><td class="box" style="background-color:#ECECEC;">FORTRAN compiler</td></tr>
  <tr><td class="box" style="background-color:lightyellow;">machine program</td></tr>
  <tr><td class="box" style="background-color:#ECECEC;">machine languauge</td></tr>
  <tr>
    <td class="box" style="background-color:#CCCCCC;">
      <table class="container">
        <tr>
          <td class="box" style="background-color:orange;">CPU</td>
          <td class="box" style="background-color:orange;">memory</td>
        </tr>
      </table>
      hardware
    </td>
  </tr>
</table>
      </div></div></div>
<span class="text top">Special-purpose applications could be written using either a machine language or a high-level language.</span>
<a name="674d509bf2634fa4be9687547f47de19"></a><div class="linked block"><div class="link-block">[<a href="#674d509bf2634fa4be9687547f47de19">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="diagram other">
<table class="container">
  <tr><td class="box" style="background-color:lightyellow;">application</td></tr>
  <tr><td class="box" style="background-color:#ECECEC;">high-level program</td></tr>
  <tr><td class="box" style="background-color:#ECECEC;">compiler</td></tr>
  <tr><td class="box" style="background-color:lightyellow;">machine program</td></tr>
  <tr><td class="box" style="background-color:#ECECEC;">machine languauge</td></tr>
  <tr>
    <td class="box" style="background-color:#CCCCCC;">
      <table class="container">
        <tr>
          <td class="box" style="background-color:orange;">CPU</td>
          <td class="box" style="background-color:orange;">memory</td>
        </tr>
      </table>
      hardware
    </td>
  </tr>
</table>
      </div></div></div>
<span class="text top">Once it became possible for non-experts and multiple users to use a computer with a variety of different components beyond the memory and CPU (due to advances in many areas, including reductions in cost and the availability of better interface devices and special-purpose components), operating systems were developed to make it possible to manage multiple applications that might run by different users and might employ different components. However, all the applications would need to be either written using a machine language, or written in a language that could be compiled into a machine language. The operating system would then manage how these machine programs could use the various components and resources available to the computer (including the resource of time).</span>
<a name="0a516d9e2ca446f69c1758c0bbd9a473"></a><div class="linked block"><div class="link-block">[<a href="#0a516d9e2ca446f69c1758c0bbd9a473">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="diagram other">
<table class="container">
  <tr>
    <td class="box" colspan="2" style="background-color:#EEEEEE;">
      user A
      <table class="container">
        <tr>
          <td class="box" style="background-color:lightyellow;">application</td>
          <td class="box" style="background-color:lightyellow;">application</td>
        </tr>
      </table>
    </td>
    <td class="box" colspan="2" style="background-color:#EEEEEE;">
      user B
      <table class="container">
        <tr>
          <td class="box" style="background-color:lightyellow;">application</td>
          <td class="box" style="background-color:lightyellow;">application</td>
        </tr>
      </table>
    </td>
  </tr>
  <tr>
    <td class="box" style="background-color:#EEEEEE;">high-level<br/>program</td>
    <td class="box" style="background-color:#EEEEEE;">high-level<br/>program</td>
    <td class="box" style="background-color:#EEEEEE;">high-level<br/>program</td>
    <td class="box" style="background-color:#EEEEEE;">high-level<br/>program</td>
  </tr>
  <tr><td class="box" colspan="4" style="background-color:#ECECEC;">compiler</td></tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">machine<br/>program</td>
    <td class="box" style="background-color:lightyellow;">machine<br/>program</td>
    <td class="box" style="background-color:lightyellow;">machine<br/>program</td>
    <td class="box" style="background-color:lightyellow;">machine<br/>program</td>
  </tr>
  <tr><td class="box" colspan="4" style="background-color:#ECECEC;">machine languauge</td></tr>
  <tr><td class="box" colspan="4" style="background-color:lightyellow;">operating system</td></tr>
  <tr>
    <td class="box" colspan="4" style="background-color:#CCCCCC;">
      <table class="container">
        <tr>
          <td class="box" style="background-color:orange;">CPU</td>
          <td class="box" style="background-color:orange;">CPU</td>
          <td class="box" style="background-color:orange;">CPU</td>
          <td class="box" style="background-color:orange;">memory</td>
          <td class="box" style="background-color:orange;">input device</td>
          <td class="box" style="background-color:orange;">output device</td>
          <td class="box" style="background-color:orange;">other device</td>
        </tr>
      </table>
      hardware
    </td>
  </tr>
</table>
      </div></div></div>
<span class="text top">One could collapse this into a relatively simple diagram by omitting the portions of the diagram that do not represent components that either appear to be running to the user, or are actually running on the device.</span>
<a name="9d042ac197734b078f57c6a794aba34f"></a><div class="linked block"><div class="link-block">[<a href="#9d042ac197734b078f57c6a794aba34f">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="diagram other">
<table class="container">
  <tr>
    <td class="box" style="background-color:lightyellow;">application</td>
    <td class="box" style="background-color:lightyellow;">application</td>
    <td class="box" style="background-color:lightyellow;">application</td>
    <td class="box" style="background-color:lightyellow;">application</td>
  </tr>
  <tr><td class="box" colspan="4" style="background-color:lightyellow;">operating system</td></tr>
  <tr><td class="box" colspan="4" style="background-color:#CCCCCC;">hardware</td></tr>
</table>
      </div></div></div>
<span class="text top">The above diagram might represent a single computer in a single physical location running a single operating system and a few applications. Today, this picture is much more complicated. While many devices are still captured by the above diagram, in many other cases the actual abstractions provided are much more rich and diverse, and they reflect the diverse ecosystem of capabilities and components available to a user, programmer, or application.</span>
<a name="22af888b60e1470eaf396aaf6486859d"></a><div class="linked block"><div class="link-block">[<a href="#22af888b60e1470eaf396aaf6486859d">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="diagram other">
<table class="container">
  <tr>
    <td class="box" colspan="10" style="background-color:lightyellow;">app.</td>
    <td class="box" style="background-color:lightyellow;">app.</td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td class="box" colspan="11" style="background-color:lightyellow;">web app. platform</td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td class="box" colspan="11" style="background-color:lightyellow;">browser</td>
    <td class="box" style="background-color:lightyellow;">app.</td>
    <td class="box" colspan="3" style="background-color:lightyellow;">app.</td>
  </tr>
  <tr>
    <td class="box" colspan="8" style="background-color:lightyellow;">API</td>
    <td class="box" style="background-color:lightyellow;">API</td>
    <td class="box" colspan="3" style="background-color:lightyellow;">OS</td>
    <td class="box" colspan="3" style="background-color:lightyellow;">OS</td>
  </tr>
  <tr>
    <td class="box" colspan="8" style="background-color:lightyellow;">web service</td>
    <td class="box" style="background-color:lightyellow;">web service</td>
    <td class="box" colspan="3" style="background-color:lightyellow;">virtual machine</td>
    <td class="box" colspan="3" style="background-color:lightyellow;">virtual machine</td>
  </tr>
  <tr>
    <td class="box" colspan="8" style="background-color:lightyellow;">dist. platform</td>
    <td class="box" style="background-color:lightyellow;">web server</td>
    <td class="box" colspan="6" style="background-color:lightyellow;">virtualization layer</td></tr>
  <tr>
    <td class="box" colspan="3" style="background-color:lightyellow;">controller</td>
    <td class="box" colspan="5" style="background-color:lightyellow;">controller</td>
    <td class="box" style="background-color:lightyellow;">OS</td>
    <td class="box" colspan="6" style="background-color:lightyellow;">host operating system</td>
  </tr>
  <tr>
    <td class="box" style="background-color:#CCCCCC; font-size:8px;">node</td>
    <td class="box" style="background-color:#CCCCCC; font-size:8px;">node</td>
    <td class="box" style="background-color:#CCCCCC; font-size:8px;">node</td>
    <td class="box" style="background-color:#CCCCCC; font-size:8px;">node</td>
    <td class="box" style="background-color:#CCCCCC; font-size:8px;">node</td>
    <td class="box" style="background-color:#CCCCCC; font-size:8px;">node</td>
    <td class="box" style="background-color:#CCCCCC; font-size:8px;">node</td>
    <td class="box" style="background-color:#CCCCCC; font-size:8px;">node</td>
    <td class="box" style="background-color:#CCCCCC;">server</td>
    <td class="box" colspan="6" style="background-color:#CCCCCC;">hardware (web/cloud server)</td>
  </tr>
</table>
      </div></div></div>
<span class="text top">Today, the picture is much more complicated. Many applications running on a device actually provide capabilities that are assembled from a collection of underlying layers of potentially interdependent components. Every component in every layer must provide an interface and a collection of abstractions that capture its capabilities and communicate them to users (and expose them to the components on the layers above). Effectively, every component in every layer has a programming language, and assembling multilayered applications may require many compilation steps at various layers.</span></div>
  <a name="5.2"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#5.2">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">5.2.</span> Transformations between abstract syntaxes</h3>
<a name="dfe2befbecb0490b8983a5bc51697a09"></a><div class="linked block"><div class="link-block">[<a href="#dfe2befbecb0490b8983a5bc51697a09">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
Given two abstract syntaxes <i>A</i> and <i>B</i> (i.e., both <i>A</i> and <i>B</i> are sets of parse trees that conform to two distinct grammars), an algorithm that <i>always terminates</i> and maps parse trees in <i>A</i> to parse trees in <i>B</i> is called a <i>compilation algorithm</i>, and it is said to <i>compile</i> programs in the language corresponding to <i>A</i> into programs in the language corresponding to <i>B</i>. Note that while a compiler must always terminate on all inputs, it is allowed to return an error on some inputs.
      </div></div></div>
<span class="text top">Note the similarities and distinctions between an interpreter and a compiler. Both interpreters and compilers map some set of abstract syntax trees to some other set of abstract syntax trees (in the case of interpreters, the resulting abstract syntax trees are usually <i>values</i> that are simpler than programs). However, an interpreter might not terminate (e.g., if the program it is interpreting does not terminate when it is evaluated and/or executed), while a compiler must terminate. Furthermore, an interpreter must keep track of both values and side effects (such as output), while a compiler is simply transforming one program into another program without concerning itself with what the program might do when evaluated/executed.</span>
<a name="9ae3f8346677473dbe6662fed72eae51"></a><div class="linked block"><div class="link-block">[<a href="#9ae3f8346677473dbe6662fed72eae51">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="diagram other">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">source language<br/>abstract syntax</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">compiler</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">target language<br/>abstract syntax</td>
  </tr>
</table>
      </div></div></div>
<span class="text top">Often, the term <i>compiler</i> will refer to the entire toolchain of components that make it possible to convert the character string (i.e., concrete syntax) representation of a program in the source language into the concrete syntax representation of the program in the target language. In these cases, we will refer to the individual component that performs compilation as the <i>compilation algorithm</i> or <i>compilation component</i>.</span>
<a name="de262b467bf14e31ab31711c9ea49a8c"></a><div class="linked block"><div class="link-block">[<a href="#de262b467bf14e31ab31711c9ea49a8c">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="diagram other">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">source language<br/>concrete syntax</td>
    <td></td>
    <td></td>
    <td></td>
    <td class="box" style="background-color:powderblue;">libraries</td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&#8659;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td><span style="font-size:20px;">&#8659;</span></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">parser</td>
    <td></td>
    <td></td>
    <td></td>
    <td class="box" style="background-color:lightyellow;">linker</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">target language<br/>concrete syntax</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&#8659;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td><span style="font-size:20px;">&#8657;</span></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td class="box" style="background-color:powderblue;">source language<br/>abstract syntax</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">compilation<br/>algorithm</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">target language<br/>abstract syntax</td>
    <td></td>
    <td></td>
  </tr>
</table>
      </div></div></div>
<span class="text top">Furthermore, a compilation algorithm will often consist of multiple stages. Each stage may perform some specific task, such as simplifying the features used in a program (e.g., eliminating procedures and replacing them with labels and branching statements, or eliminating variable names and replacing them with explicit memory addresses), or it may perform optimizations (e.g., elimination of unreachable code blocks). The <i>intermediate representation</i> (IR) between each stage might be a distinct abstract syntax data structure.</span>
<a name="e45efeea541c4424b8213b67578f393e"></a><div class="linked block"><div class="link-block">[<a href="#e45efeea541c4424b8213b67578f393e">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="diagram other">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">source<br/>language<br/>abstract<br/>syntax</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">comp.<br/>alg. A</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">IR<br/>#1</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">comp.<br/>alg. B</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">IR<br/>#2</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">comp.<br/>alg. C</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">target<br/>language<br/>abstract<br/>syntax</td>
  </tr>
</table>
      </div></div></div></div>
  <a name="5.3"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#5.3">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">5.3.</span> Machine languages and bytecodes</h3>
<a name="a3c0158e667c47a8b3b73cf929ebc7af"></a><div class="linked block"><div class="link-block">[<a href="#a3c0158e667c47a8b3b73cf929ebc7af">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
Given a model of a computer that consists of a single central processing unit (CPU) that can perform some basic operations, and a block of memory (accessible to the CPU) that is organized using some kind of sequential and/or hierarchical addressing scheme (e.g., positive integers in some range represent memory locations), a <i>machine language</i>, <i>assembly language</i>, or <i>machine code</i> is an imperative programming language that consists of instructions that can directly be executed by a single CPU.
      </div></div></div>
<span class="text top">Note that in modern systems and networks, machine code might not be executed by a CPU directly. Instead, a program might be running on an operating system that might itself be running on a virtual machine, which is being simulated by a program that runs on a physical computer but emulates the behavior of a (perhaps very different) CPU and memory.</span>
<a name="91ebfabbdd9f42e7bfd579be18a6d52a"></a><div class="linked block"><div class="link-block">[<a href="#91ebfabbdd9f42e7bfd579be18a6d52a">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
A <i>bytecode</i> is a low-level programming language that is similar to a machine language (i.e., the instructions in the language are primarily for manipulating memory and performing basic arithmetic and logical operations) but is not platform-dependent (i.e., dependent on a particular CPU model), and itself needs to be either interpreted (e.g., by a run-time system or virtual machine) or compiled into a machine language.
      </div></div></div>
<span class="text top">Note that there is a distinction between machine code and bytecode, though this distinction is increasingly harder to discern in practice with the advent of widespread virtualization. Usually, machine code is said to be <i>executed</i> when it is run on its native CPU, and <i>simulated</i> if it is being executed by some software application that emulates the behavior of a CPU; bytecode is typically executed by an interpreter, which might be called a <i>run-time system</i> or a <i>virtual machine</i> (depending on the features and capabilities of the interpreter, some of which will be discussed in more detail in subsequent sections). Examples of bytecodes include the Java bytecode (interpreted by the Java Virtual Machine, or JVM) and the Python bytecode.</span>
<a name="3ee4c63a96db4254ba2b6ad0ee4e29a2"></a><div class="linked block"><div class="link-block">[<a href="#3ee4c63a96db4254ba2b6ad0ee4e29a2">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Consider the following target language, which has many characteristics of a machine language or bytecode. A program consists of an ordered sequence of instructions that can manipulate a block of memory addresses.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>instruction</i> <i>program</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
              <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>instruction</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>label</b> <i>label</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>branch</b> <i>label</i> <i>address</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>branch</b> <i>label</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>set</b> <i>address</i> <i>number</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>copy</b> <i>address</i> <i>address</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>add</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>label</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid label</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>address</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any positive integer or zero</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>number</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any positive integer or zero</i>
</td></tr></table></td></tr></table>
We can implement a simple Python simulator (or virtual machine, if the above is a bytecode) for this language.</span>
        
<div class="code"><div class="source"><pre><code class="py">
# Simulate a machine running the program represented by the string s.
def simulate(s):
    instructions = [l.split(" ") for l in s.split("\n")]
    mem = {0: 0}
    control = 0
    while control < len(instructions):
        inst = instructions[control]
        if inst[0] == 'label':
            pass
        # For two arguments, test the memory address in the second
        # argument; given one argument, branch unconditionally.
        if inst[0] == 'branch':
            if len(inst) == 2 or mem[int(inst[2])] != 0:
                control = instructions.index(['label', inst[1]])
                continue
        if inst[0] == 'set':
            mem[int(inst[1])] = int(inst[2])
        if inst[0] == 'copy':
            mem[int(inst[2])] = mem[int(inst[1])]
        if inst[0] == 'add':
            mem[0] = mem[1] + mem[2]
        control = control + 1
    return mem[0]
        </code></pre></div></div>
        
<span class="text">A program in this language might look as follows:</span>
        
<div class="code"><div class="source"><pre><code class="py">
>>> p = '''
  label start
  set 1 2
  set 2 3
  branch skip 1
  set 2 40
  label skip
  add
  '''
>>> simulate(p)
5
        </code></pre></div></div>        
      </div></div></div>
<a name="3246043602d540668dc63d5b6277a47f"></a><div class="linked block"><div class="link-block">[<a href="#3246043602d540668dc63d5b6277a47f">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">In this example, the target language will be a slightly more complex machine language than the one presented in <a href="#3ee4c63a96db4254ba2b6ad0ee4e29a2">a previous example</a>. A program consists of an ordered sequence of instructions that can manipulate a block of memory addresses. The abstract syntax for the language is presented below.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>instruction</i> <i>program</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
              <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>instruction</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>label</b> <i>label</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>goto</b> <i>label</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>branch</b> <i>label</i> <i>address</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>jump</b> <i>address</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>set</b> <i>address</i> <i>number</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>copy</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>add</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>label</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any alphanumeric character string</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>address</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any integer</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>number</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any integer</i>
</td></tr></table></td></tr></table>
When a machine is running a program, the state of the machine consists of a single block of memory (indexed by integers: both negative and positive) and a single integer representing the machine's position in the sequence of instructions (this integer represents which instruction in the program currently has <i>control</i>, i.e., which instruction is being executed by the CPU). The memory has eight special memory locations, which are defined below:
<ul>
  <li><b>memory address 0:</b> the address of the result of an <b>add</b> operation;</li>
  <li><b>memory address 1:</b> the address of the first input to an <b>add</b> operation;</li>
  <li><b>memory address 2:</b> the address of the second input to an <b>add</b> operation;</li>
  <li><b>memory address 3:</b> the address containing the "from" address for a <b>copy</b> operation;</li>
  <li><b>memory address 4:</b> the address containing the "to" address for a <b>copy</b> operation;</li>
  <li><b>memory address 5:</b> the output buffer (set to &#8722;1 after every step);</li>
  <li><b>memory address 6:</b> the address of the program's control index.</li>
</ul>
The meaning of each instruction is described below:
<ul>
  <li><b>label <i>l</i>:</b> there is no effect and control is passed to the next instruction;</li>
  <li><b>goto <i>l</i>:</b> control immediately moves to the program instruction <b>label</b> <i>l</i>;</li>
  <li><b>branch <i>l</i> <i>a</i>:</b> control immediately moves to the program instruction <b>label</b> <i>l</i> if memory address <i>a</i> contain a non-zero integer;</li>
  <li><b>jump <i>a</i>:</b> if the integer <i>i</i> is stored in memory address <i>a</i>, control moves immediately to the <i>i</i>th instruction in the program;</li>
  <li><b>set <i>a</i> <i>n</i>:</b> memory address <i>a</i> is set to the integer <i>n</i>;</li>
  <li><b>copy:</b> if <i>a</i> is the integer stored in memory address 3, and <i>b</i> is the integer stored in memory address 4, then the contents of memory address <i>a</i> are copied to memory address <i>b</i>;</li>
  <li><b>add:</b> the contents of memory location 1 and memory location 2 are added and stored in memory location 0.</li>
</ul>
We can implement a simple <a href="hw3/machine.py">Python simulator</a> for this language.
<br/><br/>
As an example of how this language might be used, suppose we want to write a program in this language to copy the contents of memory address 10 to memory address 20. The machine language program presented below would have this behavior:</span>   
        
<div class="code"><div class="source"><pre><code class="py">
set 3 10
set 4 20
copy
        </code></pre></div></div>
        
<span class="text">In fact, we can write a Python program that can generate an instance of the above for any two addresses. Notice that the <code>copy()</code> function below can be viewed as a macro that generates a specific machine language program.</span>
        
<div class="code"><div class="source"><pre><code class="py">
def copy(frm, to):
   return [\
      'set 3 ' + str(frm),\
      'set 4 ' + str(to),\
      'copy'\
   ]
        </code></pre></div></div>
        
<span class="text">Suppose we have another macro <code>increment()</code> that takes a single argument, a memory address, and generates a machine program that increments the value at the address specified memory address. We could then implement the following macro, which will set an entire region of memory to a particular constant.</span>
        
<div class="code"><div class="source"><pre><code class="py">
def setAllToInRegion(constant, startAddr, endAddr):
  # Memory location 8 contains the constant.
  # Memory location 9 contains the counter.  
  return [\
        'set 8 ' + str(constant),\
        'set 9 ' + str(startAddr),\
        'label loop'\
      ] \
      # Set second argument (destination) of copy.
      + copy(9,4)\
      + [\
        # Set first argument (source) for copy.
        'set 3 8',\
        'copy'\
      ]\
      # Increment the counter.
      + increment(9) \
      # If counter is endAddr, break out of loop;
      # otherwise, go back to the beginning of the loop.
      # We check by adding -endAddr to the counter.
      # First argument of add.
      + copy(9,1) \
      + [\
        # Second argument of add.
        'set 2 -' + str(endAddr),\
        'add',\
        'branch loop 0'\
      ]
        </code></pre></div></div>
        
<span class="text">Running <code>setAllToInRegion()</code> on specific inputs generates a machine language program for a particular region.</span>
        
<div class="code"><div class="source"><pre><code class="py">
>>> setAllToInRegion(3, 10, 100)
['set 8 3', 
 'set 9 10', 
 'label loop', 
 'set 3 9', 
 'set 4 4', 
 'copy', 
 'set 3 8', 
 'copy', 
 '# increment() done as homework.',
 'set 3 9', 
 'set 4 1', 
 'copy', 
 'set 2 -100', 
 'add', 
 'branch loop 0']
        </code></pre></div></div>
        
<span class="text">The version below works with the <a href="machine.php">web-based machine language simulator</a> (but it only initializes a region up to address <code>15</code>). Note that <code>#increment#</code> is a macro provided by the simulator and not part of the machine language itself; you cannot use <code>#increment#</code> when working on an assignment because simulator provided to you will not support such macros.</span>
        
<div><div class="button"><button onclick="window.open('machine.php?instructions=set_8_3~set_9_10~label_loop~set_3_9~set_4_4~copy~set_3_8~copy~%23increment%23_9~set_3_9~set_4_1~copy~set_2_-15~add~branch_loop_0');">simulator</button></div><div class="code" style="margin-top:0px; border-top:0px;"><div class="source"><br/><span class="keyword">set</span>&nbsp;8&nbsp;3<br/><span class="keyword">set</span>&nbsp;9&nbsp;10<br/><span class="keyword">label</span>&nbsp;loop<br/><span class="keyword">set</span>&nbsp;3&nbsp;9<br/><span class="keyword">set</span>&nbsp;4&nbsp;4<br/><span class="keyword">copy</span><br/><span class="keyword">set</span>&nbsp;3&nbsp;8<br/><span class="keyword">copy</span><br/><span class="builtin">#increment#</span>&nbsp;9<br/><span class="keyword">set</span>&nbsp;3&nbsp;9<br/><span class="keyword">set</span>&nbsp;4&nbsp;1<br/><span class="keyword">copy</span><br/><span class="keyword">set</span>&nbsp;2&nbsp;-15<br/><span class="keyword">add</span><br/><span class="keyword">branch</span>&nbsp;loop&nbsp;0<br/><br/></div></div></div>
      </div></div></div>
<a name="f45c0fc303524727bd5b3e1cae4ff32b"></a><div class="linked block"><div class="link-block">[<a href="#f45c0fc303524727bd5b3e1cae4ff32b">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Suppose we need to copy a value 123 from memory address 9 to memory address 12. However, we do not know that the source address is memory address 9. Instead, 9 is stored in memory address 0 at the beginning of our machine language program. Can we still copy from memory address 9?</span>
        
<div><div class="button"><button onclick="window.open('machine.php?instructions=set_0_9~set_9_123~set_3_0~set_4_3~copy~set_4_12~copy');">simulator</button></div><div class="code" style="margin-top:0px; border-top:0px;"><div class="source"><br/><span class="keyword">set</span>&nbsp;0&nbsp;9<br/><span class="keyword">set</span>&nbsp;9&nbsp;123<br/><span class="keyword">set</span>&nbsp;3&nbsp;0<br/><span class="keyword">set</span>&nbsp;4&nbsp;3<br/><span class="keyword">copy</span><br/><span class="keyword">set</span>&nbsp;4&nbsp;12<br/><span class="keyword">copy</span><br/><br/></div></div></div>
        
<span class="text">We do so in the above machine language program by first copying from memory address 0 to the memory address corresponding to the source parameter for the <b>copy</b> instruction (notice that we are copying an address, but the machine language program does not know this and simply copies the integer in memory address 0 to memory address 3).</span>
        <div class="paragraph">
Now, memory address 3 contains the source address we want (which is 9), so we set the destination address for the <b>copy</b> instruction by putting 12 into memory address 4. The final <b>copy</b> instruction now copies the value 123 from memory address 9 to memory address 12, as desired.
        </div>
      </div></div></div>
<a name="4c36a001f5ba4f44b817fd3b0f4de1bf"></a><div class="linked block"><div class="link-block">[<a href="#4c36a001f5ba4f44b817fd3b0f4de1bf">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Suppose the value we want to copy to address 0 is in address 13. The value is actually 999 but we do not know this. We also do not know that it is in address 13. We only know that memory address 7 contains the address that holds the address that holds the value 999 (in reality, address 7 holds the address 11, and address 11 holds the address 13, and address 13 holds the value 999). In other words, what if there are two layers of indirection between the value we want and the address we have?</span>
        <div class="paragraph">
We can set this situation up using our machine language by setting memory addresses 7, 11, and 13 to appropriate values. How can we then write a machine language program that copies the value from address 13 to address 0 when all it knows about is address 7?
        </div>
        
<div><div class="button"><button onclick="window.open('machine.php?instructions=set_7_11~set_11_13~set_13_999~set_3_7~set_4_3~copy~set_4_3~copy~set_4_0~copy');">simulator</button></div><div class="code" style="margin-top:0px; border-top:0px;"><div class="source"><br/><span class="keyword">set</span>&nbsp;7&nbsp;11<br/><span class="keyword">set</span>&nbsp;11&nbsp;13<br/><span class="keyword">set</span>&nbsp;13&nbsp;999<br/><span class="keyword">set</span>&nbsp;3&nbsp;7<br/><span class="keyword">set</span>&nbsp;4&nbsp;3<br/><span class="keyword">copy</span><br/><span class="keyword">set</span>&nbsp;4&nbsp;3<br/><span class="keyword">copy</span><br/><span class="keyword">set</span>&nbsp;4&nbsp;0<br/><span class="keyword">copy</span><br/><br/></div></div></div>
        
<span class="text">We do so in the above machine language program by first copying the address 11 contained in address 7 to the source copy parameter address 3. We can then issue another copy command that copies 13 from memory address 11 to the source copy parameter address 3. Finally, once we've set up a situation in which we can copy from address 13, we can issue one more copy command to copy the integer value 999 from address 13 to address 0.</span>
      </div></div></div></div>
  <a name="5.4"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#5.4">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">5.4.</span> Compiling expressions to a machine language or bytecode</h3>
<span class="text top">In order to compile a high-level language to a machine language that only provides the CPU and indexed memory abstractions, it is necessary to transform the high-level language's parse tree into a series of instructions that manipulate memory in a way that appears identical to the behavior of the high-level program when it is being interpreted.
<br/><br/>
Since machine language programs describe how to manipulate memory, it is a good idea to plan how the machine program will utilize the memory available to it to store intermediate results it needs to compute while the program is running.</span>
<a name="f7d602562fe211e38cf6ce3f5508acd9"></a><div class="linked block"><div class="link-block">[<a href="#f7d602562fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
        
<span class="text">The region of memory that a machine program uses to store values (i.e., results of computing expressions) is called the <i>heap</i>.</span>
        <div class="paragraph">
As a machine program continues running and computing more results, it <i>grows</i> the heap by adding values to new memory locations. To keep track of this at the time of compilation, the compiler might maintain a counter that stores the current "top" of the heap. When a machine program is running, it may itself maintain a <i>heap pointer</i> to keep track of the last item stored on the heap, primarily so that it knows where to look for more space if it wants to store more values in memory.
        </div>
      </div></div></div>
<a name="f288b6e6a04d45e58feb24c6f72de96a"></a><div class="linked block"><div class="link-block">[<a href="#f288b6e6a04d45e58feb24c6f72de96a">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Suppose we are starting with the following source language:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>formula</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> | <b>false</b> | <b>not</b> <i>formula</i> | <i>formula</i> <b>and</b> <i>formula</i> | <i>formula</i> <b>or</b> <i>formula</i>
</td></tr></table></td></tr></table>
How can we implement a compiler that converts formulas in the source language into sequences of instructions in the target language in the <a href="#3ee4c63a96db4254ba2b6ad0ee4e29a2">previous example</a>?
<br/><br/>
We can approach this problem by constructing a function <code>compileFormula()</code> that takes as its input the parse tree, and a variable <code>heap</code> that represents the highest address in memory that contains a computed value (in our case, <code>1</code> can represent <b>true</b> and <code>0</code> can represent <b>false</b>). The function returns a list of machine language instructions that computes that value, as well as the memory address where that value would be stored if anyone actually executed (or simulated) the machine language program.</span>       
        
<div class="code"><div class="source"><pre><code class="py">
def compileFormula(f, heap = 3, fresh = 0):
    if type(f) == Leaf:
        if f == 'True':
            # Find a new memory address on the heap.
            heap = heap + 1
            # Generate instruction to store the integer representing 'True' on the heap.
            inst = 'set ' + str(heap) + ' 1'
            # Return the instruction list and "top" of the heap.
            return ([inst], heap, fresh)
        if f == 'False':
            # Find a new memory address on the heap.
            heap = heap + 1
            # Generate instruction to store the integer representing 'False' on the heap.
            inst = 'set ' + str(heap) + ' 0'
            # Return the instruction list and "top" of the heap.
            return ([inst], heap, fresh)
    if type(f) == Node:
        for label in f:
            children = f[label]
            if label == 'Not':
                # Compile the subtree f to obtain the list of
                # instructions that computes the value represented
                # by f.
                f = children[0]
                (insts, heap, fresh) = compileFormula(f, heap, fresh)
                # Generate more instructions to change the memory
                # location in accordance with the definition of the
                # 'Not' operation.
                instsNot = \
                   ["branch setZero" + str(fresh) + " " + str(heap),\
                    "set " + str(heap) + " 1",\
                    "branch finish" + str(fresh),\
                    "label setZero" + str(fresh),\
                    "set " + str(heap) + " 0",\
                    "label finish" + str(fresh)\
                   ]
                return (insts + instsNot, heap, fresh + 1)
            if label == 'Or':
                # Compile the two subtrees and get the instructions
                # lists as well as the addresses in which the results
                # of computing the two subtrees would be stored if someone
                # were to run those machine instructions.
                f1 = children[0]
                f2 = children[1]
                (insts1, heap2, fresh1) = compileFormula(f1, heap, fresh)
                (insts2, heap3, fresh2) = compileFormula(f2, heap2, fresh1)
                # Increment the heap counter so we store the
                # result of computing 'Or' in a new location.
                heap4 = heap3 + 1
                # Add instructions that compute the result of the
                # 'Or' operation.
                instsOr = \
                   ["copy " + str(heap2) + " 1",\
                    "copy " + str(heap3) + " 2",\
                    "add",\
                    "branch setOne" + str(fresh2) + " 0",\
                    "branch finish" + str(fresh2),\
                    "label setOne" + str(fresh2),\
                    "set 0 1",\
                    "label finish" + str(fresh2),\
                    "copy 0 " + str(heap4)\
                   ]
                return (insts1 + insts2 + instsOr, heap4, fresh2 + 1)
        </code></pre></div></div>
      </div></div></div></div>
  <a name="5.5"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#5.5">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">5.5.</span> Compiling statement sequences and procedures to a machine language or bytecode</h3>
<a name="5d9506c23103486b988313047a5182b7"></a><div class="linked block"><div class="link-block">[<a href="#5d9506c23103486b988313047a5182b7">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Suppose we want to compile the following program in an imperative programming language that supports <b>while</b> loops to a machine language program in our machine language.</span>
        
<div class="code"><div class="source"><pre><code class="py">
x := true; 
while x { 
  x := false; 
}
print false;
        </code></pre></div></div>
        
<span class="text">If our heap begins at memory address 8 and <code>true</code> is represented as 1, then our compiler would first emit the instruction <b>set</b> 8 1 and would store inside the environment a mapping {x &#x21A6; 8}. It would then use this information to compile the expression condition and assignment statement in the body of the loop.</span>
        
<div><div class="button"><button onclick="window.open('machine.php?instructions=set_8_1~label_startLoop~branch_bodyLoop_8~goto_endLoop~label_bodyLoop~set_9_0~set_3_9~set_4_8~copy~goto_startLoop~label_endLoop~set_5_0');">simulator</button></div><div class="code" style="margin-top:0px; border-top:0px;"><div class="source"><br/><span class="keyword">set</span>&nbsp;8&nbsp;1<br/><span class="keyword">label</span>&nbsp;startLoop<br/><span class="keyword">branch</span>&nbsp;bodyLoop&nbsp;8<br/><span class="keyword">goto</span>&nbsp;endLoop<br/><span class="keyword">label</span>&nbsp;bodyLoop<br/><span class="keyword">set</span>&nbsp;9&nbsp;0<br/><span class="keyword">set</span>&nbsp;3&nbsp;9<br/><span class="keyword">set</span>&nbsp;4&nbsp;8<br/><span class="keyword">copy</span><br/><span class="keyword">goto</span>&nbsp;startLoop<br/><span class="keyword">label</span>&nbsp;endLoop<br/><span class="keyword">set</span>&nbsp;5&nbsp;0<br/><br/></div></div></div>
      </div></div></div>
<a name="f7d604542fe211e38cf6ce3f5508acd9"></a><div class="linked block"><div class="link-block">[<a href="#f7d604542fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
        
<span class="text">The region of memory that a machine program uses to store information that makes it possible to simulate calls to named procedures is called the <i>stack</i>.</span>
        <div class="paragraph">
In its simplest form, the stack is simply a region of memory that holds integers corresponding to program locations. The top of the stack always corresponds to the program location to which control must move once the procedure that is currently being executed (or simulated) reaches the end of its body.
        </div>
      </div></div></div>
<a name="f7d618222fe211e38cf6ce3f5508acd9"></a><div class="linked block"><div class="link-block">[<a href="#f7d618222fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Suppose we are starting with the following source language:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>variable</i> <b>:=</b> <i>formula</i> <b>;</b> <i>program</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>print</b> <i>formula</i> <b>;</b> <i>program</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>procedure</b> <i>variable</i> <b>{</b> <i>program</i> <b>}</b> <i>program</i>  </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>call</b> <i>variable</i> <b>;</b> <i>program</i>  </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>formula</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> | <b>false</b> | <i>variable</i> | <b>not</b> <i>formula</i> | <i>formula</i> <b>and</b> <i>formula</i> | <i>formula</i> <b>or</b> <i>formula</i>
</td></tr></table></td></tr></table>
How can we implement a compiler that converts formulas in the source language into sequences of instructions in the target language in a <a href="#3246043602d540668dc63d5b6277a47f">previous example</a>?</span>
        <div class="paragraph">
As an example, suppose we begin with the following program.
        </div>
        
<div class="code"><div class="source"><pre><code class="py">
procedure printProc {
  print true;
  print false;
}
call printProc;
print false;
call printProc;
print true;
        </code></pre></div></div>
        
<span class="text">If we want to compile the above program, we will need to ensure that the machine language program passes control to the block of machine code representing the procedure body, and then passes it back when the body finishes running.</span>
        <div class="paragraph">
However, we must compile the procedure into a <i>single</i> block of machine code. How will that block know whether to come back to the point in the machine language program corresponding to the first <code>call printProc;</code> statement, or to the point corresponding to the second <code>call printProc;</code> statement?
        </div>
        <div class="paragraph">
We will need to make sure that the <code>call printProc;</code> are compiled into machine code that stores the index of the current instruction at each call point at a particular memory location (in this example, suppose it is memory address <code>7</code>). Then, the block of machine code into which the procedure body is compiled can always consult the same memory location to determine to which point it should pass control back after the machine code for the procedure body finishes executing. Because control should not go back to the <b>goto</b> instruction but beyond it, it may be necessary to increment the value representing the program location before using the <b>jump</b> instruction. We provide machine language pseudocode below that does just that.
        </div>
        
<div class="code"><div class="source"><pre><code class="py">
# The procedure.
goto printProcEnd   # Skip procedure body.
label printProc
set 5 1             # print true;
set 5 0             # print false;

# Return control to the last calling point.
< increment integer stored in address 7 by 2 >
jump 7
label printProcEnd

# The first call.
< copy integer from address 6 to address 7 >
goto printProc

set 5 0             # print false;

# The second call.
< copy integer from address 6 to address 7 >
goto printProc

set 5 1             # print true;
        </code></pre></div></div>
        <div class="paragraph">
The above approach might work if we never call a procedure from inside another procedure. However, it will not work if a <b>call</b> instruction appears inside the body of a procedure because that <b>call</b> instruction will be compiled into machine language instructions that overwrite the contents of memory address <code>7</code>, making it impossible to determine the program location to which control must return after the outermost procedure body finishes. To address this, it is possible to have the machine language program maintain a <a href="#f7d604542fe211e38cf6ce3f5508acd9"><i>stack</i></a> starting at memory location <code>7</code> that will keep track of all the program locations to which control must return after each nested procedure call finishes. We do so in the machine language pseudocode below.
        </div> 
        
<div class="code"><div class="source"><pre><code class="py">
# Set stack pointer to top of stack at address 8.
set 7 8

# The procedure.
goto printProcEnd   # Skip procedure body.
label printProc
set 5 1             # print true;
set 5 0             # print false;

# Return control to the last calling point.
< copy integer from top of stack 
  (i.e., integer/address contained in address 7) to address 1 >

< set address 2 to some constant
  (to skip the calling machine instructions) >

< add contents of address 1 and address 2 >
jump 0
label printProcEnd

# The first call.
< increment integer in address 7 (the stack pointer) >
< copy integer from address 6 to top of stack
  (i.e., address/integer specified in address 7) >

goto printProc

set 5 0             # print false;

# The second call.
< increment integer in address 7 (the stack pointer) >
< copy integer from address 6 to top of stack
  (i.e., address/integer specified in address 7) >

goto printProc

set 5 1             # print true;
        </code></pre></div></div>
      </div></div></div></div>
  <a name="5.6"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#5.6">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">5.6.</span> Common compiler optimizations and register allocation</h3>
<span class="text top">Optimization algorithms are typically transformations of the abstract syntax of a language. In a compiler, this abstract syntax is usually that of a particular intermediate representation used within the compiler, but optimizations might occur at any stage in the compilation process.</span>
<a name="187c109b829d484d8d5ef326088e52da"></a><div class="linked block"><div class="link-block">[<a href="#187c109b829d484d8d5ef326088e52da">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="diagram other">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">source<br/>language<br/>abstract<br/>syntax</td>
    <td><span style="font-size:20px;">&rArr;<br/>&lArr;</span></td>
    <td class="box" style="background-color:lightyellow;">optimization<br/>algorithm #1</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">compilation<br/>algorithm A</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:powderblue;">intermediate<br/>representation<br/>(IR) #1</td>
    <td><span style="font-size:20px;">&rArr;<br/>&lArr;</span></td>
    <td class="box" style="background-color:lightyellow;">optimization<br/>algorithm #2</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">compilation<br/>algoritm B</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:powderblue;">intermediate<br/>representation<br/>(IR) #2</td>
    <td><span style="font-size:20px;">&rArr;<br/>&lArr;</span></td>
    <td class="box" style="background-color:lightyellow;">optimization<br/>algorithm #3</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">compilation<br/>algorithm C</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:powderblue;">target<br/>language<br/>abstract<br/>syntax</td>
    <td><span style="font-size:20px;">&rArr;<br/>&lArr;</span></td>
    <td class="box" style="background-color:lightyellow;">optimization<br/>algorithm #4</td>
  </tr>
</table>
      </div></div></div>
<a name="f7d61c822fe211e38cf6ce3f5508acd9"></a><div class="linked block"><div class="link-block">[<a href="#f7d61c822fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
<i>Loop unrolling</i> is an optimization that involves duplicating loop bodies a constant number of times, typically to reduce the number of conditional <b>branch</b> instructions that must occur if the number of loop iterations is known at compile time. Depending on the particular language and compiler, the loop unrolling optimization could be applied to high-level language abstract syntax trees, intermediate representation abstract syntax trees, and sometimes to machine language programs.
      </div></div></div>
<a name="e5e18f0c7eea4f0d85cd48ae45d6ca0f"></a><div class="linked block"><div class="link-block">[<a href="#e5e18f0c7eea4f0d85cd48ae45d6ca0f">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Suppose we are compiling a program written in a high-level language that looks like the following.</span>
        
<div class="code"><div class="source"><pre><code class="py">
i = 0;
while (i < 1000000) {
  i++;
}
        </code></pre></div></div>
        
<span class="text">One option is to compile the above program into the following sequence of machine language instructions (assume that the variable <code>i</code> corresponds to memory address <code>123</code>).</span>
        
<div class="code"><div class="source"><pre><code class="py">
label whileLoop
< increment integer in address 123 >
< compare integer in address 123 to integer 1000000 and store result in address 200 >
branch whileLoop 200
        </code></pre></div></div>
        
<span class="text">If we execute the above machine language program, we will execute 1,000,000 comparison operations. We can reduce the cost of the comparison operations in this case by duplicating the body of the loop some number of times.</span>
        
<div class="code"><div class="source"><pre><code class="py">
i = 0;
while (i < 1000000) {
  i++;
  i++;
  i++;
  i++;
  i++;
  i++;
  i++;
  i++;
  i++;
  i++;
}
        </code></pre></div></div>
        
<span class="text">Notice that in the above program, we have reduced the number of comparison operations by a factor of 10. However, to achieve this we had to increase the size of the machine language program by a factor of 10.</span>
        
<div class="code"><div class="source"><pre><code class="py">
label whileLoop
< increment integer in address 123 >
< increment integer in address 123 >
< increment integer in address 123 >
< increment integer in address 123 >
< increment integer in address 123 >
< increment integer in address 123 >
< increment integer in address 123 >
< increment integer in address 123 >
< increment integer in address 123 >
< increment integer in address 123 >
< compare integer in address 123 to integer 1000000 and store result in address 200 >
branch whileLoop 200
        </code></pre></div></div>
      </div></div></div>
<a name="f7d6137c2fe211e38cf6ce3f5508acd9"></a><div class="linked block"><div class="link-block">[<a href="#f7d6137c2fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
<i>Constant folding</i> involves replacing subtrees (typically expressions) within an abstract syntax tree with values (the value should normally correspond to the result of evaluating the expression).
      </div></div></div>
<a name="8e950576073f4bf79045b9e636757453"></a><div class="linked block"><div class="link-block">[<a href="#8e950576073f4bf79045b9e636757453">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Suppose we have the following abstract syntax tree.</span>
        
<div class="code"><div class="source"><pre><code class="py">
{'Print': [
  {'Plus': [
    {'Mult':[{'Number':[3]}, {'Number':[4]}]},
    {'Variable':['x']}
  ]}
]}
        </code></pre></div></div>
        
<span class="text">An optimization algorithm that performs constant folding might traverse the above tree, recognize that the subtree <code>{'Mult':[{'Number':[3]}, {'Number':[4]}]}</code> can be evaluated in a finite amount of time, and then replace it with the value to which it evaluates. The overall tree would then look as follows.</span>
        
<div class="code"><div class="source"><pre><code class="py">
{'Print': [
  {'Plus': [
    {'Number':[12]},
    {'Variable':['x']}
  ]}
]}
        </code></pre></div></div>
      </div></div></div>
<a name="f7d6137c2fe211e38cf6ce3f5508a123"></a><div class="linked block"><div class="link-block">[<a href="#f7d6137c2fe211e38cf6ce3f5508a123">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
<i>Dead code elimination</i> involves removing subtrees (typically statements) within an abstract syntax tree that can never be reached (e.g., because a branching statement or loop condition is always false).
      </div></div></div>
<a name="196b533f6ecf46a6a4f7f639b072c51f"></a><div class="linked block"><div class="link-block">[<a href="#196b533f6ecf46a6a4f7f639b072c51f">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
        
<span class="text">An abstract syntax tree is in <i>single static assignment</i> or <i>SSA</i> form if every variable appears exactly once on the left-hand side of an assignment statement.</span>
        <div class="paragraph">
An abstract syntax tree can be converted into SSA form by converting every variable on the left-hand side of an assignment statement so that it is unique, and then replacing all occurrences of that variable with the version of that variable that appears in the last assignment above the occurrence.
        </div>
      </div></div></div>
<a name="266f498ec6374a7191ede114f45b244a"></a><div class="linked block"><div class="link-block">[<a href="#266f498ec6374a7191ede114f45b244a">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Suppose we have the following program in a high-level programming language.</span>
        
<div class="code"><div class="source"><pre><code class="py">
a := 2;
b := 5;
print a + b;
f := true and false;
print f;
a := 7;
g := true;
h := false;
b := 0;
print b;
print h;
print g;
print a;
        </code></pre></div></div>
        
<span class="text">If we converted the abstract syntax tree that represents the above program into SSA form, we might obtain an abstract syntax tree that represents the following program.</span>
        
<div class="code"><div class="source"><pre><code class="py">
a_0 := 2;
b_0 := 5;
print a_0 + b_0;
f_0 := true and false;
print f_0;
a_1 := 7;
g_0 := true;
h_0 := false;
b_1 := 0;
print b_1;
print h_0;
print g_0;
print a_1;
        </code></pre></div></div>
        
<span class="text">Notice that each variable in the original program has been associated with an index so that no variable in the new program ever appears on the left-hand of an assignment more than once.</span>
      </div></div></div>
<a name="25323684870d432981d07d82b725955e"></a><div class="linked block"><div class="link-block">[<a href="#25323684870d432981d07d82b725955e">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
<i>Register allocation</i> involves assigning a CPU register to each variable within the abstract syntax tree representing a program (typically an intermediate representation in single static assignment form). This usually requires building an <i>interference graph</i> of the variables within the program, and then solving the <i>graph coloring problem</i> where each register represents a color.
      </div></div></div>
<a name="51f35310e639411c98f9246c52e08f33"></a><div class="linked block"><div class="link-block">[<a href="#51f35310e639411c98f9246c52e08f33">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">When compiling list or set comprehensions in languages such as Haskell and Python, the operational semantics of comprehensions allows for parallelization of the individual steps in a way that iterative constructs do not allow. This is because in a comprehension, each "iteration" or "step" of the comprehension is evaluated under the same environment. In an imperative looping statement, the modified environment emitted by one iteration is fed into the execution of the next iteration, so the effects of each iteration accumulate over time. This requires executing each iteration one after the other, and keeping track of the changing environment.</span>
        <div class="paragraph">
Thus, it is possible to compile a program so that the individual "iterations" or "steps" of a comprehension are evaluated on different processors, or even different computers, and then reassembled into the final results. This is not necessarily possible with a looping statement.
        </div>
        <div class="paragraph">
You can see this in the two different operational semantics rules below (the first for an imperative looping statement, the second for a comprehension expression).
        </div>
        <div class="inferences"><table class="inference"><tr><td class="title">[Stmt-For]</td><td><table><tr><td class="premises">&nbsp;
              &Sigma;<sub>0</sub> &#8846; {<i>x</i> &#x21A6; 1}, <i>p</i> &dArr; &Sigma;<sub>1</sub>
              &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;<sub>1</sub> &#8846; {<i>x</i> &#x21A6; 2}, <i>p</i> &dArr; &Sigma;<sub>2</sub>
              &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;<sub>2</sub> &#8846; {<i>x</i> &#x21A6; 3}, <i>p</i> &dArr; &Sigma;<sub>3</sub>
            &nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;<sub>0</sub>, <b>for</b> <i>x</i> <b>in</b> {1,2,3}<b>:</b> <i>p</i> &dArr; &Sigma;<sub>3</sub>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Exp-Comprehension]</td><td><table><tr><td class="premises">&nbsp;
              &Sigma; &#8846; {<i>x</i> &#x21A6; 1}, <i>p</i> &dArr; <i>v</i><sub>1</sub>
              &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma; &#8846; {<i>x</i> &#x21A6; 2}, <i>p</i> &dArr; <i>v</i><sub>2</sub>
              &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma; &#8846; {<i>x</i> &#x21A6; 3}, <i>p</i> &dArr; <i>v</i><sub>3</sub>
            &nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <b>[</b> <i>e</i> <b>for</b> <i>x</i> <b>in</b> {1,2,3} <b>]</b> &dArr; [<i>v</i><sub>1</sub>, <i>v</i><sub>2</sub>, <i>v</i><sub>3</sub>]&nbsp;</td></tr></table></td></tr></table></div>
      </div></div></div>
<span class="text top">The following diagram illustrates how the various optimization and compilation algorithms described in this section might fit together within the architecture of a compiler.</span>
<a name="618c5606b9954085b951ad71231eccf9"></a><div class="linked block"><div class="link-block">[<a href="#618c5606b9954085b951ad71231eccf9">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="diagram other">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">high-level<br/>source<br/>language<br/>abstract<br/>syntax</td>
    <td><span style="font-size:20px;">&rArr;<br/>&lArr;</span></td>
    <td class="box" style="background-color:lightyellow;">loop<br/>unrolling</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">SSA conversion</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:powderblue;">IR in SSA form</td>
    <td><span style="font-size:20px;">&rArr;<br/>&lArr;</span></td>
    <td class="box" style="background-color:lightyellow;">constant<br/>folding</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">compilation</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:powderblue;">low-level IR</td>
    <td><span style="font-size:20px;">&rArr;<br/>&lArr;</span></td>
    <td class="box" style="background-color:lightyellow;">register<br/>allocation</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">instruction<br/>selection</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:powderblue;">low-level<br/>target<br/>machine<br/>language<br/>abstract<br/>syntax</td>
    <td></td>
    <td></td>
  </tr>
</table>
      </div></div></div></div>
  <a name="5.7"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#5.7">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">5.7.</span> Correctness of compilation algorithms</h3>
<span class="text top">Compilers represent a unique kind of software application because their implementation can affect the quality of all the software applications that they compile. This means that compiler flaws can be particularly expensive; as a result, there may be many practical justifications for investing heavily in verifying that a compiler, or components thereof, behave correctly. However, to determine whether a compiler behaves correctly, it is first necessary to define what constitutes correct behavior.
<br/><br/>
One way to define correct behavior is to appeal to the operational semantics of the source and target languages.</span>
<a name="a7d611922fe211e38cf6ce3f5508a123"></a><div class="linked block"><div class="link-block">[<a href="#a7d611922fe211e38cf6ce3f5508a123">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="diagram other">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">source language<br/>abstract syntax</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">compilation<br/>algorithm</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">target language<br/>abstract syntax</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&#8659;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td><span style="font-size:20px;">&#8659;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">source language<br/>operational semantics<br/>(interpreter)</td>
    <td></td>
    <td></td>
    <td></td>
    <td class="box" style="background-color:lightyellow;">target language<br/>operational semantics<br/>(simulator)</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&#8659;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:powderblue;">source language<br/>abstract syntax<br/>for values/outputs</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">simple<br/>conversion<br/>algorithm for<br/>values/outputs</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">target language<br/>abstract syntax<br/>for values/outputs</td>
  </tr>
</table>
      </div></div></div>
<a name="f7d611922fe211e38cf6ce3f5508acd9"></a><div class="linked block"><div class="link-block">[<a href="#f7d611922fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
Suppose we are given a source and target language (including the definitions of the abstract syntax and the operational semantics for each language, as well as corresponding interpretation/simulation functions <b>interpret()</b> and <b>simulate()</b>), a simple conversion algorithm <b>convert()</b> between the sets of values and outputs in each language, and a compilation algorithm <b>compile()</b>.
<br/><br/>
The compilation algorithm <b>compile()</b> is <i>correct</i> (or <i>behaves correctly</i>) if for all possible input programs <i>p</i> in the source language, the following equation is true:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><b>simulate(compile(</b><i>p</i><b>))</b><td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>convert(interpret(</b><i>p</i><b>))</b>
</td></tr></table></td></tr></table>
      </div></div></div>
<span class="text top">Notice that the <a href="#f7d611922fe211e38cf6ce3f5508acd9">above definition</a> of correctness is functional but perhaps not practical. If the operational semantics of one or both languages does not capture running time, security (e.g., stack overflows), or other concerns, the definition may be inadequate. We will discuss these issues in more detail in a <a href="#6">subsequent section</a>.
<br/><br/>
If the number of possible programs in the source language is infinite, it is impossible to check that the equation in the <a href="#f7d611922fe211e38cf6ce3f5508acd9">above definition</a> holds for all possible programs through testing alone, though testing can provide some confidence. Nevertheless, it may be possible to mathematically <i>prove</i> that the equation holds without doing any testing at all.
<br/><br/>
Software testing and verification is a broad area of research and practice that spans multiple (sometimes disparate) disciplines and communities. In this subsection, we will focus on three specific categories of testing and verification that are useful for determining the correctness of compiler implementations. These three categories represent only a small (but important) subset of the approaches currently being developed and used.</span>
<a name="f7d6204c2fe211e38cf6ce3f5508acd9"></a><div class="linked block"><div class="link-block">[<a href="#f7d6204c2fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
        
<span class="text">There are at least three possible approaches to verifying that a compiler's behavior conforms to its specification. These include:</span>
        <ul><li>suites of individual test cases;</li><li>bounded exhaustive testing;</li><li>formal (usually inductive) proof of correctness over all inputs.</li></ul>
      </div></div></div>
<a name="f7d61a842fe211e38cf6ce3f5508acd9"></a><div class="linked block"><div class="link-block">[<a href="#f7d61a842fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Bounded exhaustive testing involves defining a metric on inputs (e.g., a mapping from inputs to an integer), and then testing all inputs for which the matric is below a certain integer bound. For example, let us consider a simple language for formulas:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>formula</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> | <b>false</b> | <b>not</b> <i>formula</i>| <i>formula</i> <b>and</b> <i>formula</i> | <i>formula</i> <b>or</b> <i>formula</i> 
</td></tr></table></td></tr></table>
We can define a metric on the set of abstract syntax trees that conform to the above definition: the depth of the tree.</span>
        
<div class="code"><div class="source"><pre><code class="py">
Node = dict
Leaf = str

def metric(f):
    if type(f) == Leaf:
        return 1
    if type(f) == Node:
        for label in f:
            return 1 + max([metric(child) for child in f[label]])
        </code></pre></div></div>
        
<span class="text">We can then generate all trees whose metric falls within a specified bound.</span>
        
<div class="code"><div class="source"><pre><code class="py">
def formulas(n):
    if n <= 0:
        return []
    elif n == 1:
        return ['True', 'False']
    else:
        fs = formulas(n-1)
        fsN = []
        fsN += [{'Not':[f]} for f in fs]
        fsN += [{'And':[f1,f2]} for f1 in fs for f2 in fs]
        fsN += [{'Or':[f1,f2]} for f1 in fs for f2 in fs]
        return fs + fsN
        </code></pre></div></div>
        
<span class="text">It is then possible to use the above code to generate test cases automatically, and to check the equation specifying compiler correctness against each test case.</span>
      </div></div></div></div>
</div>
<a name="6"></a>
<div class="section"><hr /><h2 class="linked"><span class="link-title">[<a href="#6">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">6.</span> Static Analysis and Abstract Interpretation</h2>
<span class="text top">Most compilers and interpreters perform basic error checking and <i>static analysis</i> before running or compiling a program. This serves a variety of purposes, some of which include:
<ul>
  <li>catching errors in the program before incurring the cost (in time, power, etc.) or actually running it;</li>
  <li>returning more detailed and user-friendly error messages;</li>
  <li>determining information about the program that is required for the optimization and compilation algorithms (e.g., detecting opportunities for constant folding);</li>
  <li>improving performance of interpreted or compiled programs by eliminating run-time error checking;</li>
  <li>eliminating invalid test cases when doing bounded exhaustive testing.</li>
</ul>
Static analysis is related to a broader concept: <i>abstract interpretation</i>. It is possible to analyze programs along a variety of other dimensions that may of interest, including, for example, the program's range of outputs, the program's running time, the monetary cost of running the program, the program's power consumption, and so on.
<br/><br/>
Both static analysis and abstract interpretation algorithms are conventionally expected to terminate in a finite, and typically relatively fast, amount of time (e.g., it should be possible to run a new static analysis or abstract interpretation each and every time the program is compiled, even during an interactive programming and/or testing session).
<br/><br/>
In this section we present a notation for defining static analysis and abstract interpretation algorithms. This notation is very similar to the one we introduced for defining the <a href="#4.2">operational semantics</a> of programming languages.</span>
<a name="90ff364f95324f14b2b540e5d8fe6d13"></a><div class="linked block"><div class="link-block">[<a href="#90ff364f95324f14b2b540e5d8fe6d13">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="diagram other">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">source<br/>language<br/>concrete<br/>syntax</td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td class="box" style="background-color:powderblue;">target<br/>language<br/>abstract<br/>syntax</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td><span style="font-size:20px;">&uArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">parser</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">source<br/>language<br/>abstract<br/>syntax</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">static<br/>analysis<br/>algorithms</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">abstract<br/>syntax<br/>or IR</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">compilation<br/>algorithms</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td class="box" style="background-color:powderblue;">syntax<br/>errors</td>
    <td></td>
    <td></td>
    <td></td>
    <td class="box" style="background-color:powderblue;">other errors<br/>(unbound variables,<br/>type errors, etc.)</td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
</table>
      </div></div></div>
  <a name="6.1"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#6.1">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">6.1.</span> Monomorphic type systems and type checking</h3>
<span class="text top">A <i>type checking</i> algorithm is a specific kind of static analysis algorithm. It represents a "low-resolution" evaluation of the abstract syntax tree of a program to determine the <i>type</i> that can be assigned to every subtree in that program.</span>
<a name="f7d607382fe211e38cf6ce3f5508acd9"></a><div class="linked block"><div class="link-block">[<a href="#f7d607382fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Suppose we are working with a programming language with the following abstract syntax.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>expression</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> | <b>false</b> | <i>number</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>not</b> <i>expression</i>  </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>expression</i> <b>and</b> <i>expression</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>expression</i> <b>or</b> <i>expression</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>expression</i> <b>+</b> <i>expression</i>
</td></tr></table></td></tr></table>
The abstrac syntax for types is defined as follows:                   
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">           
<i>type</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b style="color:firebrick">integer</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b style="color:firebrick">boolean</b>
</td></tr></table></td></tr></table>
We can define a set of type inference rules for this language. These rules constitute the type system for the language.</span>
        <div class="inferences"><table class="inference"><tr><td class="title">[Formula-True]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&#8866; <b>true</b>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-False]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&#8866; <b>false</b>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-Not]</td><td><table><tr><td class="premises">&nbsp;&#8866; <i>e</i>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&#8866; <b>not</b> <i>e</i>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-And]</td><td><table><tr><td class="premises">&nbsp;&#8866; <i>e</i><sub>1</sub>: <b style="color:firebrick">boolean</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &#8866; <i>e</i><sub>2</sub>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&#8866; <i>e</i><sub>1</sub> <b>and</b> <i>e</i><sub>2</sub>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-Or]</td><td><table><tr><td class="premises">&nbsp;&#8866; <i>e</i><sub>1</sub>: <b style="color:firebrick">boolean</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;  &#8866; <i>e</i><sub>2</sub>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&#8866; <i>e</i><sub>1</sub> <b>or</b> <i>e</i><sub>2</sub>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Term-Number]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&#8866; <i>number</i>: <b style="color:firebrick">integer</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Term-Plus]</td><td><table><tr><td class="premises">&nbsp;&#8866; <i>e</i><sub>1</sub>: <b style="color:firebrick">integer</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &#8866; <i>e</i><sub>2</sub>: <b style="color:firebrick">integer</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&#8866; <i>e</i><sub>1</sub> <b>+</b> <i>e</i><sub>2</sub>: <b style="color:firebrick">integer</b>&nbsp;</td></tr></table></td></tr></table></div>
        
<span class="text">We can convert the above inference rules into a type checking algorithm; the process is almost identical to the process used for converting an operational semantics into an interpreter implementation.</span>
        
<div class="code"><div class="source"><pre><code class="py">
def typeCheck(e):
    if type(e) == Leaf:
        if e == 'True' or e == 'False':
            return 'boolean'
    if type(e) == Node:
        for label in e:
            if label == 'Number':
                 return 'integer'
            if label == 'Not':
                  [e1] = e[label]
                  t1 = typeCheck(e1)
                  if t1 != 'boolean':
                     print("not must be applied to a boolean")
                     return None
                  return 'boolean'
            
            # ...
            
            if label == 'Plus':
                [e1,e2] = e[label]
                t1 = typeCheck(e1)
                t2 = typeCheck(e2)
                if t1 != 'integer' or t2 != 'integer':
                    print("+ requires integer arguments")
                    return None
                return 'integer'
        </code></pre></div></div>
      </div></div></div>
<a name="f7d615702fe211e38cf6ce3f5508acd9"></a><div class="linked block"><div class="link-block">[<a href="#f7d615702fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Suppose we are working with a programming language with the following abstract syntax.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>variable</i> <b>:=</b> <i>expression</i> <b>;</b> <i>program</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>expression</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>variable</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>constant</i>  </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>not</b> <i>expression</i>  </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>expression</i> <b>and</b> <i>expression</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>expression</i> <b>or</b> <i>expression</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>expression</i> <b>*</b> <i>expression</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>expression</i> <b>+</b> <i>expression</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>constant</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> | <b>false</b> | <i>number</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>number</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid integer</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>variable</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid variable</i></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>type</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b style="color:firebrick">integer</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b style="color:firebrick">boolean</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b style="color:firebrick">void</b>
</td></tr></table></td></tr></table>
We can define a set of type inference rules for this language. These rules constitute the type system for the language.</span>
        <div class="inferences"><table class="inference"><tr><td class="title">[Statement-Assign]</td><td><table><tr><td class="premises">&nbsp;&Gamma; &#8846; {<i>x</i> &#x21A6; &tau;} &#8866; <i>p</i>: <b style="color:firebrick">void</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>e</i>: &tau;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>x</i> <b>:=</b> <i>e</i> <b>;</b> <i>p</i> : <b style="color:firebrick">void</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-End]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b style="color:gray;">end</b>: <b style="color:firebrick">void</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Variable]</td><td><table><tr><td class="premises">&nbsp;&Gamma;(<i>x</i>) = &tau;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>x</i>: &tau;&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-True]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b>true</b>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-False]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b>false</b>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-Not]</td><td><table><tr><td class="premises">&nbsp;&Gamma; &#8866; <i>e</i>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b>not</b> <i>e</i>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-And]</td><td><table><tr><td class="premises">&nbsp;&Gamma; &#8866; <i>e</i><sub>1</sub>: <b style="color:firebrick">boolean</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>e</i><sub>2</sub>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>e</i><sub>1</sub> <b>and</b> <i>e</i><sub>2</sub>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-Or]</td><td><table><tr><td class="premises">&nbsp;&Gamma; &#8866; <i>e</i><sub>1</sub>: <b style="color:firebrick">boolean</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>e</i><sub>2</sub>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>e</i><sub>1</sub> <b>or</b> <i>e</i><sub>2</sub>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Term-Number]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>number</i>: <b style="color:firebrick">integer</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Term-Plus]</td><td><table><tr><td class="premises">&nbsp;&Gamma; &#8866; <i>e</i><sub>1</sub>: <b style="color:firebrick">integer</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>e</i><sub>2</sub>: <b style="color:firebrick">integer</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>e</i><sub>1</sub> <b>+</b> <i>e</i><sub>2</sub>: <b style="color:firebrick">integer</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Term-Mult]</td><td><table><tr><td class="premises">&nbsp;&Gamma; &#8866; <i>e</i><sub>1</sub>: <b style="color:firebrick">integer</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>e</i><sub>2</sub>: <b style="color:firebrick">integer</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>e</i><sub>1</sub> <b>*</b> <i>e</i><sub>2</sub>: <b style="color:firebrick">integer</b>&nbsp;</td></tr></table></td></tr></table></div>
      </div></div></div>
<a name="ffe2a6789eb84626aedbde121a1a9b7b"></a><div class="linked block"><div class="link-block">[<a href="#ffe2a6789eb84626aedbde121a1a9b7b">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Let's consider the difference between the operational semantics inference rule and the type checking rule for a <b>while</b> construct in a hypothetical programming language. Notice that the execution rule can result in an infinite recursion because a premise above the line contains an exact copy of the abstract syntax tree that we are trying to execute. Unlike the execution rule, the typing rule cannot result in an infinite recursion (it only requires a linear-time recursive examination of the abstract syntax tree).</span>
        <div class="inferences"><table class="inference"><tr><td class="title">[Statement-While-Eval-True]</td><td><table><tr><td class="premises">&nbsp;
               &Sigma;<sub>1</sub>, <i>p</i><sub>1</sub> &dArr; &Sigma;<sub>2</sub>, <i>o</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;<sub>2</sub>, <b>while</b> <i>e</i> <b>{</b> <i>p</i><sub>1</sub> <b>}</b> <i>p</i><sub>2</sub> &dArr; &Sigma;<sub>3</sub>, <i>o</i><sub>2</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;<sub>1</sub>, <i>e</i> &dArr; <b>true</b>
             &nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;<sub>1</sub>, <b>while</b> <i>e</i> <b>{</b> <i>p</i><sub>1</sub> <b>}</b> <i>p</i><sub>2</sub> &dArr; &Sigma;<sub>3</sub>, <i>o</i><sub>1</sub>;<i>o</i><sub>2</sub>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-While-Type]</td><td><table><tr><td class="premises">&nbsp;
               &Gamma; &#8866; <i>e</i> : <b style="color:firebrick">boolean</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>p</i><sub>1</sub> : <b style="color:firebrick">void</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>p</i><sub>2</sub> : <b style="color:firebrick">void</b>
             &nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b>while</b> <i>e</i> <b>{</b> <i>p</i><sub>1</sub> <b>}</b> <i>p</i><sub>2</sub> : <b style="color:firebrick">void</b>&nbsp;</td></tr></table></td></tr></table></div>
      </div></div></div>
<a name="f7d60f9e2fe211e38cf6ce3f5508acd9"></a><div class="linked block"><div class="link-block">[<a href="#f7d60f9e2fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Suppose we are working with a programming language that supports the definition of functions that take a single integer argument.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">program <i>p</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>function</b> <i>f</i> <b>(</b> <b>int</b> <i>x</i> <b>)</b> <b>{</b> <b>return</b> <i>e</i> <b>;</b> <b>}</b> <i>p</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>x</i> <b>:=</b> <i>e</i> <b>;</b> <i>p</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
expression <i>e</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>x</i> | <i>n</i> | <i>e</i> <b>+</b> <i>e</i> | <i>f</i> <b>(</b> <i>e</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
number <i>n</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid integer</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
variable <i>f</i>, <i>x</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid variable</i></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
type &tau; <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b style="color:firebrick">int</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b style="color:firebrick">int <span style="font-size:12px;">&#8594;</span> int</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b style="color:firebrick">void</b>
</td></tr></table></td></tr></table>
We can define a set of type inference rules for this language. These rules constitute the type system for the language.</span>
        <div class="inferences"><table class="inference"><tr><td class="title">[Statement-Assign]</td><td><table><tr><td class="premises">&nbsp;
            &Gamma; &#8846; {<i>x</i> &#x21A6; <b style="color:firebrick">int</b>} &#8866; <i>p</i>: <b style="color:firebrick">void</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>e</i>: <b style="color:firebrick">int</b>
            &nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>x</i> <b>:=</b> <i>e</i> <b>;</b> <i>p</i> : <b style="color:firebrick">void</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-Function]</td><td><table><tr><td class="premises">&nbsp;
            &Gamma; &#8846; {<i>f</i> &#x21A6; <b style="color:firebrick">int <span style="font-size:12px;">&#8594;</span> int</b>} &#8866; <i>p</i>: <b style="color:firebrick">void</b> 
            &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8846; {<i>x</i> &#x21A6; <b style="color:firebrick">int</b>} &#8866; <i>e</i>: <b style="color:firebrick">int</b>
            &nbsp;</td></tr><tr><td class="conclusion">&nbsp;
            &Gamma; &#8866; <b>function</b> <i>f</i> <b>(</b> <b style="color:firebrick">int</b> <i>x</i> <b>)</b> <b>{</b> <b>return</b> <i>e</i> <b>;</b> <b>}</b> <i>p</i> : <b style="color:firebrick">void</b>
            &nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-End]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b style="color:gray;">end</b>: <b style="color:firebrick">void</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Term-Variable]</td><td><table><tr><td class="premises">&nbsp;&Gamma;(<i>x</i>) = <b style="color:firebrick">int</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>x</i>: <b style="color:firebrick">int</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Term-Number]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>n</i>: <b style="color:firebrick">int</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Term-Plus]</td><td><table><tr><td class="premises">&nbsp;&Gamma; &#8866; <i>e</i><sub>1</sub>: <b style="color:firebrick">int</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>e</i><sub>2</sub>: <b style="color:firebrick">int</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>e</i><sub>1</sub> <b>+</b> <i>e</i><sub>2</sub>: <b style="color:firebrick">int</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Term-Apply]</td><td><table><tr><td class="premises">&nbsp;&Gamma;(<i>f</i>) = <b style="color:firebrick">int <span style="font-size:12px;">&#8594;</span> int</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>e</i>: <b style="color:firebrick">int</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>f</i> <b>(</b> <i>e</i> <b>)</b>: <b style="color:firebrick">int</b>&nbsp;</td></tr></table></td></tr></table></div>
        
<span class="text">Before implementing a type checking algorithm, suppose we want to implement an interpreter for this language. Below is an example of how it might be implemented.</span>
        
<div class="code"><div class="source"><pre><code class="py">
def evaluate(env, e):
   if type(e) == Node:
        for label in e:
            children = e[label]
            if label == 'Number':
                n = children[0]
                return n
            elif label == 'Plus':
                [e1,e2] = children
                return evaluate(env, e1) + evaluate(env, e2)
            elif label == 'Variable':
                x = children[0]
                value = env[x]
                return value
            elif label == 'Apply':
                 [f, eArg] = children
                 f = f['Variable'][0] # Unpack.
                 x = env[f]['Function'][2]['Variable'][0]
                 eBody = env[f]['Function'][3] # Body.
                 vArg = evaluate(env, eArg)
                 envF = env.copy()
                 envF[x] = vArg
                 vResult = evaluate(envF, eBody)
                 return vResult
        
def execute(env, s):
    if type(s) == Leaf:
        if s == 'End':
            return (env, [])
    elif type(s) == Node:
        for label in s:
            if label == 'Assign':
                [var, e, p] = s[label]
                x = var['Variable'][0]
                env[x] = evaluate(env, e)
                (env, o) = execute(env, p)
                return (env, o)
            if label == 'Function':
                [f, ty, x, e, p] = s[label]
                f = f['Variable'][0] # Unpack.
                env[f] = s
                (env, o) = execute(env, p)
                return (env, o)
        </code></pre></div></div> 
        
<span class="text">A type checking algorithm implementation is presented below.</span>
        
<div class="code"><div class="source"><pre><code class="py">
def tyExpr(env, e):
   if type(e) == Node:
        for label in e:
            children = e[label]
            if label == 'Number':
                return 'TyInt'
            elif label == 'Variable':
                x = children[0]
                return env[x]
            elif label == 'Apply':
                 [f, eArg] = children
                 f = f['Variable'][0] # Unpack.
                 tyArg = tyExpr(env, eArg)
                 tyFunArg = env[f]['TyArrow'][0]
                 if tyArg == tyFunArg:
                     return env[f]['TyArrow'][1]
        
def tyProg(env, s):
   if type(s) == Leaf:
        if s == 'End':
            return 'TyVoid'
   elif type(s) == Node:
        for label in s:
            if label == 'Assign':
                [x,e,p] = s[label]
                x = x['Variable'][0] # Unpack.
                tExpr = tyExpr(env, e)
                env[x] = tExpr
                tProg = tyProg(env, p)
                if tExpr == 'TyInt' and tProg == 'Void':
                    return 'TyVoid'
            if label == 'Function':
                [f, tyArg, x, e, p] = s[label]
                name = f['Variable'][0]
                x = x['Variable'][0]
                envF = env.copy()
                envF[x] = tyArg
                tBody = tyExpr(envF, e)
                if tBody == 'TyInt':
                    env[name] = {'TyArrow':[tyArg, tBody]}
                    tProg = tyProg(env, p)                  
                    return tProg
        </code></pre></div></div>
      </div></div></div>
<a name="f7d61e6c2fe211e38cf6ce3f5508acd9"></a><div class="linked block"><div class="link-block">[<a href="#f7d61e6c2fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Suppose we are working with a programming language that supports the definition of functions that take a single string argument. The type system of this language supports explicit tracking of the sizes of strings.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">program <i>p</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>function</b> <i>f</i> <b>(</b> <b style="color:firebrick">string[</b><i>k</i><b style="color:firebrick">]</b> <i>x</i> <b>)</b> <b>{</b> <b>return</b> <i>e</i> <b>;</b> <b>}</b> <i>p</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>x</i> <b>:=</b> <i>e</i> <b>;</b> <i>p</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
expression <i>e</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>x</i> | <i>s</i> | <i>e</i> <b>+</b> <i>e</i> | <i>f</i> <b>(</b> <i>e</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
string <i>s</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid string literal</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
variable <i>f</i>, <i>x</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid variable</i></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
type &tau; <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b style="color:firebrick">string[</b><i>k</i><b style="color:firebrick">]</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b style="color:firebrick">string[</b><i>k</i><b style="color:firebrick">] <span style="font-size:12px;">&#8594;</span> string</b><b style="color:firebrick">[</b><i>k</i><b style="color:firebrick">]</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b style="color:firebrick">void</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
type size <i>k</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid integer</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>k</i> <b>+</b> <i>k</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
</td></tr></table></td></tr></table>
We can define a set of type inference rules for this language. These rules constitute the type system for the language.</span>
        <div class="inferences"><table class="inference"><tr><td class="title">[Statement-Assign]</td><td><table><tr><td class="premises">&nbsp;
            &Gamma; &#8846; {<i>x</i> &#x21A6; <b style="color:firebrick">string[</b><i>k</i><b style="color:firebrick">]</b>} &#8866; <i>p</i>: <b style="color:firebrick">void</b> 
            &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>e</i>: <b style="color:firebrick">string[</b><i>k</i><b style="color:firebrick">]</b>
            &nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>x</i> <b>:=</b> <i>e</i> <b>;</b> <i>p</i> : <b style="color:firebrick">void</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-Function]</td><td><table><tr><td class="premises">&nbsp;
            &Gamma; &#8846; {<i>f</i> &#x21A6; <b style="color:firebrick">string[</b><i>k</i><sub>1</sub><b style="color:firebrick">]</b> <b><span style="font-size:12px;">&#8594;</span></b> <b style="color:firebrick">string[</b><i>k</i><sub>2</sub><b style="color:firebrick">]</b>} &#8866; <i>p</i>: <b style="color:firebrick">void</b> 
            &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8846; {<i>x</i> &#x21A6; <b style="color:firebrick">string[</b><i>k</i><sub>1</sub><b style="color:firebrick">]</b>} &#8866; <i>e</i>: <b style="color:firebrick">string[</b><i>k</i><sub>2</sub><b style="color:firebrick">]</b>
            &nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b>function</b> <i>f</i> <b>(</b> <b style="color:firebrick">string[</b><i>k</i><sub>1</sub><b style="color:firebrick">]</b> <i>x</i> <b>)</b> <b>{</b> <b>return</b> <i>e</i> <b>;</b> <b>}</b> <i>p</i> : <b style="color:firebrick">void</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-End]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b style="color:gray;">end</b>: <b style="color:firebrick">void</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Term-Variable]</td><td><table><tr><td class="premises">&nbsp;&Gamma;(<i>x</i>) = <b style="color:firebrick">string[</b><i>k</i><b style="color:firebrick">]</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>x</i>: <b style="color:firebrick">string[</b><i>k</i><b style="color:firebrick">]</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Term-String]</td><td><table><tr><td class="premises">&nbsp;|<i>s</i>| = <i>k</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>s</i>: <b style="color:firebrick">string[</b><i>k</i><b style="color:firebrick">]</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Term-Concat]</td><td><table><tr><td class="premises">&nbsp;
            &Gamma; &#8866; <i>e</i><sub>1</sub>: <b style="color:firebrick">string[</b><i>k</i><sub>1</sub><b style="color:firebrick">]</b> 
            &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>e</i><sub>2</sub>: <b style="color:firebrick">string[</b><i>k</i><sub>2</sub><b style="color:firebrick">]</b>
            &nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>e</i><sub>1</sub> <b>+</b> <i>e</i><sub>2</sub>: <b style="color:firebrick">string[</b><i>k</i><sub>1</sub><b>+</b><i>k</i><sub>2</sub><b style="color:firebrick">]</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Term-Apply]</td><td><table><tr><td class="premises">&nbsp;
            &Gamma;(<i>f</i>) = <b style="color:firebrick">string[</b><i>k</i><sub>1</sub><b style="color:firebrick">]</b> <b><span style="font-size:12px;">&#8594;</span></b> <b style="color:firebrick">string[</b><i>k</i><sub>2</sub><b style="color:firebrick">]</b> 
            &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>e</i>: <b style="color:firebrick">string[</b><i>k</i><sub>1</sub><b style="color:firebrick">]</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;
            &Gamma; &#8866; <i>f</i> <b style="color:firebrick">(</b> <i>e</i> <b style="color:firebrick">)</b>: <b style="color:firebrick">string[</b><i>k</i><sub>2</sub><b style="color:firebrick">]</b>
            &nbsp;</td></tr></table></td></tr></table></div>
      </div></div></div></div>
  <a name="6.2"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#6.2">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">6.2.</span> Abstract interpretation</h3>
<span class="text top">An <i>abstract interpretation</i> algorithm is a specific kind of interpreter for a programming language: it must always terminate (and, typically, it must run quickly), and it typically provides information about the given program along some dimension of interest (i.e., not the value(s) it produces).</span>
<a name="f7d60ab22fe211e38cf6ce3f5508acd9"></a><div class="linked block"><div class="link-block">[<a href="#f7d60ab22fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Suppose we are working with a simple general-purpose programming language with the following abstract syntax.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">program <i>p</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>print</b> <i>e</i> <b>;</b> <i>p</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>for</b> <i>x</i> <b>to</b> <i>n</i> <b>{</b> <i>p</i> <b>}</b> <i>p</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>procedure</b> <i>x</i> <b>{</b> <i>p</i> <b>}</b> <i>p</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>call</b> <i>x</i> <b>;</b> <i>p</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
expression <i>e</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>n</i> | <i>e</i> <b>*</b> <i>e</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
number <i>n</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid integer</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
variable <i>x</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid variable</i></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
</td></tr></table></td></tr></table>
We want to define an abstract interpretation over the above language to a language that describes running times of programs. The language for running times has the following syntax:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">running time <i>t</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b style="color:firebrick;"><i>n</i></b>  | <b style="color:firebrick;"><i>t</i> <b>+</b> <i>t</i></b> | <b style="color:firebrick;"><i>t</i> <b>*</b> <i>t</i></b> | <b style="color:firebrick;"><b>(</b> <i>t</i> <b>)</b> </b> 
</td></tr></table></td></tr></table>
We can define the following abstract interpretation of the language:</span>
        <div class="inferences"><table class="inference"><tr><td class="title">[Expression-Number]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&#8866; <i>n</i> : <b style="color:firebrick;">1</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Expression-Mult]</td><td><table><tr><td class="premises">&nbsp;&#8866; <i>e</i><sub>1</sub>: <b style="color:firebrick;"><i>t</i><sub>1</sub></b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &#8866; <i>e</i><sub>1</sub>: <b style="color:firebrick;"><i>t</i><sub>2</sub></b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&#8866; <i>e</i><sub>1</sub> <b>*</b> <i>e</i><sub>2</sub>: <b style="color:firebrick;">1 + <i>t</i><sub>1</sub> + <i>t</i><sub>2</sub></b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-Print]</td><td><table><tr><td class="premises">&nbsp;&Gamma; &#8866; <i>p</i>: <b style="color:firebrick;"><i>t</i><sub>1</sub></b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &#8866; <i>e</i>: <b style="color:firebrick;"><i>t</i><sub>2</sub></b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b>print</b> <i>e</i> <b>;</b> <i>p</i> : <b style="color:firebrick;">1 + <i>t</i><sub>1</sub> + <i>t</i><sub>2</sub></b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-For]</td><td><table><tr><td class="premises">&nbsp;&Gamma; &#8866; <i>p</i><sub>1</sub>: <b style="color:firebrick;"><i>t</i><sub>1</sub></b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>p</i><sub>2</sub>: <b style="color:firebrick;"><i>t</i><sub>2</sub></b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b>for</b> <i>x</i> <b>to</b> <i>n</i> <b>{</b> <i>p</i><sub>1</sub> <b>}</b> <i>p</i><sub>2</sub> : <b style="color:firebrick;">(<i>n</i> * <i>t</i><sub>1</sub>) + <i>t</i><sub>2</sub></b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-Procedure]</td><td><table><tr><td class="premises">&nbsp;&Gamma; &#8866; <i>p</i><sub>1</sub>: <b style="color:firebrick;"><i>t</i><sub>1</sub></b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8846; {<i>x</i> &#x21A6; <b style="color:firebrick;"><i>t</i><sub>1</sub></b>} &#8866; <i>p</i><sub>2</sub>: <b style="color:firebrick;"><i>t</i><sub>2</sub></b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b>procedure</b> <b>{</b> <i>p</i><sub>1</sub> <b>}</b> <i>p</i><sub>2</sub> : <b style="color:firebrick;"><i>t</i><sub>2</sub></b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-Call]</td><td><table><tr><td class="premises">&nbsp;&Gamma;(<i>x</i>) = <b style="color:firebrick;"><i>t</i><sub>2</sub></b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>p</i>: <b style="color:firebrick;"><i>t</i><sub>1</sub></b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b>call</b> <i>x</i> <b>;</b> <i>p</i> : <b style="color:firebrick;"><i>t</i><sub>1</sub> + <i>t</i><sub>2</sub></b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-End]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b style="color:gray;">end</b> : <b style="color:firebrick;">0</b>&nbsp;</td></tr></table></td></tr></table></div>
        
<span class="text">We can implement the above inference rules as an abstract interpretation algorithm.</span>
        
<div class="code"><div class="source"><pre><code class="py">
def timeExpr(e):
    if type(e) == Node:
        for label in e:
            children = e[label]
            if label == 'Number':
                return 1
            elif label == 'Mult':
                [e1,e2] = children
                return 1 + timeExpr(e1) + timeExpr(e2)

def timeProg(env, s):
    if type(s) == Leaf:
        if s == 'End':
            return 0
    elif type(s) == Node:
        for label in s:
            if label == 'Print':
                [e,p] = s[label]
                return 1 + timeExpr(e) + timeProg(env, p)
            if label == 'For':
                [var, num, p1, p2] = s[label]
                n = num['Number'][0]
                return n * timeProg(env, p1) + timeProg(env, p2)

                # ...
        </code></pre></div></div>
      </div></div></div>
<a name="f7d60d822fe211e38cf6ce3f5508acd9"></a><div class="linked block"><div class="link-block">[<a href="#f7d60d822fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Suppose we are working with a simple programming language for reserving cloud computing resources with the following abstract syntax.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">program <i>p</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>reserve</b> <i>d</i> <b>;</b> <i>p</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
           <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>for</b> <i>x</i> <b>to</b> <i>n</i> <b>{</b> <i>p</i> <b>}</b> <i>p</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
           <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>procedure</b> <i>x</i> <b>{</b> <i>p</i> <b>}</b> <i>p</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
           <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>call</b> <i>x</i> <b>;</b> <i>p</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
           <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
duration <i>d</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>n</i> <b>minutes</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
            <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>n</i> <b>hours</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
            <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>n</i> <b>days</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
number <i>n</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid integer</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
fixed-point real number <i>r</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid real number</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
variable <i>x</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid variable</i></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
</td></tr></table></td></tr></table>
We want to define an abstract interpretation over the above language to a language that describes the monetary (i.e., dollar) cost of running a program. The language for costs has the following syntax:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">cost <i>c</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b style="color:firebrick;">$<i>r</i></b> | <b style="color:firebrick;"><i>c</i> <b>+</b> <i>c</i></b> | <b style="color:firebrick;"><i>n</i> <b>*</b> <i>c</i></b> | <b style="color:firebrick;"><b>(</b> <i>c</i> <b>)</b> </b> 
</td></tr></table></td></tr></table>
Suppose that a single <b>reserve</b> <i>d</i> <b>;</b> statement reserves a distinct computing resources for the duration specified, and that the cost of any resource is always $0.60 per hour. We can define the following abstract interpretation of the language:</span>
        <div class="inferences"><table class="inference"><tr><td class="title">[Duration-Minutes]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&#8866; <i>n</i> <b>minutes</b> : <b style="color:firebrick;"><i>n</i> &sdot; $0.01</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Duration-Hours]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&#8866; <i>n</i> <b>hours</b> : <b style="color:firebrick;"><i>n</i> &sdot; $0.60</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Duration-Days]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&#8866; <i>n</i> <b>days</b> : <b style="color:firebrick;"><i>n</i> &sdot; $14.40</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-Reserve]</td><td><table><tr><td class="premises">&nbsp;&#8866; <i>d</i>: <b style="color:firebrick;"><i>c</i><sub>1</sub></b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>p</i>: <b style="color:firebrick;"><i>c</i><sub>2</sub></b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b>reserve</b> <i>d</i> <b>;</b> <i>p</i> : <b style="color:firebrick;"><i>c</i><sub>1</sub> + <i>c</i><sub>2</sub></b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-For]</td><td><table><tr><td class="premises">&nbsp;&Gamma; &#8866; <i>p</i><sub>1</sub>: <b style="color:firebrick;"><i>c</i><sub>1</sub></b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>p</i><sub>2</sub>: <b style="color:firebrick;"><i>c</i><sub>2</sub></b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b>for</b> <i>x</i> <b>to</b> <i>n</i> <b>{</b> <i>p</i><sub>1</sub> <b>}</b> <i>p</i><sub>2</sub> : <b style="color:firebrick;">(<i>n</i> * <i>c</i><sub>1</sub>) + <i>c</i><sub>2</sub></b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-Procedure]</td><td><table><tr><td class="premises">&nbsp;&Gamma; &#8866; <i>p</i><sub>1</sub>: <b style="color:firebrick;"><i>c</i><sub>1</sub></b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8846; {<i>x</i> &#x21A6; <b style="color:firebrick;"><i>c</i><sub>1</sub></b>} &#8866; <i>p</i><sub>2</sub>: <b style="color:firebrick;"><i>c</i><sub>2</sub></b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b>procedure</b> <i>x</i> <b>{</b> <i>p</i><sub>1</sub> <b>}</b> <i>p</i><sub>2</sub> : <b style="color:firebrick;"><i>c</i><sub>2</sub></b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-Call]</td><td><table><tr><td class="premises">&nbsp;&Gamma;(<i>x</i>) = <b style="color:firebrick;"><i>c</i><sub>2</sub></b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>p</i>: <b style="color:firebrick;"><i>c</i><sub>1</sub></b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b>call</b> <i>x</i> <b>;</b> <i>p</i> : <b style="color:firebrick;"><i>c</i><sub>1</sub> + <i>c</i><sub>2</sub></b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-End]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b style="color:gray;">end</b> : <b style="color:firebrick;">$0</b>&nbsp;</td></tr></table></td></tr></table></div>  
        
<span class="text">We can implement the above inference rules as an abstract interpretation algorithm.</span>
        
<div class="code"><div class="source"><pre><code class="py">
def costDuration(e):
    if type(e) == Node:
        for label in e:
            children = e[label]
            if label == 'Minutes':
                [num] = children
                n = num['Number'][0]
                return n * 0.01
            if label == 'Hours':
                [num] = children
                n = num['Number'][0]
                return n * 0.60
            if label == 'Days':
                [num] = children
                n = num['Number'][0]
                return n * 14.40

def costProg(env, s):
    if type(s) == Leaf:
        if s == 'End':
            return 0
    elif type(s) == Node:
        for label in s:
            if label == 'Reserve':
                [d,p] = s[label]
                 return costDuration(d) + costProg(env, p)
            if label == 'For':
                [var, num, p1, p2] = s[label]
                n = num['Number'][0]
                return n * costProg(env, p1) + costProg(env, p2)

            # ...
        </code></pre></div></div>
      </div></div></div>
<a name="77cacf72f11440bcb8a949bb2a872cce"></a><div class="linked block"><div class="link-block">[<a href="#77cacf72f11440bcb8a949bb2a872cce">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Suppose we are working with a simple programming language in which the type system tracks whether values are secret or public.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">program <i>p</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>print</b> <i>e</i> <b>;</b> <i>p</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
            <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>secret</b> <i>x</i> <b>:=</b> <i>e</i> <b>;</b> <i>p</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
            <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>public</b> <i>x</i> <b>:=</b> <i>e</i> <b>;</b> <i>p</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
            <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
expression <i>e</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>n</i> | <i>x</i> | <i>e</i> <b>+</b> <i>e</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
number <i>n</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid integer</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
variable <i>x</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid variable</i></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
</td></tr></table></td></tr></table>
We want to define an abstract interpretation over the above language to a language that describes running times of programs. The language for running times has the following syntax:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">visibility <i>t</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b style="color:firebrick;">secret</b>  | <b style="color:firebrick;">public</b> | <b style="color:firebrick">void</b>
</td></tr></table></td></tr></table>
We can define the following abstract interpretation of the language:</span>
        <div class="inferences"><table class="inference"><tr><td class="title">[Statement-Assign-Secret]</td><td><table><tr><td class="premises">&nbsp;
            &Gamma; &#8846; {<i>x</i> &#x21A6; <b style="color:firebrick">secret</b>} &#8866; <i>p</i>: <b style="color:firebrick">void</b> 
            &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>e</i>: <b style="color:firebrick">secret</b>
            &nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b>secret</b> <i>x</i> <b>:=</b> <i>e</i> <b>;</b> <i>p</i> : <b style="color:firebrick">void</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-Assign-Public]</td><td><table><tr><td class="premises">&nbsp;
            &Gamma; &#8846; {<i>x</i> &#x21A6; <b style="color:firebrick">public</b>} &#8866; <i>p</i>: <b style="color:firebrick">void</b> 
            &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>e</i>: <b style="color:firebrick">public</b>
            &nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b>public</b> <i>x</i> <b>:=</b> <i>e</i> <b>;</b> <i>p</i> : <b style="color:firebrick">void</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-Print]</td><td><table><tr><td class="premises">&nbsp;
            &Gamma; &#8866; <i>p</i>: <b style="color:firebrick">void</b> 
            &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>e</i>: <b style="color:firebrick">public</b>
            &nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b>print</b> <i>e</i> <b>;</b> <i>p</i> : <b style="color:firebrick">void</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Expression-Variable]</td><td><table><tr><td class="premises">&nbsp;&Gamma;(<i>x</i>) = &tau;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>x</i>: &tau;&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Expression-Number-Secret]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>n</i>: <b style="color:firebrick">secret</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Expression-Number-Public]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>n</i>: <b style="color:firebrick">public</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Expression-Plus-Secret-Secret]</td><td><table><tr><td class="premises">&nbsp;&Gamma; &#8866; <i>e</i><sub>1</sub>: <b style="color:firebrick">secret</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>e</i><sub>2</sub>: <b style="color:firebrick">secret</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>e</i><sub>1</sub> <b>+</b> <i>e</i><sub>2</sub>: <b style="color:firebrick">secret</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Expression-Plus-Secret-Public]</td><td><table><tr><td class="premises">&nbsp;&Gamma; &#8866; <i>e</i><sub>1</sub>: <b style="color:firebrick">secret</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>e</i><sub>2</sub>: <b style="color:firebrick">public</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>e</i><sub>1</sub> <b>+</b> <i>e</i><sub>2</sub>: <b style="color:firebrick">secret</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Expression-Plus-Public-Secret]</td><td><table><tr><td class="premises">&nbsp;&Gamma; &#8866; <i>e</i><sub>1</sub>: <b style="color:firebrick">public</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>e</i><sub>2</sub>: <b style="color:firebrick">secret</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>e</i><sub>1</sub> <b>+</b> <i>e</i><sub>2</sub>: <b style="color:firebrick">secret</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Expression-Plus-Public-Public]</td><td><table><tr><td class="premises">&nbsp;&Gamma; &#8866; <i>e</i><sub>1</sub>: <b style="color:firebrick">public</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>e</i><sub>2</sub>: <b style="color:firebrick">public</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>e</i><sub>1</sub> <b>+</b> <i>e</i><sub>2</sub>: <b style="color:firebrick">public</b>&nbsp;</td></tr></table></td></tr></table></div>
      </div></div></div></div>
</div>
<a name="7"></a>
<div class="section"><hr /><h2 class="linked"><span class="link-title">[<a href="#7">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.</span> Declarative (and Functional) Programming Language Paradigms</h2>
<span class="text top">In this section we introduce the notion of a programming language paradigm, define several major programming language paradigms, and discuss which paradigms are supported by some widely used modern programming languages (in practice, many languages support more than one paradigm). We assume the reader is already at least somewhat familiar with the imperative and object-oriented programming paradigms; thus, we study in detail the <i>declarative</i> programming paradigm (including an important subset, <i>functional</i> programming).</span>
  <a name="7.1"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#7.1">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.1.</span> Programming language paradigms</h3>
<span class="text top">A programming language's <i>programming paradigm</i> is the collection of abstractions, tools, and techniques it makes available to a programmer. While <a href="http://en.wikipedia.org/wiki/Programming_paradigm">there is some disagreement</a> about what exactly constitutes a programming paradigm and how programming paradigms can be distinguished and categorized, there is wide agreement that at least a few distinct, widely-employed programming paradigms exist. We can enumerate these paradigms, and we can list the programming language features (i.e., abstractions) that can be used to identify and distinguish between them:</span><ul class="top"><li><b>imperative programming:</b><ul><li>mutable state and side effects:<ul><li>indexed memory regions;</li><li>named, mutable variables;</li><li>ability to interact with other "external" devices (video card, network, etc.);</li></ul></li><li>sequential execution of statements:<ul><li>one operation per time step (control flow);</li><li>branching and loops (direction of control flow);</li></ul></li><li><b><i>procedural programming:</i></b><ul><li>definition and invocation of named procedures;</li></ul></li><li>parallelism achieved with forking, threads, and message passing;</li></ul></li><li><b>object-oriented programming:</b><ul><li>data and methods organized into objects;</li><li>multiple instances of objects interacting via method calls:<ul><li>event handling;</li></ul></li><li>enforcement of encapsulation and modularity;</li></ul></li><li><b>declarative programming:</b><ul><li>static, immutable descriptions of data, models, or problems:<ul><li>user-defined data types:<ul><li>algebraic data types;</li></ul></li><li>type checking/inference.</li></ul></li><li>query sublanguage for examining/exploring static descriptions;</li><li><b><i>functional programming:</i></b><ul><li>referential transparency;</li><li>support for pattern matching/unification;</li><li>functions as values (<i><a href="http://en.wikipedia.org/wiki/First-class_function">first-class functions</a></i> and <i><a href="http://en.wikipedia.org/wiki/Higher-order_functions">higher-order functions</a></i>).</li></ul></li></ul></li></ul>
<span class="text top">Mathematically, it is possible to identify which paradigms are supported by a programming language by examining its operational semantics. We have already seen many examples of an operational semantics for an imperative language (such as <a href="#cbfa02d3624d42b08704d6a4c4fb9e03">this one</a> and <a href="#c09ab939e50b40428d392867c00b4710">this one</a>).
<br/><br/>
As a result of both historical trends and of practical necessity, most widely-used programming languages support multiple programming paradigms:
<br/><br/>
<table class="fig_table" style="font-size:10px; font-family:Arial,sans-serif;">
 <tr>
  <td></td>
  <td><b>imperative</b></td>
  <td><b>procedural</b></td>
  <td><b>object-<br/>oriented</b></td>
  <td><b>declarative</b></td>
  <td><b>functional</b></td>
  <td style="padding:0px;"></td>
  <td><b>static type<br/>checking</b></td>
  <td><b>garbage<br/>collection</b></td>
  <td><b>side<br/>effects</b></td>
 </tr>
 <tr> 
  <td><b>machine<br/>languages</b></td>
  <td style="background-color:lightyellow;">some support<br/>(indexed<br/>memory,<br/>branching)</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="padding:0px;"></td>
  <td>none</td>
  <td>no</td>
  <td>yes</td>
 </tr>
 <tr> 
  <td><b>FORTRAN<br/>(initial<br/>release)</b></td>
  <td style="background-color:palegreen; border:3px dashed green;">full support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="padding:0px;"></td>
  <td>very<br/>limited</td>
  <td>no</td>
  <td>yes</td>
 </tr>
 <tr> 
  <td><b>C</b></td>
  <td style="background-color:palegreen; border:3px dashed green;">full support</td>
  <td style="background-color:palegreen; border:3px dashed green;">full support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:lightyellow;">some support<br/>(function pointers)</td>
  <td style="padding:0px;"></td>
  <td>very<br/>limited</td>
  <td>no</td>
  <td>yes</td>
 </tr>
 <tr> 
  <td><b>C++</b></td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen; border:3px dashed green;">full support</td>
  <td style="background-color:lightyellow;">class declarations,<br/>some type checking</td>
  <td style="background-color:lightyellow;">function pointers<br/>and some extensions<br/>(e.g., <a href="http://en.wikipedia.org/wiki/Standard_Template_Library">STL</a>)</td>
  <td style="padding:0px;"></td>
  <td>limited</td>
  <td>no</td>
  <td>yes</td>
 </tr>
 <tr> 
  <td><b>Java</b></td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen; border:3px dashed green;">full support</td>
  <td style="background-color:lightyellow;">type system,<br/>class declarations,<br/>abstract classes,<br/>interfaces,<br/>type checking,<br/>and type inference</td>
  <td style="background-color:lightyellow;">generics, interfaces,<br/>objects as wrappers,<br/> anonymous classes</td>
  <td style="padding:0px;"></td>
  <td style="border:3px dashed green;">extensive</td>
  <td style="border:3px dashed green;">yes</td>
  <td>yes</td>
 </tr>
 <tr> 
  <td><b>PHP</b></td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:lightyellow;">some support</td>
  <td style="padding:0px;"></td>
  <td>none</td>
  <td>yes<br/>(&ge; 5.3)</td>
  <td>yes</td>
 </tr>
 <tr> 
  <td><b>Python</b></td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="padding:0px;"></td>
  <td>none</td>
  <td>yes</td>
  <td>yes</td>
 </tr>
 <tr> 
  <td><b>JavaScript</b></td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="padding:0px;"></td>
  <td>none</td>
  <td>yes</td>
  <td>yes</td>
 </tr>
 <tr> 
  <td><b>Haskell</b></td>
  <td style="background-color:lightcyan;">meta-support<br/>(monads)</td>
  <td style="background-color:lightcyan;">meta-support<br/>(functions)</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen; border:3px dashed green;">full support</td>
  <td style="padding:0px;"></td>
  <td style="border:3px dashed green;">extensive</td>
  <td>yes</td>
  <td>some<br/>(IO<br/>monads)</td>
 </tr>
 <tr> 
  <td><b>SQL</b></td>
  <td style="background-color:lightyellow;">some support<br/>(insertion/<br/>deletion;<br/>sequences of<br/>statements in<br/>versions<br/>like MS-SQL)</td>
  <td style="background-color:lightyellow;">some support<br/>(procedures in<br/>versions<br/>like MS-SQL)</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:palegreen; border:3px dashed green;">full support<br/>(definition of<br/>schemas and<br/>tables; ability<br/>to evaluate<br/>queries over<br/>tables)</td>
  <td style="background-color:lightyellow;">some support<br/>(custom map and<br/>aggregation<br/>procedures in<br/>MS-SQL)</td>
  <td style="padding:0px;"></td>
  <td>some</td>
  <td>yes</td>
  <td>some</td>
 </tr>
 <tr> 
  <td><b>Amazon<br/>Web<br/>Services<br/>APIs</b></td>
  <td style="background-color:lightyellow;">some support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:lightyellow;">some support</td>
  <td style="background-color:lightyellow;">some support</td>
  <td style="padding:0px;"></td>
  <td>none</td>
  <td>n/a</td>
  <td>yes</td>
 </tr>
</table>
<br/>
While most languagues support many paradigms in practice, there is often a historically predominant paradigm that distinguished that programming language at the time it was introduced, that is supported natively by the programming language (i.e., without special extensions, libraries, or idioms), and that is employed by the communities of programmers who use that language. In the above, the paradigm most closely identified with each language is indicated with a dark green outline.
<br/><br/>
A note about the above chart: when it comes to <i>domain-specific</i> languages that have a very narrow purpose (such as the Amazon Web Services API) and are not meant to be general-purpose programming languages, support of a paradigm does not imply that the language supports that paradigm in general; instead, it means the language supports that paradigm insofar as it applies to that particular application domain.</span></div>
  <a name="7.2"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#7.2">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.2.</span> Substitution and unification</h3>
<span class="text top">In this course, we will focus on the declarative (and functional) programming language Haskell. The Haskell syntax and operational semantics natively support <i>unification</i> in multiple ways (specifically, <i>pattern matching</i> within expressions and <i>polymorphism</i> within the type system). Unification is a general concept that is applied in some form in all areas of mathematics and computer science. In this subsection, we will define unification.</span>
<a name="f7d600442fe211e38cf6ce3f5508acd9"></a><div class="linked block"><div class="link-block">[<a href="#f7d600442fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
Given a set of variables <i>X</i> and an abstract syntax <i>A</i> (i.e., a set of abstract syntax trees), a <i>substitution</i> &sigma; is a mapping from variables names in <i>X</i> to abstract syntax trees in <i>A</i>. Given an abstract syntax tree <i>a</i> <span style="font-size:12px;">&#8712;</span> <i>A</i>, we denote the result of substituting all the variables in <i>a</i> according to &sigma; using the notation &sigma;(<i>a</i>).
      </div></div></div>
<span class="text top">You'll notice that we use the same mathematical object to represent both <a href="#e1a5053a93d54ad4b02da10e4981b810">environments</a> (a.k.a., contexts) and substitutions. Thus, we will use the same notation for representing manipulations involving substitutions.
<ul>
  <li>In this course, we will usually denote a substitution using the symbol &sigma;.</li>
  <li>Given a variable name <i>x</i> <span style="font-size:12px;">&#8712;</span> <i>X</i>, we denote by &sigma;(<i>x</i>) the abstract syntax tree that the environment &sigma; assigns to <i>x</i>.</li>
  <li>An empty substitution (one that does not map any variable names to any abstract syntax trees) is denoted using &sigma;<sub>0</sub>.</li>
  <li>We use the notation dom(&sigma;) to represent the set of variables that &sigma; maps to abstract syntax trees.</li>
  <li>Given two substitutions &sigma;<sub>1</sub> and &sigma;<sub>2</sub> such that dom(&sigma;<sub>1</sub>) &cap; dom(&sigma;<sub>2</sub>) = &empty; (i.e., the two substitutions do not overlap or conflict on any variables), we denote by &sigma;<sub>1</sub> &#8846; &sigma;<sub>2</sub> the substitution that can be obtained by combining the two individual substitutions. Thus, dom(&sigma;<sub>1</sub> &#8846; &sigma;<sub>2</sub>) = dom(&sigma;<sub>1</sub>) &cup; dom(&sigma;<sub>2</sub>).</li>
</ul></span>
<a name="f7d622362fe211e38cf6ce3f5508acd9"></a><div class="linked block"><div class="link-block">[<a href="#f7d622362fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
Suppose we have the following abstract syntax (here, <b>node</b> is an infix operator for building tree nodes):
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">tree <i>t</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>leaf</b> | <i>x</i> | <i>t</i> <b>node</b> <i>t</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
variable <i>x</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid variable</i>
</td></tr></table></td></tr></table>
Suppose we are given the following substitution, which maps the variable <i>u</i> to the tree <b>leaf</b> and the variable <i>v</i> to the tree <b>leaf</b> <b>node</b> <b>leaf</b>:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">&sigma; <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { <i>u</i> &#x21A6; <b>leaf</b>, <i>v</i> &#x21A6; <b>leaf</b> <b>node</b> <b>leaf</b> }
</td></tr></table></td></tr></table>
Applying the above substitution to a tree that does not contain any variable nodes <i>u</i> or <i>v</i> has no effect:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">&sigma;(<b>leaf</b>) <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>leaf</b>
</td></tr></table></td></tr></table>
Applying the substitution to a tree containing the variables <i>u</i> and/or <i>v</i> would result in those variables being replaced by the corresponding tree inside &sigma; (we add parentheses to the result for legibility):
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">&sigma;(<i>u</i> <b>node</b> <i>v</i>) <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> (<b>leaf</b>) <b>node</b> (<b>leaf</b> <b>node</b> <b>leaf</b>)
</td></tr></table></td></tr></table>
      </div></div></div>
<a name="f7d624202fe211e38cf6ce3f5508acd9"></a><div class="linked block"><div class="link-block">[<a href="#f7d624202fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
Given an abstract syntax <i>A</i> and two abstract syntax trees <i>a</i>, <i>b</i> <span style="font-size:12px;">&#8712;</span> <i>A</i>, we say that a substitution &sigma; <i>unifies</i> <i>a</i> and <i>b</i> if the following equation holds:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">  &sigma;(<i>a</i>) <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> &sigma;(<i>b</i>)
</td></tr></table></td></tr></table>
That is, applying the substitution to both trees produces exactly the same tree. The process of calculating the <i>smallest</i> &sigma; that guarantees the above equality is called <i>unification</i>.
      </div></div></div>
<span class="text top">For those familiar with the concept of a <a href="http://en.wikipedia.org/wiki/Magma_(algebra)">magma</a>, unification corresponds to the process of solving equations on magmas (or, more generally, any algebraic structure without any reduction or cancellation laws).</span>
<a name="8dac853e5f3f4f7f88f351fe4e6673aa"></a><div class="linked block"><div class="link-block">[<a href="#8dac853e5f3f4f7f88f351fe4e6673aa">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="fact true_required"><span class="block_label">Fact:</span> 
Suppose we are given an abstract syntax <i>A</i> and two abstract syntax trees <i>a</i>, <i>b</i> <span style="font-size:12px;">&#8712;</span> <i>A</i> that contain no variables. If <i>a</i> = <i>b</i>, then it is true that for all &sigma; (including &sigma;<sub>0</sub>):
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">  &sigma;(<i>a</i>) <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> &sigma;(<i>b</i>)
</td></tr></table></td></tr></table>
If <i>a</i> &ne; <i>b</i>, then it is true that for all &sigma;:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">  &sigma;(<i>a</i>) <td></tr></table></td><td style="text-align:center;"> &ne; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> &sigma;(<i>b</i>)
</td></tr></table></td></tr></table>
      </div></div></div>
<a name="3178040e0e304dea97da80368c7741b5"></a><div class="linked block"><div class="link-block">[<a href="#3178040e0e304dea97da80368c7741b5">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
Suppose we have the following abstract syntax:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>m</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>object</b> | <i>x</i> | <i>m</i> <b>&oplus;</b> <i>m</i> | <i>m</i> <b>&otimes;</b> <i>m</i> | <b>(</b> <i>m</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
variable <i>x</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid variable</i>
</td></tr></table></td></tr></table>
Unify the following two abstract syntax trees, if possible (i.e., solve the following equation):
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">  <b>(</b><i>z</i><b> &otimes; object) &oplus;</b> <i>x</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>(object &otimes; </b><i>y</i><b>) &oplus; (object &otimes; object)</b>
</td></tr></table></td></tr></table>
We can proceed by breaking the problem down. Since the root nodes of both abstract syntax trees are &oplus;, we can turn the above into two equations:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">  <i>z</i><b> &otimes; object</b> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>object &otimes; </b><i>y</i>  </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
  <i>x</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>object &otimes; object</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
</td></tr></table></td></tr></table>
The first equation can be broken down further:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">  <i>z</i><td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>object</b>  </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
  <b>object</b> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>y</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
  <i>x</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>object &otimes; object</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
</td></tr></table></td></tr></table>
At this point, we can build up the substitution using the above information:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">   &sigma; <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { <i>x</i> &#x21A6; <b>object &otimes; object</b>, <i>y</i> &#x21A6; <b>object</b>, <i>z</i> &#x21A6; <b>object</b> } </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
</td></tr></table></td></tr></table>
Thus, &sigma; as defined above unifies the two sides of the equation; the equation has a solution.
      </div></div></div>
<span class="text top">The equality algorithm on abstract syntax trees is a degenerate version of a unification algorithm in which substitutions must always remain empty. This algorithm is implemented natively within Python (we have been using it every time we checked whether two trees represented as nested dictionaries are equivalent using the <code>==</code> operator), and Haskell supports the automatic derivation of this algorithm for any data type (using the <code>deriving Eq</code> directive).</span>
<a name="788d70ecb3ab4acaa98a9355657fca3d"></a><div class="linked block"><div class="link-block">[<a href="#788d70ecb3ab4acaa98a9355657fca3d">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="algorithm true_required"><span class="block_label">Algorithm (equality):</span> 
        
<span class="text">The following algorithm can determine whether two trees are equivalent. 
<ol style="list-style-type:none;">
 <li><b>equal(<b><i>a</i></b>, <b><i>b</i></b>):</b> two abstract syntax trees <i>a</i> and <i>b</i></li>
 <li>
   <ol style="list-style-type:none; margin-left:-20px;">
     <li><b>if</b> both <i>a</i> <b>and</b> <i>b</i> are leaf nodes and are equivalent
       <ol style="list-style-type:none; margin-left:-20px;">
         <li><b>return</b> <b>true</b></li>
       </ol>
     </li>
     <li><b>if</b> both <i>a</i> and <i>b</i> have the same label <b>and</b> the same number of children
       <ol style="list-style-type:none; margin-left:-20px;">
         <li>in order from left to right, check each pair of corresponding children of <i>a</i> and <i>b</i> for equality</li>
         <li><b>return</b> <b>true</b> if all the subtrees are equivalent</li>
         <li><b>return</b> <b>false</b> otherwise</li>
       </ol>
     </li>
   </ol>
 </li>
</ol></span>
      </div></div></div>
<a name="95e800c8e74e4991a2ddb48668b544e0"></a><div class="linked block"><div class="link-block">[<a href="#95e800c8e74e4991a2ddb48668b544e0">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="algorithm true_required"><span class="block_label">Algorithm (pattern matching unification):</span> 
        
<span class="text">Whether unification can be computed efficiently, or at all, depends on the subset of the abstract syntax from which inputs are drawn (i.e., it depends on what restrictions are placed on the abstract syntax trees that may need to be unified). The following algorithm, which we will call <i>pattern matching</i> unification, is guaranteed to terminate quickly (i.e., polynomial time) as long as at least one side of the equation contains no variables. It is guaranteed to quickly find a solution if it exists, as long as all variables occur exactly once.
<ol style="list-style-type:none;">
 <li><b>unify(<b><i>a</i></b>, <b><i>b</i></b>):</b> two abstract syntax trees <i>a</i> and <i>b</i></li>
 <li>
   <ol style="list-style-type:none; margin-left:-20px;">
     <li><b>if</b> both <i>a</i> <b>and</b> <i>b</i> are leaf nodes and are equivalent
       <ol style="list-style-type:none; margin-left:-20px;">
         <li><b>return</b> the empty substitution &sigma;<sub>0</sub></li>
       </ol>
     </li>
     <li><b>if</b> <i>a</i> is a variable node representing a variable <i>x</i>
       <ol style="list-style-type:none; margin-left:-20px;">
         <li><b>return</b> the substitution {<i>x</i> &#x21A6; <i>b</i>}</li>
       </ol>
     </li>
     <li><b>if</b> <i>b</i> is a variable node representing a variable <i>x</i>
       <ol style="list-style-type:none; margin-left:-20px;">
         <li><b>return</b> the substitution {<i>x</i> &#x21A6; <i>a</i>}</li>
       </ol>
     </li>
     <li><b>if</b> both <i>a</i> and <i>b</i> have the same label <b>and</b> the same number of children
       <ol style="list-style-type:none; margin-left:-20px;">
         <li>in order from left to right, unify each pair of corresponding children of <i>a</i> and <i>b</i></li>
         <li>as long as they do not overlap on any variables, combine the substitutions obtained above</li>
         <li><b>return</b> the combined substitution</li>
       </ol>
     </li>
   </ol>
 </li>
</ol></span>
      </div></div></div>
<a name="8b5c8d33b508470088319ea3bb8db343"></a><div class="linked block"><div class="link-block">[<a href="#8b5c8d33b508470088319ea3bb8db343">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">The Python operational semantics (and interpreter) employ a pattern matching unification algorithm in some cases. For example, it is possible to assign to arbitrarily deep tree of nested tuples.</span>
        
<div class="code"><div class="source"><pre><code class="py">
>>> (a,(b,c),(d,(e,f),g)) = (1,(2,3),(4,(5,6),7))
>>> (a,b,c,d,e,f,g)
(1,2,3,4,5,6,7)
        </code></pre></div></div>
      </div></div></div></div>
  <a name="7.3"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#7.3">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.3.</span> Declarative programming languages</h3>
<span class="text top">Any programming language that allows users to provide a static, immutable description of data, a model, or a problem supports the declarative programming paradigm to at least some degree. For example, languages that allow users to specify types and relationships between those types (e.g., Haskell types, Java classes, and so on) support a declarative programming paradigm for types.
<br/><br/>
In this course we will focus on declarative languages that allow users to specify data types, relationships between data types, and pure mathematical functions over those data types. In particular, we will look at the Haskell programming language.
<br/><br/>
In order to define the operational semantics for a declarative language, we must slightly modify the way in which we define an operational semantics by extending the premises and conclusions with an additional parameter representing the data, model, or problem description. We will adopt the convention of calling this parameter <i>M</i>. Thus, an intepreter for a declarative programming language first <i>builds</i> data, a model, or a problem description by parsing and collecting into a single structure all the declarations in a program. It then allows the user to <i>query</i> that structure.
<br/><br/>
In the Haskell programming language, a <i>module</i> is a collection of declarations (that can occur in any order) of variables, functions, and types. For example:</span>
<div class="code top"><div class="source"><pre><code class="haskell">
module Example where

c = 5;

g (0) = 0;
g (x) = f(x) + f(x);

f (x) = 2 * x + 1;
      </code></pre></div></div>
<span class="text top">A Haskell interpreter first assembles the module without performing any evaluation, and then allows users to make queries about that module. Queries take the form of expressions, and the response to a query is the evaluation of that expression with respect to the entire module (i.e., all the definitions in the module).</span>
<div class="code top"><div class="source"><pre><code class="haskell">
*> c + c
10
*> f(4)
9
      </code></pre></div></div>
<span class="text top">Haskell natively supports lists and tuples, and the evaluation algorithm employs the <a href="#95e800c8e74e4991a2ddb48668b544e0">pattern matching unification</a> algorithm. Suppose we have the following module:</span>
<div class="code top"><div class="source"><pre><code class="haskell">
module AnotherExample where

f (-1) = 1;
f (0) = 0;
f (1) = -1;

(a,(b,(c,d),e)) = (1,(2,(3,4),5));

g([x,y,z]) = [z,y,x];
      </code></pre></div></div>
<span class="text top">We can query the above module as follows:</span>
<div class="code top"><div class="source"><pre><code class="haskell">
*> f(-1)
1
*> d
4
*> g([1,2,3])
[3,2,1]
      </code></pre></div></div></div>
  <a name="7.4"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#7.4">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.4.</span> Algebraic data types</h3>
<span class="text top">Some declarative languages natively support abstract mathematical, logical, and algebraic structures such as BNF notation, abstract syntaxes, logical formulas and predicates, and inference rules. Haskell natively supports user-defined <i>algebraic data types</i>. An algebraic data type is effectively a user-defined abstract syntax; the Haskell syntax for defining algebraic data types corresponds closely to BNF notation. In the module below, we define an algebraic data type for representing binary trees.</span>
<div class="code top"><div class="source"><pre><code class="haskell">
module Tree where

data Tree = Leaf | Node Tree Tree;
      </code></pre></div></div>
<span class="text top">Most Haskell interpreters and compilers support infix notation in data type definitions as well.</span>
<div class="code top"><div class="source"><pre><code class="haskell">
data Tree = Leaf | Tree `Node` Tree;
      </code></pre></div></div>
<span class="text top">Once the above module is parsed and built, the user is allowed to construct instances of the <code>Tree</code> algebraic data type. However, in order to actually display instances of the data type, it is necessary to ask the Haskell interpreter to derive a definition of a <code>show</code> function automatically from the definition of the algebraic data type (something that is done implicitly in, for example, Python). Haskell requires that this be requested explicitly because it also allows users to define their own variants of such functions.</span>
<div class="code top"><div class="source"><pre><code class="haskell">
module Tree where

data Tree = 
    Leaf 
  | Node Tree Tree 
  deriving Show;
      </code></pre></div></div>
<span class="text top">We can now try building trees using this algebraic data type.</span>
<div class="code top"><div class="source"><pre><code class="haskell">
*> Leaf           -- We represented this using "Leaf" in Python.
Leaf

*> Node Leaf Leaf -- We represented this using {"Node":["Leaf", "Leaf"]} in Python.
Node Leaf Leaf

*> Leaf `Node` Leaf
Node Leaf Leaf

*> Leaf `Node` ((Leaf `Node` Leaf) `Node` (Leaf `Node` Leaf))
Node Leaf (Node (Node Leaf Leaf) (Node Leaf Leaf))
      </code></pre></div></div>
<span class="text top">Haskell's native support for pattern matching unification makes it possible to write concise definitions for functions that are defined over trees.</span>
<div class="code top"><div class="source"><pre><code class="haskell">
-- Count the number of nodes in a tree that have exactly one non-leaf child.
-- The spaces between the ( ... ) are just for legibility.
nodesWithOneLeaf (Node Leaf Leaf) = 0;
nodesWithOneLeaf (Node Leaf t   ) = 1 + nodesWithOneLeaf(t);
nodesWithOneLeaf (Node t    Leaf) = 1 + nodesWithOneLeaf(t);
nodesWithOneLeaf (Node t1   t2  ) = nodesWithOneLeaf(t1) + nodesWithOneLeaf(t2);
nodesWithOneLeaf (Leaf          ) = 0;
      </code></pre></div></div>
<span class="text top">Algebraic data types are very well-suited for represented abstract syntaxes of languages, and pattern matching unification makes it possible to define concise implementations of the operational semantics of languages (as well as any other transformations over abstract syntax trees, including optimization algorithms, static analysis algorithms, and compilation algorithms).</span>
<a name="beb651b8549a4706a411ce0af3cd0010"></a><div class="linked block"><div class="link-block">[<a href="#beb651b8549a4706a411ce0af3cd0010">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Suppose we want to define an abstract syntax and simple interpreter for formulas. We can use the declarations below to do so.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
module Formula where

data Formula = 
    T
  | F
  | Not Formula
  | And Formula Formula
  | Or Formula Formula
  deriving Show;

vNot (T) = F;
vNot (F) = T;

vAnd (T, T) = T;
vAnd (T, F) = F;
vAnd (F, T) = F;
vAnd (F, F) = F;

vOr (T, T) = T;
vOr (T, F) = T;
vOr (F, T) = T;
vOr (F, F) = F;

eval (T        ) = T;
eval (F        ) = F;
eval (Not f    ) = vNot (eval f);
eval (And f1 f2) = vAnd (eval f1, eval f2);
eval (Or  f1 f2) = vOr (eval f1, eval f2);
      </code></pre></div></div>
        
<span class="text">Using wildcards (written using the underscore <code>_</code>) in patterns makes it possible to write even more concise definitions.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
vAnd (T, T) = T;
vAnd _      = F;

vOr (F, F) = F;
vOr _      = T;

eval (Not f    ) = vNot (eval f);
eval (And f1 f2) = vAnd (eval f1, eval f2);
eval (Or  f1 f2) = vOr (eval f1, eval f2);
eval (f)         = f;
        </code></pre></div></div>
        
<span class="text">To check equality of algebraic data type instances, it is necessary to either implement or derive the equality function <code>==</code>. To have the Haskell interpreter or compiler derive it automatically, you can use <code>deriving Eq</code>. These can be combined with other <code>deriving</code> directives, such as in the example below.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
data Formula = 
    T
  | F
  | Not Formula
  | And Formula Formula
  | Or Formula Formula
  deriving (Eq, Show);
        </code></pre></div></div>
      </div></div></div></div>
  <a name="7.5"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#7.5">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.5.</span> Type system of the typed declarative language Haskell</h3>
<span class="text top">Haskell natively supports defining and using algebraic data types, tuples, lists, and functions. The Haskell type system provides a good way to organize and document these data structures, and governs how they can be combined. The abstract syntax for a portion of the Haskell type system is provided below.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">Haskell type &tau; <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>Bool</code> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>Int</code> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>Integer</code> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>Char</code> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>()</code> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>(</code> &tau; <code>,</code> &tau; <code>)</code> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>(</code> &tau; <code>,</code> &tau; <code>,</code> &tau; <code>)</code> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> &#8942; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>(</code> &tau; <code>,</code> ... <code>,</code> &tau; <code>)</code> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>[</code> &tau; <code>]</code> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> &tau; <code>-></code> &tau;</td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> &#8942; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
</td></tr></table></td></tr></table>
Haskell allows users to define their own algebraic data types as well as their own type synonyms. Every Haskell module has two distinct namespaces for identifiers, and these two namespaces are completely disjoint: there is a namespace for identifiers that correspond to variable, functions, and constructors, and there is a namespace for identifiers that correspond to types. The concrete syntax determines to which namespace a given variable belongs, and there is never any ambiguity in the concrete syntax in this regard. Note that this is unlike Python, where types can appear in any expression within a program. The following example illustrates the distinct namespaces for <span style="background-color:lightgreen">expressions</span> and <span style="background-color:pink">types</span>:
<div class="code"><div class="source">
<br/>module Example where
<br/>
<br/><span style="background-color:lightgreen">f</span> :: <span style="background-color:pink">Integer</span> -> <span style="background-color:pink">Integer</span>
<br/><span style="background-color:lightgreen">f</span> (<span style="background-color:lightgreen">x</span>) = <span style="background-color:lightgreen">x</span> + <span style="background-color:lightgreen">x</span>
<br/>
<br/>data <span style="background-color:pink">Tree</span> = <span style="background-color:lightgreen">Leaf</span> | <span style="background-color:lightgreen">Node</span> <span style="background-color:pink">Tree</span> <span style="background-color:pink">Tree</span>
<br/>
<br/>type <span style="background-color:pink">AnotherNameForInteger</span> = <span style="background-color:pink">Integer</span>
<br/>
<br/>type <span style="background-color:pink">AnotherNameForTree</span> = <span style="background-color:pink">Tree</span>
<br/>
<br/><span style="background-color:lightgreen">isLeaf</span> :: <span style="background-color:pink">AnotherNameForTree</span> -> <span style="background-color:pink">Bool</span>
<br/><span style="background-color:lightgreen">isLeaf</span> (<span style="background-color:lightgreen">Leaf</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;) = <span style="background-color:lightgreen">True</span>
<br/><span style="background-color:lightgreen">isLeaf</span> (<span style="background-color:lightgreen">Node</span> <span style="background-color:lightgreen">t1</span> <span style="background-color:lightgreen">t2</span>) = <span style="background-color:lightgreen">False</span>
<br/><br/></div></div></span>
<span class="text top">Haskell lists have a list type in Haskell. For example, a list of integers has the type <code>[Integer]</code>.</span>
<div class="code top"><div class="source"><pre><code class="haskell">
list :: [Integer]
list = [1,2,3]
      </code></pre></div></div>
<span class="text top">Haskell lists are actually represented using an algebraic data type that is similar to the <code>Tree</code> data type <a href="#7.4">that we have already seen</a>. If we were to define our own algebraic data type for lists in Haskell, for example, we could do so as follows (the terms "nil" and "cons" are commonly used in the functional language community for the empty list and for the list node constructor, respectively):</span>
<div class="code top"><div class="source"><pre><code class="haskell">
data List = Nil | Cons Integer List

example :: List
example = Cons 1 (Cons 2 (Cons 3 Nil))
      </code></pre></div></div>
<span class="text top">The built-in list type has its own special names for the two constructors: the empty list is denoted <code>[]</code>, and the list node constructor is the operator <code>(:)</code>, which can also be written as an infix operator <code>:</code>. The following three syntaxes are equivalent, and evaluate to the same list <code>[1,2,3]</code>:</span>
<div class="code top"><div class="source"><pre><code class="haskell">
example1 :: [Integer]
example1 = (:) 1 ((:) 2 ((:) 3 []))

example2 :: [Integer]
example2 =  1 : (2 : (3 : []))

example3 :: [Integer]
example3 =  [1,2,3]
      </code></pre></div></div>
<span class="text top">There is also a syntax for defining lists that contain ranges of integers:</span>
<div class="code top"><div class="source"><pre><code class="haskell">
*> [1..4]
[1,2,3,4]
      </code></pre></div></div>
<span class="text top">Haskell supports user-defined type synonyms. These are simply substituted and have no restrictive effects.</span>
<div class="code top"><div class="source"><pre><code class="haskell">
type Distance = Integer
      </code></pre></div></div>
<span class="text top">There are some default type synonym definitions, such as <code>String</code>; strings in Haskell are just lists of characters:</span>
<div class="code top"><div class="source"><pre><code class="haskell">
type String = [Char]

example1 :: String
example1 = "abcdefg"

example2 :: String
example2 = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
      </code></pre></div></div>
<span class="text top">Type synonyms can be assigned any valid type, no matter how complex it may be. In the below example, the type synonym <code>GameStrategyAlgorithm</code> is equivalent to the type <code>[[(Integer, Integer)]] -> String</code> (i.e., the type for functions that take lists of lists of integer pairs and return a string):</span>
<div class="code top"><div class="source"><pre><code class="haskell">
type GameState = [(Integer, Integer)]
type Game = [GameState]
type Strategy = String
type GameStrategyAlgorithm = Game -> Strategy
      </code></pre></div></div></div>
  <a name="7.6"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#7.6">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.6.</span> Defining and working with infinite data type instances using lazy evaluation</h3>
<span class="text top">Since Haskell expressions are only evaluated when a query is made, a Haskell module can safely describe recursively defined, potentially infinitely large values. For example, we can define an infinite list containing the integer <code>1</code> in every position:</span>
<div class="code top"><div class="source"><pre><code class="haskell">
infinite :: [Integer]
infinite = [1] ++ infinite
      </code></pre></div></div>
<span class="text top">Equivalently, we can use the <code>(:)</code> list node constructor:</span>
<div class="code top"><div class="source"><pre><code class="haskell">
infinite :: [Integer]
infinite = 1 : infinite
      </code></pre></div></div>
<span class="text top">Haskell also allows infinite lists containing ranges to be declared using the list range notation:</span>
<div class="code top"><div class="source"><pre><code class="haskell">
*> take 10 [5..]
[5,6,7,8,9,10,11,12,13,14]
      </code></pre></div></div>
<span class="text top">The Haskell operational semantics is based on pattern matching unification, but it doesn't work exactly like the operational semantics we implemented in <a href="#assignment4">Assignment #4</a>. Haskell supports <i>lazy evaluation</i>. Intuitively, when trying to evaluate a function application of the form <i>f</i>(<i>e</i>), Haskell will only evaluate the expression <i>e</i> using substitutions until it is sufficiently deep to try all the patterns in the definition of <i>f</i> (e.g., if the patterns associated with <i>f</i> are all of depth at most 3, the expression <i>e</i> will be evaluated until the constructors up to depth 3 are known, and no further).
<br/><br/>
Haskell lazy evaluation operational semantics make it possible to perform queries on infinite values without running into an infinite recursion or infinite loop. For example, suppose we define the following function on lists, which takes only the first <code>n</code> elements of a list (note that this function is already included in the <code>Prelude</code>; we use <code>take_</code> for our examples to avoid a name collision).</span>
<div class="code top"><div class="source"><pre><code class="haskell">
take_ :: (Integer, [Integer]) -> [Integer]
take_ (0, xs    ) = []
take_ (n, (x:xs)) = x : take (n-1, xs)
      </code></pre></div></div>
<span class="text top">Querying the infinite list is not a problem if we use <code>take</code>.</span>
<div class="code top"><div class="source"><pre><code class="haskell">
*> take_ (10, infinite)
[1,1,1,1,1,1,1,1,1,1]
      </code></pre></div></div>
<span class="text top">Using pattern matching unification and lazy evaluation, it is also possible to define algorithm that can operate on infinite lists. For example, we can define a function that adds all the corresponding elements of two infinite lists. Notice that there is no case for the empty list in this definition because infinite lists are never empty.</span>
<div class="code top"><div class="source"><pre><code class="haskell">
addInfiniteLists :: ([Integer], [Integer]) -> [Integer]
addInfiniteLists (x:xs, y:ys) = (x + y) : addInfiniteLists (xs, ys)
      </code></pre></div></div>
<span class="text top">We can now use the <code>addInfiniteLists</code> function to add two infinite lists. Suppose we have the following definitions:</span>
<div class="code top"><div class="source"><pre><code class="haskell">
ones = 1 : ones
twos = 2 : twos
      </code></pre></div></div>
<span class="text top">We can then define an infinite list in which all entries are <code>3</code>:</span>
<div class="code top"><div class="source"><pre><code class="haskell">
*> take 10 (addInfiniteLists (ones, twos))
[3,3,3,3,3,3,3,3,3,3]
      </code></pre></div></div></div>
  <a name="7.7"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#7.7">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.7.</span> Functions and higher-order functions in a typed functional language</h3>
<span class="text top">Haskell is a functional language; functional languages are distinguished by their ability to allow users to define and use <i>higher-order function</i>: functions that can take other function as arguments, and that can return functions as results. Many other languages have native support for higher-order functions, including JavaScript and Python; we say that these languages support the functional programming paradigm.
<br/><br/>
To start become familiar with the concept of a higher-order function, we can consider the following example:</span>
<div class="code top"><div class="source"><pre><code class="haskell">
f :: Integer -> Integer
f (x) = x + 1

g :: Integer -> (Integer -> Integer)
g (y) = f
      </code></pre></div></div>
<span class="text top">Notice that <code>g</code> is a function that takes an integer as an argument. It then throws this argument away and returns the function <code>f</code>. Its type reflects this. Thus, the result of evaluating an expression such as <code>g(4)</code> is a function of type <code>Integer -> Integer</code>, and this function can be applied to another argument.</span>
<div class="code top"><div class="source"><pre><code class="haskell">
*> :t g(1)
g(1) :: Integer -> Integer
*> :t g(1)(5)
g(1)(5) :: Integer
*> g(1)(5)
6
      </code></pre></div></div>
<span class="text top">What if we want to define a function like <code>g</code> that can be partially applied to only some of its arguments, but that still uses all of its arguments? We can do so by listing multiple, space-separated parameters in the definition of <code>g</code>.</span>
<div class="code top"><div class="source"><pre><code class="haskell">
g :: Integer -> (Integer -> Integer)
g (y) (x) = y + x
      </code></pre></div></div>
<span class="text top">It is then possible to apply <code>g</code> to arguments one at a time, as before.</span>
<div class="code top"><div class="source"><pre><code class="haskell">
*> :t g(3)
g(3) :: Integer -> Integer
*> :t g(3)(4)
g(3)(4) :: Integer
*> g(3)(4)
7
      </code></pre></div></div>
<span class="text top">Notice the relationship between application of functions to arguments, and the types of each intermediate result. Suppose we have the following definitions.</span>
<div class="code top"><div class="source"><pre><code class="haskell">
data A = A
data B = B
data C = C
data D = D
data E = E

f :: A -> (B -> (C -> (D -> E)))
f a b c d = E
      </code></pre></div></div>
<span class="text top">Then we have the following types for each of the following expressions (spacing adjusted for legibility):</span>
<div class="code top"><div class="source"><pre><code class="haskell">
*> :t f
f             :: A -> (B -> (C -> (D -> E)))

*> :t f(A)
f(A)          :: B -> (C -> (D -> E))

*> :t f(A)(B)
f(A)(B)       :: C -> (D -> E)

*> :t f(A)(B)(C)
f(A)(B)(C)    :: D -> E

*> :t f(A)(B)(C)(D)
f(A)(B)(C)(D) :: E
      </code></pre></div></div>
<a name="1bdc6c8725eb468894c900da3baaa814"></a><div class="linked block"><div class="link-block">[<a href="#1bdc6c8725eb468894c900da3baaa814">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">We want to write a higher-order function that takes any function <code>f</code> of type <code>Integer -> Integer</code> and returns a function <code>f'</code> that is its reflection across the <i>x</i>-axis (i.e., for all <code>x</code>, <code>f(x)</code> = <code>-f'(x)</code>).</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
reflect :: (Integer -> Integer) -> Integer -> Integer
reflect (f) (x) = - f(x) 
        </code></pre></div></div>
        
<span class="text">Notice that we could also write the type as <code>(Integer -> Integer) -> (Integer -> Integer)</code> because <code>-></code> is right-associative. This makes it more obvious that <code>reflect</code> takes a function of type <code>Integer -> Integer</code> as an input and returns a function of type <code>Integer -> Integer</code> as an output.</span>
      </div></div></div>
<a name="939b3bd03b6c4835ab93b81eec793179"></a><div class="linked block"><div class="link-block">[<a href="#939b3bd03b6c4835ab93b81eec793179">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">We want to write a higher-order function that takes any function <code>f</code> of type <code>Integer -> Integer</code> and returns an integer approximation of its definite integral starting at <i>x</i> = 0.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
integral :: (Integer -> Integer) -> Integer -> Integer
integral (f) (x) = sum [ f(k) | k <- [0..x] ]
        </code></pre></div></div>
        
<span class="text">We could also write a higher-order function that takes any function <code>f</code> of type <code>Double -> Double</code> and returns an approximation of its definite integral starting at <i>x</i> = 0 for a given precision.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
integral :: Double -> (Double -> Double) -> Double -> Double
integral (i) (f) (x) = sum [ f(k*i)*i | k <- [0..(x/i)] ]
        </code></pre></div></div>
      </div></div></div>
<a name="b881f643ee054befa099c21d8d46390a"></a><div class="linked block"><div class="link-block">[<a href="#b881f643ee054befa099c21d8d46390a">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">We want to write a higher-order function that takes any function <code>f</code> of type <code>Double -> Double</code> and returns an approximation of its derivative.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
derivative :: Double -> (Double -> Double) -> Double -> Double
derivative (h) (f) (x) = (f(x + h) - f(x)) / h
        </code></pre></div></div>
      </div></div></div></div>
  <a name="7.8"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#7.8">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.8.</span> Logic programming</h3>
<span class="text top">Declarative languages are well-suited for describing logical models and then examining them by making queries. Declarative languages like Prolog and Datalog are designed specifically to support logic programming. In Haskell, it is possible to use functions that return boolean values to represent logical predicates, and boolean expressions to represent the formulas that define them.</span>
<a name="c24e8ebd33174a6bae403a96c4512c99"></a><div class="linked block"><div class="link-block">[<a href="#c24e8ebd33174a6bae403a96c4512c99">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Suppose we want to model a simple access control system (e.g., for a file system). Notice that we can view functions like <code>user()</code> and <code>owns()</code> either as tables in a database (with each declaration for the function acting as a row in the table) or as logical predicates.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
data Constant = Alice | Bob | X | Y | Z deriving (Eq, Show)

-- Define which constants are a file.
file (X) = True
file (Y) = True
file (Z) = True
file (_) = False

-- Define which constants are a user.
user (Alice) = True
user (Bob)   = True
user (_)     = False

-- Specify which users are administrators.
admin(Alice) = True
admin(Bob)   = False

-- Specify file ownership relation.
owns (Alice, X) = True
owns (Bob,   Y) = True
owns (Bob,   Z) = True
owns (_,     _) = False

-- Only owners and administrators can write files.
write (user', file') = 
     ( owns(user', file') || admin(user'))
  && user(user')
  && file(file')

-- Anyone can read files.
read (user, file) = True
        </code></pre></div></div>
        
<span class="text">In the above example, we needed to define predicates that distinguished different types of constants. However, this means that every call to <code>file()</code> and <code>user()</code> must take place when the program is running. We can make the code more efficient by instead declaring distinct types. Since type checking is performed only at compile time in Haskell, this will still ensure that there are no type errors, but it will be more efficient because fewer function invocations will occur when the program is running.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
data User = Alice | Bob deriving (Eq, Show)
data File = X | Y | Z deriving (Eq, Show)

admin :: User -> Bool
admin (Alice) = True
admin (Bob)   = False

owns :: (User, File) -> Bool
owns (Alice, X) = True
owns (Bob,   Y)   = True
owns (Bob,   Z)   = True
owns (_,     _)   = False

write :: (User, File) -> Bool
write (user, file) = owns(user, file) || admin(user)

read :: (User, File) -> Bool
read (user, file) = True
        </code></pre></div></div>
      </div></div></div></div>
  <a name="7.9"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#7.9">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.9.</span> Data encapsulation using algebraic data types</h3>
<span class="text top">Typed languages that support algebraic data types make it possible to implement and enforce a kind of data encapsulation. For example, suppose we want to represent distances in various units (such as Imperial and metric units) in our program. There are well-known examples of expensive software failures (such as the crash of the <a href="http://en.wikipedia.org/wiki/Mars_Climate_Orbiter">Mars Climate Orbiter</a>) that occurred because one component assumed that numerical data was in Imperial units, while another component assumed it was metric units.</span>
<div class="code top"><div class="source"><pre><code class="haskell">
data Meters = Meters Integer
data Feet = Feet Integer
      </code></pre></div></div>
<span class="text top">Given the above, it is now possible to enforce which type of measurement is supported by a function. For example:</span>
<div class="code top"><div class="source"><pre><code class="haskell">
data Action = KeepGoing | SlowDown

updateVelocity :: Feet -> Action
updateVelocity (Feet n) = if n < 100 then SlowDown else KeepGoing
      </code></pre></div></div></div>
  <a name="7.10"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#7.10">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.10.</span> Predefined Haskell type classes, user-defined operators, and embedded languages</h3>
<span class="text top">Haskell allows programmers to define their own functions for converting algebraic data type values to strings (e.g., for displaying them in the interactive interface), and it allows programmers to provide custom definitions for numeric literals (i.e., <code>0</code>, <code>1</code>, <code>2</code>, and so on) and built-in operators (such as <code>+</code>, <code>*</code>, and so on).</span>
<div class="code top"><div class="source"><pre><code class="haskell">
instance Num Meters where
  fromInteger n = Meters n
  (Meters x) + (Meters y) = Meters (x + y)
      </code></pre></div></div>
<span class="text top">The above definitions allow us to use the numeric liters and built-in operators to work with values of type <code>Meters</code>.</span>
<div class="code top"><div class="source"><pre><code class="haskell">
*> 1 + 2 + 3 :: Meters
Meters 6
      </code></pre></div></div>
<span class="text top">It is also possible to provide a user-defined function for converting values of type <code>Meters</code> to strings.</span>
<div class="code top"><div class="source"><pre><code class="haskell">
instance Show Meters where
  show (Meters n) = show n ++ " meters"
      </code></pre></div></div>
<span class="text top">Then, we have the following behavior:</span>
<div class="code top"><div class="source"><pre><code class="haskell">
*> 1 + 2 + 3 :: Meters
6 meters
      </code></pre></div></div>
<span class="text top">The Haskell features that support algebraic data types, multiple ways to apply higher-order functions to arguments, user-defined infix operators, and user-defined definitions of built-in literals and functions can be used in concert to easily define new programming languages <i>within</i> Haskell itself. This makes it much easier to build parse trees directly within Haskell, thus obviating the need for a parser.</span>
<a name="6c93307257d142a09a6927e0ecd8603a"></a><div class="linked block"><div class="link-block">[<a href="#6c93307257d142a09a6927e0ecd8603a">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
An <i>embedded language</i> is a subset of the concrete syntax of a programming language (the <i>host</i> language) that is treated as its own separate, self-contained language. Libraries can often be viewed as embedded languages.
      </div></div></div>
<a name="334b004be37343b3b190ddd3fd9ca116"></a><div class="linked block"><div class="link-block">[<a href="#334b004be37343b3b190ddd3fd9ca116">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Suppose we define the following algebraic data types, corresponding to an abstract syntax for an imperative programming language. This definition, along with some of Haskell's other features, will allow us to turn this into an <a href="#6c93307257d142a09a6927e0ecd8603a"><i>embedded language</i></a> within Haskell. We can then use Haskell's concrete syntax to write the concrete syntax for this language, and Haskell's evaluation algorithm will also act as the parser for this language (with the Haskell evaluation algorithm producing an abstract syntax tree representation of whatever is written).</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
data Term =
    Number Integer
  | Plus Term Term
  deriving Show
      
data Formula = 
    T 
  | F 
  | Not Formula 
  | And Formula Formula
  | Or Formula Formula
  | Equal Term Term
  | LessThan Term Term
  deriving Show

data Statement =
    Print Term Statement
  | If Formula Statement Statement
  | End
  deriving Show
        </code></pre></div></div>
        
<span class="text">We also introduce some user-defined infix operators, and add user-specified definitions for some built-in Haskell operators:</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
(<<<) :: Term -> Term -> Formula
(<<<) t1 t2 = LessThan t1 t2

(===) :: Term -> Term -> Formula
(===) t1 t2 = Equal t1 t2

(&&&) :: Formula -> Formula -> Formula
(&&&) f1 f2 = And f1 f2

(|||) :: Formula -> Formula -> Formula
(|||) f1 f2 = Or f1 f2

instance Num Term where
  fromInteger n = Number n
  t1 + t2 = Plus t1 t2
        </code></pre></div></div>
        
<span class="text">We can now use all of the above together with the <code>$</code> syntax to easily write down abstract syntax trees.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
parseTree =
   Print 5 $
   Print 6 $
   If ((5 <<< 6) &&& (6 <<< 7)) (
     Print 6 $
     Print 7 $
     End
   ) $
   End
        </code></pre></div></div>
        
<span class="text">Evaluating the definition of <code>parseTree</code> will yield the actual algebraic data type instance (i.e., a parse tree).</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
*> parseTree
Print (Number 5) (Print (Number 6) (
  If
    (And (LessThan (Number 5) (Number 6)) (LessThan (Number 6) (Number 7))) 
    (Print (Number 6) (Print (Number 7) End)) End)
  )
        </code></pre></div></div>
      </div></div></div></div>
  <a name="7.11"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#7.11">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.11.</span> Additional useful Haskell language features and examples</h3>
<span class="text top">Like Java/C/C++, Haskell provides a built-in ternary operator <code>if ... then ... else ...</code> for writing conditional expressions:</span>
<div class="code top"><div class="source"><pre><code class="haskell">
*> if True then 1 else 2
1
*> if False && True then "Yes" else "No"
"No"
      </code></pre></div></div>
<span class="text top">However, this is only a convenience; a user can easily implement his or her own syntax for this purpose. The support for pattern matching unification and lazy evaluation that Haskell's operational semantics provides is sufficient. Two example implementations are provided below.</span>
<div class="code top"><div class="source"><pre><code class="haskell">
if' :: (Bool, Integer, Integer) -> Integer
if' (True,  trueBranch, falseBranch) = trueBranch
if' (False, trueBranch, falseBranch) = falseBranch

if'' :: Bool -> Integer -> Integer -> Integer
if'' True  trueBranch _           = trueBranch
if'' False _          falseBranch = falseBranch
      </code></pre></div></div>
<span class="text top">The <code>if ... then ... else ...</code> syntax (or function, as we have seen above) can be useful in certain situations.</span>
<a name="cb9d023417604b6eafe52b06e26f35fb"></a><div class="linked block"><div class="link-block">[<a href="#cb9d023417604b6eafe52b06e26f35fb">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Suppose we are trying to represent an <a href="#e1a5053a93d54ad4b02da10e4981b810">environment</a> or <a href="#f7d600442fe211e38cf6ce3f5508acd9">substitution</a> using a data structure in Haskell. We might do so by using a list of tuples, where each tuple is a pair consisting of a <code>String</code> and a value (e.g., an <code>Integer</code>). For example:</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
[("x",1), ("y", 2)] :: [(String, Integer)]
        </code></pre></div></div>
        
<span class="text">Then, we would need a function that can help us retrieve a value associated with a particular variable name.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
lookup' :: String -> [(String, Integer)] -> Integer
lookup' x ((x',i) : rest) = if x == x' then i else lookup' x rest
        </code></pre></div></div>
        
<span class="text">In fact, Haskell's <a href="http://hackage.haskell.org/package/base">base</a> library contains a similar function, <code>lookup</code>. However, since it returns a result that is wrapped in a <code>Maybe</code> constructor, we can unwrap it using, e.g.:</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
unwrap :: Maybe Integer -> Integer
unwrap (Just n) = n
        </code></pre></div></div>
        
<span class="text">We discuss <code>Maybe</code> in <a href="#123b1d495c5f4c03827519c53ad95ee2">more detail</a> in a subsequent section.</span>
      </div></div></div>
<a name="9ea7dc92b52b4098b358eb45fec68a2a"></a><div class="linked block"><div class="link-block">[<a href="#9ea7dc92b52b4098b358eb45fec68a2a">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Suppose we want to write a simple interpreter for formulas (similar to the one in <a href="#beb651b8549a4706a411ce0af3cd0010">this example</a>), except we also want to support variables in the language. The data type corresponding to the abstract syntax might then look as follows:</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
data Formula =
    T
  | F
  | Variable String
  | Xor Formula Formula
  deriving Show
      </code></pre></div></div>
        
<span class="text">We can then write a simple interpreter that uses environments (as defined in <a href="#cb9d023417604b6eafe52b06e26f35fb">this example</a>) in the following way (notice that the logical operation <b>xor</b> can be represented with the inequality operator <code>/=</code> on booleans):</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
eval :: [(String, Bool)] -> Formula -> Bool
eval env (T         ) = True
eval env (F         ) = False
eval env (Variable x) = lookup' x env
eval env (Xor f1 f2 ) = eval env f1 /= eval env f2
        </code></pre></div></div>
        
<span class="text">We can then run the evaluation algorithm above on a given environment and expression containing variables:</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
*> eval [("x", True), ("y", False), ("z", True)] (Xor (Variable "x") (Variable "y"))
True
        </code></pre></div></div>
      </div></div></div>
<a name="a97e8ebd22174a6bae403a96c4511c67"></a><div class="linked block"><div class="link-block">[<a href="#a97e8ebd22174a6bae403a96c4511c67">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Suppose we want to represent our own totally ordered set. For example, suppose we have the following data type for representing a discrete subset of the color spectrum:</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
data Color = Red | Green | Blue
        </code></pre></div></div>
        
<span class="text">Since <code>Red</code> has the lowest frequency and <code>Blue</code> has the highest frequency, we can define an ordering on all instances of this data type by making the <code>Color</code> type a member of the <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html"><code>Ord</code></a> type class. Note that we could use wildcards (<code>_</code>) to make the definition more concise.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
instance Ord Color where
  Red   <= Red   = True
  Red   <= Green = True
  Red   <= Blue  = True
  Green <= Green = True
  Green <= Blue  = True
  Blue  <= Blue  = True
  _     <= _     = False
        </code></pre></div></div>
        
<span class="text">It is now possible to use the built-in operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> to compare colors, as well as library functions such as <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#v:max"><code>max :: Color -> Color -> Color</code></a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#v:min"><code>min :: Color -> Color -> Color</code></a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#v:maximum"><code>maximum :: [Color] -> Color</code></a>, and <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#v:minimum"><code>minimum :: [Color] -> Color</code></a>.</span>
      </div></div></div>
<a name="21ae535d73b54e0283c6bec5cecb8565"></a><div class="linked block"><div class="link-block">[<a href="#21ae535d73b54e0283c6bec5cecb8565">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Suppose we have a data type that allows us to build trees that contain integer constants in their leaves.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
data IntegerTree = Node IntegerTree IntegerTree | Leaf Integer
        </code></pre></div></div>
        
<span class="text">We can define a recursive function that assembles all the integers in the leaves in a single list.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
ints :: IntegerTree -> [Integer]
ints (Node t1 t2) = ints t1 ++ ints t2
ints (Leaf n    ) = [n]
        </code></pre></div></div>
      </div></div></div>
<a name="35e16e3052bf4683856ee61eda628366"></a><div class="linked block"><div class="link-block">[<a href="#35e16e3052bf4683856ee61eda628366">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Suppose we want to write a function that composes two functions on integers. We might define a type synonym for such functions:</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
type Function = Integer -> Integer
        </code></pre></div></div>
        
<span class="text">We then know that one possible type for a composition function might be as follows (it takes two function arguments, and returns a new composed function as a result):</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
compose :: Function -> Function -> Function
        </code></pre></div></div>
        
<span class="text">However, how do we actually implement <code>compose</code>?</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
compose f g = ?
        </code></pre></div></div>
        
<span class="text">To understand how we can do so, we must first expand the type of <code>compose</code>; let's substitute one the right-most <code>Function</code> synonym with its definition:</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
compose :: Function -> Function -> (Integer -> Integer)
        </code></pre></div></div>
        
<span class="text">Now recall that the <code>-&gt;</code> type operator is right-associative; this means we can remove the right-most set of parentheses without changing the meaning of the type:</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
compose :: Function -> Function -> Integer -> Integer
        </code></pre></div></div>
        
<span class="text">It is now clear how to implement <code>compose</code>: it takes two <code>Function</code> arguments, and one <code>Integer</code> argument:</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
compose :: Function -> Function -> Integer -> Integer
compose f g x = f(g(x))
        </code></pre></div></div>
        
<span class="text">Note that this function is already available in the Haskell <a href="http://hackage.haskell.org/package/base">base</a> library, and it is called <code>(.)</code>. So we could also have defined <code>compose</code> as follows:</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
compose :: Function -> Function -> Function
compose f g = f . g
        </code></pre></div></div>
        
<span class="text">The above is an example of <a href="http://en.wikipedia.org/wiki/Tacit_programming"><i>point-free</i></a> programming, because we never explicitly gave names to the individual inputs (i.e., "points") on which the functions operate.</span>
      </div></div></div></div>
  <a name="7.12"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#7.12">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.12.</span> List comprehensions and pattern matching unification</h3>
<span class="text top">Haskell list comprehension syntax can be combined with Haskell's built-in pattern matching unification capabilities.</span>
<a name="d9e61a21e7744b51be660bbe84b3c798"></a><div class="linked block"><div class="link-block">[<a href="#d9e61a21e7744b51be660bbe84b3c798">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">In Haskell, list comprehensions make it possible to build up a list by iterating over the elements of one or more other lists (possibly filtering entries using one or more formulas).</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
*> [x+1 | x <- [0..4]]
[1,2,3,4,5]

*> [(x,y) | x <- [1..3], y <- [1..2]]
[(1,1),(1,2),(2,1),(2,2),(3,1),(3,2)]

*> [(x,y) | x <- [1..3], y <- [1..2], x + y == 3, x >= 1]
[(1,2),(2,1)]
        </code></pre></div></div>
      </div></div></div>
<a name="8ea8d6f6fc774cacb27951777d64a94f"></a><div class="linked block"><div class="link-block">[<a href="#8ea8d6f6fc774cacb27951777d64a94f">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">In Haskell list comprehensions, the left-hand side of the membership operator <code><-</code> can be any pattern. If a pattern appears on the left-hand side of <code><-</code>, then each element in the list on the right-hand side will be checked against the pattern. Only those elements that unify with the pattern will be considered, and for each of them, the subsequent conditions in the comprehension, as well as the body of the comprehension, will be evaluated.</span>
        <div class="paragraph"> 
Suppose a module contains a data type definition for a simple tree data structure, and a list of trees.
        </div>
        
<div class="code"><div class="source"><pre><code class="haskell">
data Tree =
    Node Tree Tree
  | Leaf
  deriving Show

example :: [Tree]
example = [
    Node Leaf Leaf,
    Node (Node Leaf Leaf) Leaf,
    Node Leaf (Node Leaf Leaf),
    Node Leaf (Node (Node Leaf Leaf) Leaf)
  ]
        </code></pre></div></div>
        
<span class="text">Then we can evaluate comprehensions such as the following. The first expression builds a list of the right subtrees of all the trees in <code>example</code>. The second expression builds a list containing the right subtrees that are not leaves. The last expression builds a list of subtree pairs for each non-leaf tree.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
*> [r | Node _ r <- example]
[Leaf, Leaf, Node Leaf Leaf, Node (Node Leaf Leaf) Leaf]

*> [r | Node _ r <- example, r /= Leaf]
[Node Leaf Leaf, Node (Node Leaf Leaf) Leaf]

*> [(l,r) | Node l r <- example]
[(Leaf, Leaf), (Node Leaf Leaf, Leaf), (Leaf, Node Leaf Leaf), (Leaf, Node (Node Leaf Leaf) Leaf)]
        </code></pre></div></div>
        
<span class="text">We can also easily check whether a particular kind of tree is in the list (such as a non-leaf tree) by adding a value of type <code>()</code> for each matching entry and then checking the length of the list resulting from the comprehension, or by comparing it to the empty list.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
*> length [() | Node _ _ <- example] > 0
True

*> [() | Node _ _ <- example] /= []
True
        </code></pre></div></div>
      </div></div></div></div>
  <a name="7.13"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#7.13">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.13.</span> Modeling and exploring state spaces in a typed declarative/functional language</h3>
<span class="text top">In many artificial intelligence and optimization problems, the collection of possible actions an algorithm, agent, or player can take can be modelled as a state space tree or graph (also sometimes called a decision tree or decision graph) which may or may not be infinite, depending on the length of the process or game being modeled. Algebraic data types and lazy evaluation make it easy to model such graphs.</span>
<a name="472f945cb582464b91a86bd814acade5"></a><div class="linked block"><div class="link-block">[<a href="#472f945cb582464b91a86bd814acade5">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Suppose we want to model a <a href="http://en.wikipedia.org/wiki/Tic-tac-toe">Tic-tac-toe</a> game, with the eventual goal of writing an AI algorithm that can play the game well. We can first settle on a representation for the board.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
data Cell = E | X | O deriving (Eq, Show)
type Pos = (Integer, Integer)
data Board = Board [(Pos, Cell)] deriving Eq

instance Show Board where
  show (Board pcs) = show [c | (p,c) <- pcs]

start :: Board
start = Board [((r,c),E) | r <- [1..3], c <- [1..3]]
        </code></pre></div></div>
        
<span class="text">Notice that the starting board consists of all empty cells.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
*> start
[E,E,E,E,E,E,E,E,E]
        </code></pre></div></div>
        
<span class="text">When a player moves, they place an <code>X</code> or <code>O</code> somewhere on the board. We can model this using a function that, given a move, transforms one board into another board. We use a list comprehension that updates only the cell with the corresponding position.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
move :: ((Pos, Cell), Board) -> Board
move ((pos', cell'), Board pcs) = Board [(pos, if pos' == pos then cell' else cell) | (pos, cell) <- pcs]
        </code></pre></div></div>
        
<span class="text">Suppose we want to make a state space graph that captures all possible paths a Tic-tac-toe game can take from a given starting position, and given a player's current turn. Let us assume that turns can be modelled using an infinite list. For example, here is an infinite list for game in which the <code>X</code> and <code>O</code> players take alternating turns.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
turns :: [Cell]
turns = X:O:turns
        </code></pre></div></div>
        
<span class="text">We first define a data structure for representing the possible paths a game can take. The data structure is a tree graph in which each node represents a game state (i.e., a <code>Board</code>), and can have any number of child trees (including zero).</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
data DecisionTree = Move Board [DecisionTree] deriving (Eq, Show)
        </code></pre></div></div> 
        
<span class="text">Now, we can define a function that builds a decision tree given a starting game state and the player turn sequence. Notice that <code>nextMoves</code> takes a <code>Board</code> and a <code>Cell</code> (to indicate which player is taking a turn), and uses a list comprehension to choose only the board cells that are empty. For each empty cell, it adds a new board state to the list in which that position is filled with the specified player's symbol.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
nextMoves :: (Board, Cell) -> [Board]
nextMoves (Board pcs, cell) = [move ((p, cell), Board pcs) | (p, E) <- pcs]
        </code></pre></div></div> 
        
<span class="text">Given a starting board and turn sequence, we can now build the tree of state spaces for the entire game.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
tree :: Board -> [Cell] -> DecisionTree
tree b (turn:turns) = Move b [tree b' turns | b' <- nextMoves (b, turn)]
        </code></pre></div></div>
        
<span class="text">Suppose we have a function <code>win :: Cell -> Board -> Bool</code> that checks if a given board is already a win for a particular player. We can then add an <code>Ord</code> instance to compare boards from player <code>X</code>'s perspective: a board is "greater" (or "better") than another board if either the board is a win for <code>X</code>, or the other board is a loss for <code>O</code>.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
instance Ord Board where
  b <= b' = win b' X || win b O
        </code></pre></div></div>
        
<span class="text">It is now possible to use the built-in operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> to compare boards, as well as library functions such as <code>max :: Board -> Board -> Board</code> and <code>maximum :: [Board] -> Board</code> to choose the "best" boards.</span>
      </div></div></div></div>
  <a name="7.14"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#7.14">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.14.</span> Ad Hoc and Parametric Polymorphism</h3>
<a name="7065360f071a42b1b02e4cb7b73caee8"></a><div class="linked block"><div class="link-block">[<a href="#7065360f071a42b1b02e4cb7b73caee8">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
A language supports <i>ad hoc polymorphism</i> if it allows programmers to specify multiple definitions for the same constant or variable (which could be a literal, an operator symbol, a function name, a type, and so on). An interpreter or compiler then choose the appropriate definition to use based on the context (usually, the types of the argument expressions and/or the surrounding expressions and statements in the abstract syntax tree).
<br/><br/>
Common examples of language features that support ad hoc polymorphism include operator overloading in C++, C</td><td style="padding-left:8px; white-space:nowrap;"> and Python (operator overloading is not supported in Java), method overloading in Java subclasses, Java interfaces, and type classes in Haskell.
      </div></div></div>
<a name="e9497e2275f347cbbc569f810cb58c2d"></a><div class="linked block"><div class="link-block">[<a href="#e9497e2275f347cbbc569f810cb58c2d">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="definition true_required"><span class="block_label">Definition:</span> 
A language supports <i>parametric polymorphism</i> if it allows programmers to specify a single definition for a function or procedure that can then be applied to values of multiple types (typically, a large range of types, or even all types). Typically, the function or procedure will operate on a container type, or some other parameterized or generic type. Thus, languages that support parametric polymorphism usually allow programmers to define data structures that can be parameterized by other data structures. 
<br/><br/>
Common examples of language features that support parametric polymorphism include Java generics and the Haskell type system (the latter uses an extension of the <a href="http://en.wikipedia.org/wiki/Hindley-Milner_type_system">Hindley-Milner type inference algorithm</a> that is also used by the programming language <a href="http://en.wikipedia.org/wiki/ML_(programming_language)">ML</a>).
      </div></div></div>
<span class="text top">Note an important distinction between ad hoc polymorphism and parametric polymorphism: ad hoc polymorphism allows programmers to continue adding new definitions for a given variable or constant within the same scope, while parametric polymorphism only permits a single, albeit generic, definition for a function or procedure within any given scope.</span>
<a name="e00c647a3e9f4f26b831db647d7c8a78"></a><div class="linked block"><div class="link-block">[<a href="#e00c647a3e9f4f26b831db647d7c8a78">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Suppose we define a function <code>len</code> for computing lengths of lists of integers.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
len :: [Integer] -> Integer
len []         = 0
len ((:) x xs) = 1 + len xs
        </code></pre></div></div>
        
<span class="text">Unfortunately, we cannot use the above function to compute the length of a list of, e.g., <code>Bool</code> values because the type <code>[Integer]</code> does not unify with the type <code>[Bool]</code>. We could write an alternative type to address this.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
len :: [Bool] -> Integer
len []         = 0
len ((:) x xs) = 1 + len xs
        </code></pre></div></div>
        
<span class="text">We can now use <code>len</code> on lists of type <code>[Bool]</code>, but we can no longer use it on lists of type <code>[Integer]</code>. Notice that the only thing that has changed is the type of the function; the body is the same in both cases. Haskell allows us to take advantage of this by employing a <i>type variable</i>.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
len :: [a] -> Integer
len []         = 0
len ((:) x xs) = 1 + len xs
        </code></pre></div></div>
        
<span class="text">With the above declaration, it is now possible to apply the <code>len</code> function to a list containing any type of element. This is because the type variable <code>a</code> unifies with any other type (including <code>Bool</code> and <code>Integer</code>), so the input type <code>[a]</code> will unify with both <code>[Integer]</code> and <code>[Bool]</code>, as well as types such as <code>[String -> String]</code> (a list of functions that take <code>String</code> inputs and return <code>String</code> outputs).</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
*> len [True, False, True]
3
*> len [1, 2, 3, 4, 5]
5
*> len [\s -> s ++ ".", \t -> t ++ ";"]
2
        </code></pre></div></div>
        
<span class="text">Since <code>len</code> is a function that can be applied to different input types, but has only a single definition that works for all input types, it is an example of <i>parametric</i> polymorphism.</span>
      </div></div></div>
<a name="b8adf3fedafc40648a90e89dcce10f8c"></a><div class="linked block"><div class="link-block">[<a href="#b8adf3fedafc40648a90e89dcce10f8c">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">We can define a <code>Set</code> data structure for holding sets of <code>Integer</code> values that has an underlying list implementation.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
module IntegerSet where
  
data Set =
    Empty
  | Set [Integer]
  deriving Show   
 
insert :: Set -> Integer -> Set
insert (Set l) x = Set (x:l)
insert (Empty) x = Set [x]

contains :: Integer -> Set -> Bool
contains x (Empty) = False
contains x (Set l) = x `elem` l
        </code></pre></div></div>
        
<span class="text">However, what if we also want user to have the option of using a data structure for sets that uses an underlying binary search tree implementation? We can first define a class for set data structures that specifies the signatures of the functions that a set data structure must support. We can even define new functions that rely only on the signature.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
module SetClass where

class IsSet s where
  empty :: s
  insert :: s -> Integer -> s
  contains :: Integer -> s -> Bool
  
  inserts :: s -> [Integer] -> s
  inserts s (x:xs) = inserts (insert s x) xs
  inserts s []     = s
        </code></pre></div></div>
        
<span class="text">This makes it possible to provide two different implementations that are both members of this class.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
module IntegerSetList where

import SetClass
  
data IntegerSetList =
    Empty
  | Set [Integer]
  deriving Show   

instance IsSet IntegerSetList where
  empty = Empty

  insert (Set l) x = Set (x:l)
  insert (Empty) x = Set [x]

  contains x (Empty) = False
  contains x (Set l) = x `elem` l
        </code></pre></div></div>
        
<div class="code"><div class="source"><pre><code class="haskell">
module IntegerSetTree where

import SetClass

data IntegerSetTree =
    Leaf
  | Node Integer IntegerSetTree IntegerSetTree
  deriving Show   

instance IsSet IntegerSetTree where
  empty = Leaf

  insert (Leaf       ) x = Node x Leaf Leaf
  insert (Node y s s') x =
    if x < y then 
      Node y (insert s x) s' 
    else
      Node y s (insert s' x)

  contains x (Leaf       ) = False
  contains x (Node y s s') =
    if y == x then
      True
    else if x < y then
      contains x s
    else
      contains x s'
        </code></pre></div></div>
      </div></div></div>
<span class="text top">Haskell type classes need not contain types; they can also contain type constructors (i.e., functions in the type system that can be used to construct a type given a type, i.e., type constructors with kind <code>Type -> Type</code>, and so on).</span>
<a name="1dade7b3338943cebc188d3b4b9890ba"></a><div class="linked block"><div class="link-block">[<a href="#1dade7b3338943cebc188d3b4b9890ba">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">We can define a <code>Set</code> data structure for holding sets of values of any type <code>a</code>.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
module Set where
  
data Set a =
    Empty
  | Set [a]
  deriving Show   
 
insert :: Set a -> a -> Set a
insert (Set l) x = Set (x:l)
insert (Empty) x = Set [x]

contains :: Eq a => a -> Set a -> Bool
contains x (Empty) = False
contains x (Set l) = x `elem` l
        </code></pre></div></div>
        
<span class="text">However, what if we also want user to have the option of using a data structure for sets that uses an underlying binary search tree implementation? We can first define a class for set data structures that specifies the signatures of the functions that a set data structure must support. We can even define new functions that rely only on the signature.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
module SetClass where

class IsSet s where
  empty :: s a
  insert :: Ord a => s a -> a -> s a
  contains :: (Ord a, Eq a) => a -> s a -> Bool
  
  inserts :: Ord a => s a -> [a] -> s a
  inserts s (x:xs) = inserts (insert s x) xs
  inserts s []     = s
        </code></pre></div></div>
        
<span class="text">This makes it possible to provide two different implementations of polymorphic set data structures that are both members of this class. Notice that we added the <code>Ord a</code> constraint on the element type <code>a</code> in case we want to compare them (e.g., if we are using a binary search tree implementation of sets).</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
module SetList where

import SetClass
  
data SetList a =
    Empty
  | Set [a]
  deriving Show   

instance IsSet SetList where
  empty = Empty

  insert (Set l) x = Set (x:l)
  insert (Empty) x = Set [x]

  contains x (Empty) = False
  contains x (Set l) = x `elem` l
        </code></pre></div></div>
        
<div class="code"><div class="source"><pre><code class="haskell">
module SetTree where

import SetClass

data SetTree a =
    Leaf
  | Node a (SetTree a) (SetTree a)
  deriving Show   

instance IsSet SetTree where
  empty = Leaf

  insert (Leaf       ) x = Node x Leaf Leaf
  insert (Node y s s') x =
    if x < y then 
      Node y (insert s x) s' 
    else
      Node y s (insert s' x)

  contains x (Leaf       ) = False
  contains x (Node y s s') =
    if y == x then
      True
    else if x < y then
      contains x s
    else
      contains x s'
        </code></pre></div></div>
      </div></div></div>
<a name="a881f643ee054befa199c31d8d46390a"></a><div class="linked block"><div class="link-block">[<a href="#a881f643ee054befa199c31d8d46390a">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Suppose we have a <code>Set</code> data structure for holding sets of values of any type <code>a</code> that has a corresponding <code>size :: Set a -> Int</code> function.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
module Set where
  
data Set a =
    Empty
  | Set [a]
  deriving (Eq, Show)   
 
size :: Set a -> Int
size (Set l) = length l
size (Empty) = 0
        </code></pre></div></div>
        
<span class="text">We can make it possible to order sets by their size using the <code>&lt;</code> operator by making the type <code>Set a</code> (for any possible <code>a</code>) a member of the <code>Ord</code> type class.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
instance Eq a => Ord (Set a) where
  s < s' = size s < size s'
        </code></pre></div></div>
        
<span class="text">Note that the instance declaration is prepended with the condition that the type <code>a</code> must be in the <code>Eq</code> type class. This is because the definition of <code>Set a</code> contains a <code>deriving Eq</code> clause, which means that a type <code>Set a</code> can only be used in a module if the parameter type <code>a</code> is a member of the <code>Eq</code> type class (otherwise, Haskell would not be able to compare two sets for equality using the automatically derived definition of <code>(==)</code> generated by the <code>deriving Eq</code> clause).</span>
      </div></div></div></div>
  <a name="7.15"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#7.15">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.15.</span> Folds, Unfolds, and Algebraic Properties of Functional Programs</h3>
<span class="text top">We have seen that the operational semantics of declarative and functional languages support an approach to problem solving that involves first defining a model of some system, and then querying that model to answer questions about that system or explore its properties. We can define this approach to programming with more consistency and mathematical rigor by identifying the mathematical transformations that are typically employed and composed when using this approach. In particular, most component operations fall into two categories:
<ul>
  <li><i><b>unfold</b></i> (or <i>anamorphism</i>) operations are used to define or construct a data value;</li>
  <li><i><b>fold</b></i> (or <i>catamorphism</i>) operations are used to reduce, simplify, break down, or transform a data value.</li>
</ul></span>
<span class="text top">A few special cases of the composition of a <b>fold</b> followed by an <b>unfold</b> are commonly used, as well (these are commonly implemented using comprehensions when the data value being transformed is a set or list):</span>
<span class="text top"><ul>
  <li><i><b>map</b></i> (sometimes known as <i>metamorphism</i>) operations are used to modify all the components of a data value using a single, often local transformation that is applied to all the components across the entire data value;</li>
  <li><i><b>filter</b></i> operations are used to remove (or select) only some of the components of a data value.</li>
</ul>
<br/>
The ability to describe an algorithm using a composition of <b>unfold</b>, <b>fold</b>, <b>map</b>, and <b>filter</b> operations imposes fewer restrictions on how that computation can be carried out (when compared to a description of the same algorithm using a sequential list of operations). A description using <b>fold</b>, <b>map</b>, and so on may still impose some <i>hierarchical</i> dependencies on the computation, but the operational semantics of such a description allows an implementation (or a compiled version) of the algorithm to perform operations in parallel <i>unless</i> such parallelization is explicitly forbidden by the algorithm itself through explicit sequential dependencies introduced by the programmer. In other words, <b>the default interpretation of such an algorithm definition is inherently parallelizable</b>.
<br/><br/>
Defining the above operations on algebraic data types (including polymorphic algebraic data types) is often a straightforward process (in fact, it can often be automated). The Haskell <a href="http://hackage.haskell.org/package/base">base</a> library provides functions for all of the above operations on Haskell lists, and many library functions are implemented using these functions; the Haskell compiler is optimized to compile these functions into efficient machine code. Most of the above functions are also supported by languages such as Python.</span>
<a name="e99b09b7d7054dcd8603ae063fae8fb7"></a><div class="linked block"><div class="link-block">[<a href="#e99b09b7d7054dcd8603ae063fae8fb7">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">We can begin by implementing a <b>fold</b> operation on Haskell <code>Integer</code> lists that does nothing.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
fold :: [Integer] -> [Integer]
fold []     = []
fold (x:xs) = x : fold xs
        </code></pre></div></div>
        
<span class="text">We can modify the above to replace the two list constructors (i.e., <code>(:)</code> and <code>[]</code>) in the input list with a binary operator and a base case (in this case, <code>(+)</code> and <code>0</code>). This way, the <code>fold</code> function now computes the sum of the elements in the list.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
fold :: [Integer] -> Integer
fold []     = 0
fold (x:xs) = x + fold xs
        </code></pre></div></div>
        
<span class="text">We can further generalize the above so that it takes the two replacement functions as arguments. The two functions are a replacement for <code>(:)</code>, so it must be of type <code>Integer -> Integer -> Integer</code>, and a replacement for <code>[]</code>, which must be of type <code>Integer</code>.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
fold :: (Integer -> Integer -> Integer) -> Integer -> [Integer] -> Integer
fold f b []     = b
fold f b (x:xs) = f x (fold f b xs)
        </code></pre></div></div>
        
<span class="text">We can now use the above <code>fold</code> implementation to define many common functions on lists of integers.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
sum :: [Integer] -> Integer
sum = fold (+) 0

product :: [Integer] -> Integer
product = fold (*) 1

maximum :: [Integer] -> Integer
maximum = fold max 0 -- Assumes non-negative integers.

minimum :: [Integer] -> Integer
minimum l = fold min (fold max 0 l) l
        </code></pre></div></div>
      </div></div></div>
<a name="173d61a62368428bb5f7bfc393d45ab8"></a><div class="linked block"><div class="link-block">[<a href="#173d61a62368428bb5f7bfc393d45ab8">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">The fold function for the default right-associative list implementation supported by Haskell (i.e., with the built-in constructors <code>(:)</code> and <code>[]</code>) is called <code>foldr</code>.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f base []     = base
foldr f base (x:xs) = f x (foldr f base xs)
        </code></pre></div></div>
        
<span class="text">The <code>foldr</code> function can be used to implement many of the usual library functions one might find useful when working with lists, and this is what is done in the Haskell libraries. Below are some examples (some of these are simplified versions of what is actually found in the libraries).</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
sum :: Num a -> [a] -> a
sum xs = foldr (+) 0 xs

max :: Ord a => a -> a -> a
max x y = if x > y then x else y

maximum :: Ord a => [a] -> a
maximum xs = foldr max 0 xs
        </code></pre></div></div>
      </div></div></div>
<a name="cc555577086f4c8bae8ba7fae4d62c8b"></a><div class="linked block"><div class="link-block">[<a href="#cc555577086f4c8bae8ba7fae4d62c8b">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">We can implement any <b>map</b> operation as a fold. Suppose we want to add the constant <code>1</code> to every element in an <code>Integer</code> list. For example, we want to achieve the following using a call to <code>foldr</code>:</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
*> [x + 1 | x <- [1,2,3,4,5]]
[2,3,4,5,6]
        </code></pre></div></div>
        
<span class="text">We can accomplish this by defining a modified list node constructor function that adds <code>1</code> to its first argument, then builds the list node:</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
addOneThenCons :: Integer -> [Integer] -> [Integer]
addOneThenCons x xs = (x + 1) : xs
        </code></pre></div></div>
        
<span class="text">We can now use the above together with <code>foldr</code>:</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
*> foldr addOneThenCons [] [1,2,3,4,5]
[2,3,4,5,6]
        </code></pre></div></div>
        
<span class="text">Using &lambda; abstractions, we can avoid having to explicitly define <code>addOneThenCons</code>:</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
*> foldr (\x xs -> (x+1) : xs) [] [1,2,3,4,5]
[2,3,4,5,6]
        </code></pre></div></div>
      </div></div></div>
<a name="7e489ac9ffdb41c7b295ea16c0255ebc"></a><div class="linked block"><div class="link-block">[<a href="#7e489ac9ffdb41c7b295ea16c0255ebc">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">We can implement any <b>filter</b> operation as a fold. For example, suppose we want to only keep positive integers from an integer list:</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
*> [x | x <- [-3,-2,-1,0,1,2,3], x > 0]
[1,2,3]
        </code></pre></div></div>
        
<span class="text">We can accomplish this by defining a modified list node constructor function that only adds a new list node if the data inside it is a positive integer:</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
consIfPositive :: Integer -> [Integer] -> [Integer]
consIfPositive x xs = if x > 0 then x : xs else xs
        </code></pre></div></div>
        
<span class="text">We can now use the above together with <code>foldr</code>:</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
*> foldr consIfPositive [] [-3,-2,-1,0,1,2,3]
[1,2,3]
        </code></pre></div></div>
        
<span class="text">Using &lambda; abstractions, we can avoid having to explicitly define <code>consIfPositive</code>:</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
*> foldr (\x xs -> if x > 0 then x : xs else xs) [] [-3,-2,-1,0,1,2,3]
[1,2,3]
        </code></pre></div></div>
      </div></div></div>
<a name="cec4b16ab14e4db49fb478aef9bd846b"></a><div class="linked block"><div class="link-block">[<a href="#cec4b16ab14e4db49fb478aef9bd846b">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">We can implement an easily parallelizable version of quicksort using <b>filter</b> operations:</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
qsort :: [Integer] -> [Integer]
qsort []     = []
qsort (x:xs) = qsort [y | y <- xs, y < x] ++ [x] ++ qsort [y | y <- xs, y >= x]
        </code></pre></div></div>
      </div></div></div>
<a name="2cc51f6d51e54601a95b14a30fe459a3"></a><div class="linked block"><div class="link-block">[<a href="#2cc51f6d51e54601a95b14a30fe459a3">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">We can implement a <b>fold</b> operation that works for associative binary operators that recursively splits the problem into two parts over and over until a base case is reached.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
fold :: (a -> a -> a) -> a -> [a] -> a
fold f b []  = b
fold f b [x] = x
fold f b xs  =
  fold f b (take (length xs `div` 2) xs)
    `f` 
  fold f b (drop (length xs `div` 2) xs)
        </code></pre></div></div>
        
<span class="text">If each recursive invocation were run on a separate thread, processor, server, and so on, this would maximum the amount of parallelization that can be achieved in performing this <b>fold</b> operation.</span>
      </div></div></div>
<a name="7e489ac9ffdb41c7b295ea16c0255ebc"></a><div class="linked block"><div class="link-block">[<a href="#7e489ac9ffdb41c7b295ea16c0255ebc">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example (filter, map, and fold operations in SQL-like languages):</span> 
        
<span class="text">SQL-like languages (as well as the <a href="http://en.wikipedia.org/wiki/Relational_algebra">relational algebra</a> on which they are based) can be viewed as supporting fold, map, and filter operations (and compositions thereof) on a particular data structure: a table. This allows databases to be distributed across multiple storage devices, and it makes it possible to simultaneously query different portions of a database, stored on different devices, using multiple computational devices (processors, virtual machines, servers, and so on) running in parallel.
<br/><br/>
For example, suppose an SQL table consists of some number of rows, and each row has an entry of the form <code>(Name, Age)</code>:</span>
        
<div class="code"><div class="source"><pre><code class="SQL">
+---------------+
|    People     |
+---------------+
| Name  |  Age  |
+-------+-------+
| Alice |  20   |
| Bob   |  17   |
| Carl  |  23   |
+-------+-------+
        </code></pre></div></div>
        
<span class="text">The following SQL query allows a user to retrieve only the <code>Name</code> entries in the table; this query amounts to a <b>map</b> operation:</span>
        
<div class="code"><div class="source"><pre><code class="sql">
> SELECT Name from People

+-------+
| Name  |
+-------+
| Alice |
| Bob   |
| Carl  |
+-------+
        </code></pre></div></div>
        
<span class="text">The following SQL query allows a user to retrieve only the entries within a certain <code>Age</code> range; this query amounts to a <b>filter</b> operation:</span>
        
<div class="code"><div class="source"><pre><code class="sql">
> SELECT * from People where Age >= 18

+---------------+
| Name  |  Age  |
+-------+-------+
| Alice |  20   |
| Carl  |  23   |
+-------+-------+
        </code></pre></div></div>
        
<span class="text">The following SQL query allows a user to retrieve the sum of the <code>Age</code> fields of all the entries; this query amounts to <b>fold</b> operation (it is often called an aggregation operation):</span>
        
<div class="code"><div class="source"><pre><code class="sql">
> SELECT SUM(Age) from People

+-------+
|  Age  |
+-------+
|  60   |
+-------+
        </code></pre></div></div>
        
<span class="text">We can easily simulate all of the above capabilities using another language that supports the declarative and functional programming paradigms, such as Haskell. Suppose we have the following definitions:</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
type Name = String
type Age = Integer
type Table = [(Name, Age)]

people = [("Alice", 20), ("Bob", 17), ("Carl", 23)]
        </code></pre></div></div>
        
<span class="text">We can then perform the following queries:</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
*> [name | (name, age) <- people]
["Alice", "Bob", "Carl"]

*> [(name, age) | (name, age) <- people, age >= 18]
[("Alice", 20), ("Carl", 23)]

*> foldr (+) 0 [age | (name, age) <- people]
60
        </code></pre></div></div>
        
<span class="text">Equivalently, we can use <code>map</code>, <code>filter</code>, <code>foldr</code>, and &lambda; abstractions instead of list comprehensions (the Haskell compiler simply converts list comprehensions into some combination of these during compilation):</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
*> map (\(name, age) -> name) people
["Alice", "Bob", "Carl"]

*> map fst people
["Alice", "Bob", "Carl"]

*> filter (\(name, age) -> age >= 18) people]
[("Alice", 20), ("Carl", 23)]

*> foldr (+) 0 (map snd people)
60
        </code></pre></div></div>
        
<span class="text">All of the above can also be done using Python list comprehensions:</span>
        
<div class="code"><div class="source"><pre><code class="py">
>>> People = [("Alice", 20), ("Bob", 17), ("Carl", 23)]

>>> [name for (name, age) in People]
["Alice", "Bob", "Carl"]

>>> [(name, age) for (name, age) in People if age >= 18]
[('Alice', 20), ('Carl', 23)]

>>> sum([age for (name, age) in People])
60
        </code></pre></div></div>
        
<span class="text">Python also supports <code>map</code>, <code>filter</code>, <code>reduce</code> (similar to Haskell's <code>foldr</code>), and lambda abstractions:</span>
        
<div class="code"><div class="source"><pre><code class="py">

>>> list(map((lambda person: person[0]), People))
['Alice', 'Bob', 'Carl']

>>> list(filter((lambda person: person[1] >= 18), People))
[('Alice', 20), ('Carl', 23)]

>>> from functools import reduce
>>> reduce(lambda x,y: x + y, [age for (name, age) in People])
60
        </code></pre></div></div>
      </div></div></div>
<a name="6235f5ed98124301bb2a7cac0f08cd03"></a><div class="linked block"><div class="link-block">[<a href="#6235f5ed98124301bb2a7cac0f08cd03">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example (filter and map operations in JavaScript libraries):</span> 
        
<span class="text">Many JavaScript libraries, such as <a href="http://jquery.com/">jQuery</a>/<a href="http://jqueryui.com/">jQuery UI</a>, <a href="http://nodejs.org/">node.js</a>, <a href="http://d3js.org/">d3</a>, and others support an abstraction for manipulating web documents (which are often used as application components on the web today) that is organized around <b>filter</b> and <b>map</b> operations.
<br/><br/>
In jQuery, it is possible to select all the elements with a certain tag in an HTML document and then to specify a function that will be applied to each element selected. This corresponds to the composition of a <b>filter</b> and <b>map</b> operation.
<br/><br/>
For example, the following code selects all the <code>li</code> elements and updates the text content of each to indicate the item number corresponding to that element. Notice that the <code>.text()</code> function takes a function as an argument (the function supplied as an argument takes an index as an input and returns a string):</span>
        
<div class="code"><div class="source"><pre><code class="javascript">
$("ul li").text(
  function( index ) {
    return "item number " + ( index + 1 );
  }
);
        </code></pre></div></div>
        
<span class="text">More generally, it's possible to update individual document elements using the <a href="http://api.jquery.com/each/"><code>.each()</code></a> function.</span>
      </div></div></div></div>
  <a name="7.16"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#7.16">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.16.</span> Folds, Monads, and Algebraic Properties of Programs</h3>
<span class="text top">In this section we introduce several consequences of viewing programs as a collection of functions (possibly assembled from building blocks such as folds and unfolds) that can be composed.</span>
<a name="90686c651b844976b9c69e2ab6e1064c"></a><div class="linked block"><div class="link-block">[<a href="#90686c651b844976b9c69e2ab6e1064c">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Suppose we have the following definition for a polymorphic data type <code>Tree a</code>:</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
data Tree a =
    Node a (Tree a) (Tree a)
  | Leaf
  deriving Show
        </code></pre></div></div>
        
<span class="text">To determine how to put together a <code>foldTree</code> function for values of type <code>Tree a</code>, we first list all the constructors for <code>Tree a</code> (we could also get this information using the <code>:t</code> command in GHCi):</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
Node :: a -> Tree a -> Tree a -> Tree a
Leaf :: Tree a
        </code></pre></div></div>
        
<span class="text">A fold function will simply replace all instances of <code>Node</code> and <code>Leaf</code> in a tree with different value or function (for example, let's call <code>Node</code>'s replacement <code>n</code> and <code>Leaf</code>'s replacement <code>l</code>); this means that the replacement values and functions must have a type that has the same structure (i.e., they must take the same number of arguments) as the constructors they replace. However, they will fold into some new type of value <code>b</code>, so we replace every instance of <code>Tree a</code> with the new result type <code>b</code>:</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
n :: a -> b -> b -> b
l :: b
        </code></pre></div></div>
        
<span class="text">We can now write our <code>foldTree</code> function to take the above two arguments, and then the tree that is being folded as the last argument. Every <code>Node</code> will be replaced with <code>n</code> and every <code>Leaf</code> will be replaced with <code>l</code>. Notice that in the case of <code>Node</code>, we also recursively fold the trees, since we need to turn them into the result type <code>b</code> before we can apply <code>n :: a -> b -> b -> b</code>.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
foldTree :: (a -> b -> b -> b) -> b -> Tree a -> b
foldTree n l (Node x t1 t2) = n x (foldTree n l t1) (foldTree n l t2)
foldTree n l Leaf           = l
        </code></pre></div></div>
        
<span class="text">Notice that a <code>mapTree</code> function is just a special case of fold in which <code>n x t1 t2 = Node (f x) t1 t2</code> for some function <code>f</code>, and where <code>l = Leaf</code>, since we want to change each value of type <code>a</code> inside the tree, but not the nodes of the tree themselves. This also means we no longer need <code>n</code> and <code>l</code> as arguments; we only need <code>f</code>.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
mapTree :: (a -> c) -> (Tree a -> Tree c)
mapTree f (Node x t1 t2) = Node (f x) (mapTree f t1) (mapTree f t2)
mapTree f Leaf           = Leaf
        </code></pre></div></div>
        
<span class="text">To reiterate, notice that the relationship between the two function is <code>mapTree f = foldTree (\x -> Node (f x)) Leaf</code> (and we could have defined <code>mapTree</code> in this way):</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
mapTree f = foldTree (\x -> Node (f x)) Leaf
        </code></pre></div></div>
        
<span class="text">In the above, we are taking advantage of Haskell's support for partially applying functions, since <code>Node</code> is partially applied to its result, which means <code>Node (f x)</code> is a function still waiting for two more arguments (the two subtrees). Alternatively but equivalently, we could have written the below definition:</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
mapTree f t = foldTree (\x t1 t2 -> Node (f x) t1 t2) Leaf t
        </code></pre></div></div>
      </div></div></div>
<a name="5d4b1d495c5f4c03827519c53ad95ee2"></a><div class="linked block"><div class="link-block">[<a href="#5d4b1d495c5f4c03827519c53ad95ee2">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Common operations on abstract syntax trees (such as evaluation and execution) can also be represented as fold operations. Suppose we have the following implementation for an abstract syntax for formulas (which we have seen in <a href="#beb651b8549a4706a411ce0af3cd0010">previous examples</a>):</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
data Formula = 
    T
  | F
  | Not Formula
  | And Formula Formula
  | Or Formula Formula
  deriving Show
        </code></pre></div></div>
        
<span class="text">We first list all the constructors for <code>Formula</code> (we could also get this information using the <code>:t</code> command in GHCi):</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
T :: Formula
F :: Formula
Not :: Formula -> Formula
And :: Formula -> Formula -> Formula
Or :: Formula -> Formula -> Formula
        </code></pre></div></div>
        
<span class="text">A fold function will simply replace all instances of each constructor in a tree with different value or function (for example, let's call <code>And</code>'s replacement <code>a</code> and <code>T</code>'s replacement <code>t</code>); this means that the replacement values and functions must have a type that has the same structure (i.e., they must take the same number of arguments) as the constructors they replace. However, they will fold into some new type of value <code>b</code>, so we replace every instance of <code>Formula</code> with the new result type <code>b</code>:</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
t :: b
f :: b
n :: b -> b
a :: b -> b -> b  
o :: b -> b -> b
        </code></pre></div></div>
        
<span class="text">We can now write our <code>foldFormula</code> function to take the above five arguments, and then the formula tree that is being folded as the last argument.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
foldFormula :: b -> b -> (b -> b) -> (b -> b -> b) -> (b -> b -> b) -> Formula -> b
foldFormula t f n a o (T          ) = t
foldFormula t f n a o (F          ) = f
foldFormula t f n a o (Not formula) = n (foldFormula t f n a o formula) 
foldFormula t f n a o (And f1 f2  ) = a (foldFormula t f n a o f1) (foldFormula t f n a o f2)
foldFormula t f n a o (Or  f1 f2  ) = o (foldFormula t f n a o f1) (foldFormula t f n a o f2)
        </code></pre></div></div>
        
<span class="text">We can now implement two evaluation algorithms easily: one that evaluates the tree as a native Haskell <code>Bool</code> result, and one that evaluates the tree as a native Haskell <code>Int</code> result:</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
evalAsBool :: Formula -> Bool
evalAsBool = foldFormula True False not (&&) (||) 

evalAsInt :: Formula -> Int
evalAsInt = foldFormula 1 0 ((-) 1) (*) max
        </code></pre></div></div>
        
<span class="text">Notice that the <code>foldFormula</code> function acts as a form of encapsulation for the <code>Formula</code> data structure. Suppose we want to change the data type definition to the following (using a terminology for formulas that corresponds to terminology from the study of logic):</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
data Formula = 
    Top
  | Bottom
  | Neg Formula
  | Conj Formula Formula
  | Disj Formula Formula
  deriving Show
        </code></pre></div></div>
        
<span class="text">We could then change the definition of <code>foldFormula</code> once, and would not need to change our implementations of <code>evalAsBool</code> and <code>evalAsInt</code> at all.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
foldFormula :: b -> b -> (b -> b) -> (b -> b -> b) -> (b -> b -> b) -> Formula -> b
foldFormula t f n a o (Top         ) = t
foldFormula t f n a o (Bottom      ) = f
foldFormula t f n a o (Neg formula ) = n (foldFormula t f n a o formula) 
foldFormula t f n a o (Conj f1 f2  ) = a (foldFormula t f n a o f1) (foldFormula t f n a o f2)
foldFormula t f n a o (Disj  f1 f2 ) = o (foldFormula t f n a o f1) (foldFormula t f n a o f2)
        </code></pre></div></div>
      </div></div></div>
<a name="123b1d495c5f4c03827519c53ad95ee2"></a><div class="linked block"><div class="link-block">[<a href="#123b1d495c5f4c03827519c53ad95ee2">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="example task_required"><span class="block_label">Example:</span> 
        
<span class="text">Suppose we are working with functions that may not always successfully return a result. We may want to document this in the type of each function. For example, suppose we have the following functions.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
neg :: Integer -> Integer
neg n = -1 * n
        
log2 :: Integer -> Integer
log2 1 = 0
log2 2 = 1
log2 4 = 2
log2 _ = -1 -- Undefined in all other cases.
        </code></pre></div></div>
        
<span class="text">One problem with the definition of <code>log2</code> is that the output <code>-1</code> is ambiguous: it may be an actual result or an error. We can document that this result is exceptional by introducing a new parametric polymorphic data type that allows us to return either a result or a constructor indicating that there is no result. In the Haskell <code>Prelude</code>, the <code>Maybe a</code> data type is defined for such situations (although we could create our own, as well).</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
data Maybe a = Just a | Nothing
        </code></pre></div></div>
        
<span class="text">We can now modify our implementation for <code>log2</code>.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
log2 :: Integer -> Maybe Integer
log2 1 = Just 0
log2 2 = Just 1
log2 4 = Just 2
log2 _ = Nothing
        </code></pre></div></div>
        
<span class="text">However, we then run into a problem: we can no longer apply another function like <code>neg</code> directly to the result of <code>log2</code> because <code>Maybe Integer</code> and <code>Integer</code> do not unify, so the Haskell type inference rule for function application is not satisfied. To address this, we can create a parametric polymorphic <i>map</i> function for <code>Maybe a</code>.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
mapMaybe :: (a -> b) -> (Maybe a -> Maybe b)
mapMaybe f (Just x ) = Just (f x)
mapMaybe f (Nothing) = Nothing
        </code></pre></div></div>
        
<span class="text">We can now apply <code>neg</code> to an input of type <code>Maybe Integer</code>.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
*> (mapMaybe neg) (log2 (-2))
Nothing
*> (mapMaybe neg) (log2 4)
Just (-2)
        </code></pre></div></div>
        
<span class="text">Since <code>mapMaybe</code> can be described as "lifting" a function of type <code>a -> b</code> to a more powerful function <code>Maybe a -> Maybe b</code>, another common name for the map operation is <i>lift</i>.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
liftMaybe :: (a -> b) -> (Maybe a -> Maybe b)
liftMaybe = mapMaybe
        </code></pre></div></div>
        
<span class="text">There is one more problem with this approach, however. What if we want to compose two functions that might both return results that are erroneous or undefined? We can see that we run into a problem.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
*> :t (liftMaybe log2) (log2 (-2))
Maybe (Maybe Integer)
        </code></pre></div></div>
        
<span class="text">However, we can address this by introducing another function that has a very natural definition, which we call a <i>join</i> operation.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
joinMaybe :: Maybe (Maybe a) -> Maybe a
joinMaybe (Just (Just x)) = Just x
joinMaybe (Just Nothing ) = Nothing
joinMaybe (Nothing      ) = Nothing
        </code></pre></div></div>
        
<span class="text">We can now combine multiple operations and still obtain a result of type <code>Maybe a</code>.</span>
        
<div class="code"><div class="source"><pre><code class="haskell">
*> joinMaybe $ (liftMaybe log2) (log2 (-2))
Nothing
        </code></pre></div></div>
      </div></div></div>
<span class="text top">When lift and join operations are defined for a container type, we sometimes call that type a <i>monad</i>. One application of this concept is in dealing with different kinds of errors in a large software application with many modular, interdepending components that can each return their own collection of erroneous or undefined outputs. It would not make sense to require that every component should handle the erroneous outputs of every other component (potentially leading to O(<i>n</i><sup>2</sup>) different combinations to consider throughout the application).</span><div class="paragraph">
A more tractable approach is to have each modular component provide a lift function for its particular error monad, and to have a dedicated module for all the join functions. This way, the problem of composing erroneous outputs is encapsulated and modularized in the definitions of the join operations, and every other component can write code under the assumption that it only needs to handle non-erroneous and well-defined inputs. 
      </div></div>
</div><a name="R.1"></a><div class="review"><hr /><h2 class="linked"><span class="link-title">[<a href="#R.1">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">Review 1.</span> Programming Language Concepts</h2>
<span class="text top">This section contains a collection of review problems going over all the course material. These problems are an accurate representation of the kinds of problems you may see on a quiz or exam.</span>
<a name="d31915c941d848449c7fc5f7e6618355"></a><div class="linked block"><div class="link-block">[<a href="#d31915c941d848449c7fc5f7e6618355">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="exercise task_required"><span class="block_label">Exercise:</span> 
      
<span class="text">Suppose you are given the following type definitions for representing simple English sentences:</span>
      
<div class="code"><div class="source"><pre><code class="haskell">
type Noun = String
type Adjective = String
type Verb = String
type Adverb = String

data NounPhrase = AN Adjective NounPhrase | N Noun
data VerbPhrase = AV Adverb VerbPhrase | V Verb
data Sentence = S NounPhrase VerbPhrase
      </code></pre></div></div>
      <ol style="list-style-type:lower-alpha"><li>
<span class="text">Determine the minimal substitution that solves the following equation under pattern-matching unification, or explain why no solution can exist (by demonstrating what base case causes an issue):
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><code>S (AN a (N "cat")) (V b)</code> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>S (AN "yellow" (N "cat")) (V "runs")</code>
</td></tr></table></td></tr></table></span></li><li>
<span class="text">Determine the minimal substitution that solves the following equation under pattern-matching unification, or explain why no solution can exist (by demonstrating what base case causes an issue):
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><code>S (AN a (AN b (N "cat"))) (V c)</code> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>S (AN "yellow" (N "cat")) (V "runs")</code>
</td></tr></table></td></tr></table></span></li><li>
<span class="text">Given the above data type definition, is it possible to write a single Haskell function pattern that will match any sentence in which <code>"cat"</code> is the subject?</span></li></ol>
    </div></div></div>
<a name="2f9c5a17c5044724bfa04089a3f97d3d"></a><div class="linked block"><div class="link-block">[<a href="#2f9c5a17c5044724bfa04089a3f97d3d">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="exercise task_required"><span class="block_label">Exercise:</span> 
      
<span class="text">Adjust the following grammar definition so that it accepts exactly the same set of token sequences, but is not left-recursive:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">number <i>n</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>0</b> | <b>1</b> | ... | <b>9</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>&#8722;</b> <b>(</b> <i>n</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>n</i> <b>*</b> <i>n</i>
</td></tr></table></td></tr></table></span>
    </div></div></div>
<a name="2f9c5a1744444724bfa04089a3f97d3d"></a><div class="linked block"><div class="link-block">[<a href="#2f9c5a1744444724bfa04089a3f97d3d">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="exercise task_required"><span class="block_label">Exercise:</span> 
      
<span class="text">Write down a fold function for the follow data type.</span>
      
<div class="code"><div class="source"><pre><code class="haskell">
data Tree =
      Red Tree Tree 
    | Blue Tree Tree 
    | Green Integer
      </code></pre></div></div>
    </div></div></div>
<a name="21235a17c5044724bfa04089a3f97d3d"></a><div class="linked block"><div class="link-block">[<a href="#21235a17c5044724bfa04089a3f97d3d">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="exercise task_required"><span class="block_label">Exercise:</span> 
      
<span class="text">Complete the following inference rules.</span>
      <div class="inferences"><table class="inference"><tr><td class="title">[???]</td><td><table><tr><td class="premises">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8866; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : <b>TyBool</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b>print</b> <i>e</i> <b>;</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[???]</td><td><table><tr><td class="premises">&nbsp;&Sigma; &#8846; {<i>x</i> &#x21A6; <i>v</i>} , &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &dArr; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; , &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &dArr; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; , <i>x</i> <b>:=</b> <i>e</i> <b>;</b> <i>s</i> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</td></tr></table></td></tr></table></div>
    </div></div></div>
<a name="2a357ccdb6414725b96f52e71d55f40e"></a><div class="linked block"><div class="link-block">[<a href="#2a357ccdb6414725b96f52e71d55f40e">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="exercise task_required"><span class="block_label">Exercise:</span> 
      
<span class="text">Suppose you are given the following grammar definition and operational semantics:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">actor <i>r</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>foo</b> 
            |  <b>bar</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
action <i>a</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>change</b> <i>r</i> | <b>is</b> <i>r</i></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
</td></tr></table></td></tr></table></span>
      <div class="inferences"><table class="inference"><tr><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>is</b> <i>r</i> &dArr; <b>is</b> <i>r</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>change</b> <b>foo</b> &dArr; <b>is</b> <b>bar</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>change</b> <b>bar</b> &dArr; <b>is</b> <b>foo</b>&nbsp;</td></tr></table></td></tr></table></div>
      
<span class="text">According to the above operational semantics, to what should <b>change foo</b> evaluate?</span>
    </div></div></div>
<a name="e8146595d4df4e1fbc19b0f001af8dc8"></a><div class="linked block"><div class="link-block">[<a href="#e8146595d4df4e1fbc19b0f001af8dc8">link</a>]&nbsp;&nbsp;</div><div style="width:100%; display:inline-block;"><div style="width:auto;" class="exercise task_required"><span class="block_label">Exercise:</span> 
      
<span class="text">Answer the following questions by drawing diagrams (your diagrams may need to incorporate self-loops).</span>
      <ol style="list-style-type:lower-alpha"><li>
<span class="text">Determine which of the following terms refer to <b>data structures</b>, and which terms refer to <b>algorithms</b>. Draw a flow chart incorporating all of the above components that demonstrates how they might interact in an actual implementation (there may be more than one correct answer, but the way they interact must be reasonable):
<ul>
  <li>input file;</li>
  <li>abstract syntax trees;</li>
  <li>parser;</li>
  <li>compiler;</li>
  <li>type checker;</li>
  <li>error message;</li>
  <li>loop unroller;</li>
  <li>machine instruction sequences.</li>
</ul></span>
<div class="button"><button class="solution_toggle">show solution</button></div><div class="solution_container" style="display:none;"><div class="solution">
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">input<br/>file</td>
    <td></td>
    <td class="box" style="background-color:lightyellow;">loop<br/>unroller</td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td class="box" style="background-color:powderblue;">machine<br/>instruction<br/>sequences</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td></td>
    <td><span style="font-size:20px;">&uArr; &dArr;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td><span style="font-size:20px;">&uArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">parser</td>
    <td><span style="font-size:20px;">&rArr;</span></td>
    <td class="box" style="background-color:powderblue;">abstract<br/>syntax<br/>trees</td>
    <td><span style="font-size:20px;">&rArr;</span></td>
    <td class="box" style="background-color:lightyellow;">type<br/>checker</td>
    <td><span style="font-size:20px;">&rArr;</span></td>
    <td class="box" style="background-color:powderblue;">abstract<br/>syntax<br/>trees</td>
    <td><span style="font-size:20px;">&rArr;</span></td>
    <td class="box" style="background-color:lightyellow;">compiler</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td class="box" style="background-color:powderblue;">error<br/>messages</td>
    <td></td>
    <td></td>
    <td></td>
    <td class="box" style="background-color:powderblue;">error<br/>messages</td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
</table>
</div>
          </div></div><div class="solution_spacer"></div></li><li>
<span class="text">Draw a flow chart incorporating all of the below components that demonstrates how they might interact in an actual implementation:
<ul>
  <li>exhaustive case generator;</li>
  <li>abstract syntax trees;</li>
  <li>compiler;</li>
  <li>interpreter;</li>
  <li>machine instruction sequences;</li>
  <li>simulator;</li>
  <li>outputs;</li>
  <li>output comparison function.</li>
</ul></span>
<div class="button"><button class="solution_toggle">show solution</button></div><div class="solution_container" style="display:none;"><div class="solution">
<div class="diagram">
<table class="container">
  <tr>
    <td colspan="3" class="box" style="background-color:lightyellow;">exhaustive<br/>case<br/>generator</td>
    <td colspan="2"></td>
  </tr>
  <tr>
    <td colspan="3"><span style="font-size:20px;">&dArr;</span></td>
    <td colspan="2"></td>
  </tr>
  <tr>
    <td colspan="3" class="box" style="background-color:powderblue;">abstract<br/>syntax<br/>trees</td>
    <td colspan="2"></td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td></td>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td colspan="2"></td>
  </tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">interpreter</td>
    <td></td>
    <td class="box" style="background-color:lightyellow;">compiler</td>
    <td><span style="font-size:20px;">&rArr;</span></td>
    <td class="box" style="background-color:powderblue;">machine<br/>instruction<br/>sequences</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:powderblue;">outputs</td>
    <td></td>
    <td class="box" style="background-color:powderblue;">outputs</td>
    <td><span style="font-size:20px;">&lArr;</span></td>
    <td class="box" style="background-color:lightyellow;">simulator</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td></td>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td colspan="3" class="box" style="background-color:lightyellow;">output<br/>comparison<br/>function</td>
    <td></td>
    <td></td>
  </tr>
</table>
</div>
          </div></div><div class="solution_spacer"></div></li></ol>
    </div></div></div>
</div><a name="A"></a><div class="appendix"><hr /><h2 class="linked"><span class="link-title">[<a href="#A">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">Appendix A.</span> Using gsubmit</h2>
<span class="text top">In this course, you will submit your assignments using <code><a href="http://www.cs.bu.edu/teaching/hw/gsubmit/">gsubmit</a></code>. This section reproduces and extends some of the <a href="http://www.cs.bu.edu/teaching/hw/gsubmit/">instructions</a> already made available by the BU Computer Science Department.</span>
  <a name="A.1"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#A.1">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">A.1.</span> Register for a CS account</h3>
<span class="text top">You must obtain a CS account to use the <code>csa</code> machines maintained by the CS Dept. You will need to physically visit the <a href="http://www.bu.edu/cs/resources/laboratories/undergraduate-lab/">undergraduate computing lab</a> located at 730 Commonwealth Avenue, on the third floor in room 302.</span></div>
  <a name="A.2"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#A.2">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">A.2.</span> Download SSH/SCP client software</h3>
<span class="text top">You will need an SCP or SFTP client (such as <a href="http://winscp.net/eng/index.php)">WinSCP</a> for Windows or <a href="http://cyberduck.ch/">CyberDuck</a> for OS X) to copy files from your local computer to your <code>csa</code> home directory. If you are using Windows, you will also need an SSH client (such as <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html">PuTTY</a>).</span></div>
  <a name="A.3"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#A.3">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">A.3.</span> Submitting assignments using gsubmit</h3>
<span class="text top">A typical workflow can be described as follows.</span><ol><li>You assemble your assignment solution file(s) on your own computer or device.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:#EFEFEF;">
      local<br/>device
      <table class="container">
        <tr>
          <td class="box" style="background-color:lightyellow;">
            hw1
            <table class="container">
              <tr>
                <td class="box" style="background-color:powderblue;">hw1.py</td>
              </tr>
            </table>
          </td>
       </tr>
      </table>
    </td>
    <td><span style="font-size:20px;">&nbsp;&nbsp;&nbsp;</span></td>
    <td class="box" style="background-color:#EFEFEF;">
      your <code>csa2</code>/<code>csa3</code><br/>home directory
    </td>
    <td><span style="font-size:20px;">&nbsp;&nbsp;&nbsp;</span></td>
    <td class="box" style="background-color:#EFEFEF;">
      your <code>gsubmit</code><br/>directory for CS 320
    </td>
  </tr>
</table>
</div></li><li>
<span class="text">You log into <code>csa2</code> or <code>csa3</code> using an SCP or SSH client and create a directory for your submission in your CS account home directory. Note that in the examples below <code>%&gt;</code> represents a terminal prompt, which may look different on your system.</span>
<div class="code"><div class="source"><pre><code class="py">
%> cd ~
%> mkdir hw1
          </code></pre></div></div>
<span class="text"><div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:#EFEFEF;">
      local<br/>device
      <table class="container">
        <tr>
          <td class="box" style="background-color:lightyellow;">
            hw1
            <table class="container">
              <tr>
                <td class="box" style="background-color:powderblue;">hw1.py</td>
              </tr>
            </table>
          </td>
       </tr>
      </table>
    </td>
    <td><span style="font-size:20px;">&nbsp;&nbsp;&nbsp;</span></td>
    <td class="box" style="background-color:#EFEFEF;">
      your <code>csa2</code>/<code>csa3</code><br/>home directory
      <table class="container">
        <tr>
          <td class="box" style="background-color:lightyellow;">
            hw1<br/><br/><br/>
          </td>
       </tr>
      </table>
    </td>
    <td><span style="font-size:20px;">&nbsp;&nbsp;&nbsp;</span></td>
    <td class="box" style="background-color:#EFEFEF;">
      your <code>gsubmit</code><br/>directory for CS 320
    </td>
  </tr>
</table>
</div></span></li><li>
<span class="text">If you have not already done so (e.g., if you were using an SSH client in the previous step), you log into <code>csa2</code> or <code>csa3</code> using an SCP client and copy your completed file(s) into that directory.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:#EFEFEF;">
      local<br/>device
      <table class="container">
        <tr>
          <td class="box" style="background-color:lightyellow;">
            hw1
            <table class="container">
              <tr>
                <td class="box" style="background-color:powderblue;">hw1.py</td>
              </tr>
            </table>
          </td>
       </tr>
      </table>
    </td>
    <td><span style="font-size:20px;">&rArr;</span></td>
    <td class="box" style="background-color:#EFEFEF;">
      your <code>csa2</code>/<code>csa3</code><br/>home directory
      <table class="container">
        <tr>
          <td class="box" style="background-color:lightyellow;">
            hw1
            <table class="container">
              <tr>
                <td class="box" style="background-color:powderblue;">hw1.py</td>
              </tr>
            </table>
          </td>
       </tr>
      </table>
    </td>
    <td><span style="font-size:20px;">&nbsp;&nbsp;&nbsp;</span></td>
    <td class="box" style="background-color:#EFEFEF;">
      your <code>gsubmit</code><br/>directory for CS 320
    </td>
  </tr>
</table>
</div></span></li><li>
<span class="text">If you have not already done so, you log into <code>csa2</code> or <code>csa3</code> using an SSH client and run the <code>gsubmit</code> commands to copy the files from your CS account home directory to the <code>gsubmit</code> directories to which the course staff has access.</span>
<div class="code"><div class="source"><pre><code class="py">
%> cd ~
%> gsubmit cs320 hw1
          </code></pre></div></div>
<span class="text"><div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:#EFEFEF;">
      local<br/>device
      <table class="container">
        <tr>
          <td class="box" style="background-color:lightyellow;">
            hw1
            <table class="container">
              <tr>
                <td class="box" style="background-color:powderblue;">hw1.py</td>
              </tr>
            </table>
          </td>
       </tr>
      </table>
    </td>
    <td><span style="font-size:20px;">&rArr;</span></td>
    <td class="box" style="background-color:#EFEFEF;">
      your <code>csa2</code>/<code>csa3</code><br/>home directory
      <table class="container">
        <tr>
          <td class="box" style="background-color:lightyellow;">
            hw1
            <table class="container">
              <tr>
                <td class="box" style="background-color:powderblue;">hw1.py</td>
              </tr>
            </table>
          </td>
       </tr>
      </table>
    </td>
    <td><span style="font-size:20px;">&rArr;</span></td>
    <td class="box" style="background-color:#EFEFEF;">
      your <code>gsubmit</code><br/>directory for CS 320
      <table class="container">
        <tr>
          <td class="box" style="background-color:lightyellow;">
            hw1
            <table class="container">
              <tr>
                <td class="box" style="background-color:powderblue;">hw1.py</td>
              </tr>
            </table>
          </td>
       </tr>
      </table>
    </td>
  </tr>
</table>
</div></span></li><li>
<span class="text">To view your submitted files, you can use the following command:</span>
<div class="code"><div class="source"><pre><code class="py">
%> gsubmit cs320 -ls
          </code></pre></div></div>
<span class="text">To look at a file that has already been submitted, you can use:</span>
<div class="code"><div class="source"><pre><code class="py">
%> gsubmit cs320 -cat hw1/hw1.py
          </code></pre></div></div>
<span class="text"><i>After</i> grades are posted (normally, this will be announced on the mailing list and in lecture), you can check your grade using:</span>
<div class="code"><div class="source"><pre><code class="py">
%> gsubmit cs320 -cat grade.hw1.txt
          </code></pre></div></div></li></ol></div></div><a name="B"></a><div class="appendix"><hr /><h2 class="linked"><span class="link-title">[<a href="#B">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">Appendix B.</span> Python Reference</h2>
<span class="text top">The Python programming language will be among the languages we use in this course. This language supports the object-oriented, imperative, and functional programming paradigms, has automatic memory managememt, and natively supports common high-level data structures such as lists and sets. Python is often used as an interpreted language, but it can also be compiled.</span>
  <a name="B.1"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#B.1">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">B.1.</span> Obtaining Python</h3>
<span class="text top">The latest version of Python 3 can be downloaded at: <b><a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a></b>. In this course, we will require the use if <b>Python 3</b>, which has been installed on all the <a href="http://www.bu.edu/cs/resources/laboratories/undergraduate-lab/">CS Department's undergraduate computing lab</a> machines, as well as on <code>csa2/csa3</code>.</span></div>
  <a name="B.2"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#B.2">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">B.2.</span> Assembling a Python module</h3>
<span class="text top">The simplest Python program is a single file (called a <i>module</i>) with the file extension <code>.py</code>. For example, suppose the following is contained within a file called <code>example.py</code>:</span>
<div class="code top"><div class="source"><pre><code class="py">
# This is a comment in "example.py".
# Below is a Python statement.
print("Hello, world.")
      </code></pre></div></div>
<span class="text top">Assuming Python is installed on your system, to run the above program from the command line you can use the following (you may need to use <code>python3</code>, <code>python3.2</code>, <code>python3.3</code>, etc. depending on the Python installation you're using). Note that in the examples below <code>%&gt;</code> represents a terminal prompt, which may look different on your system.</span>
<div class="code top"><div class="source"><pre><code class="py">
%> python example.py
Hello, world.
      </code></pre></div></div>
<span class="text top">If you run Python without an argument on the command line, you will enter Python's interactive prompt. You can then evaluate expressions and execute individual statements using this prompt; you can also load and execute a Python module file:</span>
<div class="code top"><div class="source"><pre><code class="py">
%> python
Python 3.2 ...
Type "help", "copyright", "credits" or "license" for more information.
>>> exec(open("example.py").read()) # Load "example.py" module.
Hello, world.
>>> x = "Hello." # Execute an assignment statement.
>>> print(x)     # Execute a "print" statement.
Hello.
>>> x            # Evaluate a string expression.
'Hello.'
>>> 1 + 2        # Evaluate a numerical expression.
3
      </code></pre></div></div></div>
  <a name="B.3"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#B.3">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">B.3.</span> Common data structures (i.e., Python expressions)</h3>
<span class="text top">Python provides native support for several data structures that we will use throughout this course: integers, strings, lists, tuples, sets, and dictionaries (also known as finite maps). In this subsection, we present how instances of these data structures are represented in Python, as well as the most common operations and functions that can be applied to these data structure instances.</span><ul class="top"><li>
<span class="text"><b>Booleans</b> consist of two constants: <code>True</code> and <code>False</code>.</span><ul><li>The usual logical operations are available using the operators <code>and</code>, <code>or</code>, and <code>not</code>.</li></ul>
<div class="code"><div class="source"><pre><code class="py">
>>> True                                      # A boolean constant.
True
>>> False                                     # A boolean constant.
False
>>> True and False or True and (not False)    # A boolean expression.
True
          </code></pre></div></div></li><li>
<span class="text"><b>Integers</b> are written as in most other programming languages (i.e., as a sequence of digits).</span><ul><li>The usual arithmetic operations are available using the operators <code>+</code>, <code>*</code>, <code>-</code>, and <code>/</code>. The infix operator <code>//</code> represents integer division, and the infix operators <code>**</code> represents exponentiation. Negative integers are prefixed with the negation operator <code>-</code>.</li><li>The usual relational operators <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> are available.</li><li>The <code>int()</code> function can convert a string that looks like an integer into an integer.</li></ul>
<div class="code"><div class="source"><pre><code class="py">
>>> 123                                       # An integer constant.
123
>>> 1 * (2 + 3) // 4 - 5                      # An integer expression.
-4
>>> 4 * 5 >= 19                               # A boolean expression involving integers.
True
>>> int("123")                                # A string being converted into an integer
123
          </code></pre></div></div></li><li>
<span class="text"><b>Strings</b> are delimited by either <code>'</code> or <code>"</code> characters. Strings can be treated as lists of single-character strings. Another way to look at this is that there is no distinction between a character and a string: all characters are just strings of length 1. Multiline strings can be delimited using <code>"""</code> or <code>'''</code> (i.e., three quotation mark characters at the beginning and end of the string literal).</span><ul><li>The empty string is denoted using <code>''</code> or <code>""</code>.</li><li>Two strings can be concatenated using <code>+</code>.</li><li>The function <code>len()</code> returns the length of a string.</li><li>Individual characters in a string can be accessed using the bracketed index notation (e.g., <code>s[i]</code>). These characters are also strings themselves.</li></ul>
<div class="code"><div class="source"><pre><code class="py">
>>> 'Example.'                                # A string.
'Example.'
>>> "Example."                                # Alternate notation for a string.
'Example.'
>>> len("ABCD")                               # String length.
4
>>> "ABCD" + "EFG"                            # String concatenation.
'ABCDEFG'
>>> "ABCD"[2]                                 # Third character in the string.
'C'
          </code></pre></div></div></li><li>
<span class="text"><b>Lists</b> are similar to arrays: they are ordered sequences of objects and/or values. The entries of a list can be of a mixture of different types, and lists containing one or more objects are delimited using <code>[</code> and <code>]</code>, with the individual list entries separated by commas. Lists cannot be members of sets.</span><ul><li>The empty list is denoted using <code>[]</code>.</li><li>Two lists can be concatenated using <code>+</code>.</li><li>The function <code>len()</code> returns the length of a list.</li><li>Individual entries in a list can be accessed using the bracketed index notation (e.g., <code>a[i]</code>).</li><li>To check if a value is in a list, use the <code>in</code> relational operator.</li></ul>
<div class="code"><div class="source"><pre><code class="py">
>>> [1,2,"A","B"]                             # A list.
[1, 2, 'A', 'B']
>>> [1, 2] + ['A','B']                        # Concatenating lists.
[1, 2, 'A', 'B']
>>> len([1,2,"A","B"] )                       # List length.
4
>>> [1,2,"A","B"][0]                          # First entry in the list.
1
>>> 1 in [1, 2]                               # List containment check.
True
          </code></pre></div></div></li><li>
<span class="text"><b>Tuples</b> are similar to lists (they are ordered, and can contain objects of different types), except they are delimited by parentheses <code>(</code> and <code>)</code>, with entries separated by commas. The main distinction between lists and tuples is that tuples are hashable (i.e., they can be members of sets).</span><ul><li>The empty tuple is denoted using <code>()</code>.</li><li>A tuple containing a single object <code>x</code> is denoted using <code>(x, )</code>.</li><li>Two tuples can be concatenated using <code>+</code>.</li><li>A tuple can be turned into a list using the <code>list()</code> function.</li><li>A list can be turned into a tuple using the <code>tuple()</code> function.</li><li>The function <code>len()</code> returns the length of a tuple.</li><li>Individual entries in a tuple can be accessed using the bracketed index notation (e.g., <code>t[i]</code>).</li><li>To check if a value is in a tuple, use the <code>in</code> relational operator.</li></ul>
<div class="code"><div class="source"><pre><code class="py">
>>> (1,2,"A","B")                             # A tuple.
(1, 2, 'A', 'B')
>>> (1,)                                      # Another tuple.
(1,)
>>> (1, 2) + ('A','B')                        # Concatenating tuples.
(1, 2, 'A', 'B')
>>> list((1, 2, 'A','B'))                     # A tuple being converted into a list.
[1, 2, 'A', 'B']
>>> tuple([1, 2, 'A','B'])                    # A list being converted into a tuple.
(1, 2, 'A', 'B')
>>> len((1,2,"A","B"))                        # Tuple length.
4
>>> (1,2,"A","B")[0]                          # First entry in the tuple.
1
>>> 1 in (1, 2)                               # Tuple containment check.
True
          </code></pre></div></div></li><li>
<span class="text"><b>Sets</b> are unordered sequences that cannot contain duplicates. They are a close approximation of mathematical sets. Sets cannot be members of sets.</span><ul><li>The empty set is denoted using <code>set()</code>.</li><li>The methods <code>.union()</code> and <code>.intersect</code> correspond to the standard set operations.</li><li>A list or tuple can be turned into a set using the <code>set()</code> function.</li><li>A set can be turned into a list or tuple using the <code>list()</code> or <code>list()</code> function, respectively.</li><li>The function <code>len()</code> returns the size of a set.</li><li>To access individual entries in a set, it is necessary to turn the set into a list or tuple.</li><li>To check if a value is in a set, use the <code>in</code> relational operator.</li></ul>
<div class="code"><div class="source"><pre><code class="py">
>>> {1,2,"A","B"}                             # A set.
{1, 2, 'A', 'B'}
>>> ({1,2}.union({3,4})).intersection({4,5})  # Set operations.
{4}
>>> set([1, 2]).union(set(('A','B')))         # Converting a list and a tuple to sets.
{'A', 1, 2, 'B'}
>>> len({1,2,"A","B"})                        # Set size.
4
>>> 1 in {1,2,"A","B"}                        # Tuple containment check.
True
          </code></pre></div></div></li><li>
<span class="text"><b>Frozen sets</b> are like sets, except they can be members of other sets. A set can be turned into a frozen set using the <code>frozenset()</code> function.</span>
<div class="code"><div class="source"><pre><code class="py">
>>> frozenset({1,2,3})                        # A frozen set.
frozenset({1, 2, 3})
>>> {frozenset({1,2}), frozenset({3,4})}      # Set of frozen sets.
{frozenset({3, 4}), frozenset({1, 2})}
          </code></pre></div></div></li><li>
<span class="text"><b>Dictionaries</b> are unordered collections of associations between some set of keys and some set of values. Dictionaries are also known as finite maps.</span><ul><li>The empty dictionary is denoted using <code>{}</code>.</li><li>The list of keys that the dictionary associates with values can be obtained using <code>list(d.keys())</code>.</li><li>The list of values that the dictionary contains can be obtained using <code>list(d.values())</code>.</li><li>The function <code>len()</code> returns the number of entries in the dictionary.</li><li>Individual entries in a dictionary can be accessed using the bracketed index notation (e.g., <code>d[key]</code>).</li></ul>
<div class="code"><div class="source"><pre><code class="py">
>>> {"A":1, "B":2}                            # A dictionary.
{'A': 1, 'B': 2}
>>> list({"A":1, "B":2}.keys())               # Dictionary keys.
['A', 'B']
>>> list({"A":1, "B":2}.values())             # Dictionary values.
[1, 2]
>>> len({"A":1, "B":2})                       # Dictionary size.
2
>>> {"A":1, "B":2}["A"]                       # Obtain a dictionary value using a key.
1
          </code></pre></div></div></li></ul></div>
  <a name="B.4"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#B.4">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">B.4.</span> Function, procedure, and method invocations</h3>
<span class="text top">Python provides a variety of ways to supply parameter arguments when invoking functions, procedures, and methods.</span><ul class="top"><li>
<span class="text"><b>Function calls and method/procedure invocations</b> consist of the function, procedure, or method name followed by a parenthesized, comma-delimited list of arguments. For example, suppose a function or procedure <code>example()</code> is defined as follows:</span>
<div class="code"><div class="source"><pre><code class="py">
def example(x, y, z):
  print("Invoked.")
  return x + y + z
          </code></pre></div></div>
<span class="text">To invoke the above definition, we can use one of the following techniques.</span><ul><li>
<span class="text"><b>Passing arguments directly</b> involves listing the comma-delimited arguments directly between parentheses.</span>
<div class="code"><div class="source"><pre><code class="py">
>>> example(1,2,3)
Invoked.
6
              </code></pre></div></div></li><li>
<span class="text"><b>The argument unpacking operator</b> (also known as the <code>*</code>-operator, the <b>scatter</b> operator, or the <b>splat</b> operator) involves providing a list to the function, preceded by the <code>*</code> symbol; the arguments will be drawn from the elements in the list.</span>
<div class="code"><div class="source"><pre><code class="py">
>>> args = [1,2,3]
>>> example(*args)
Invoked.
6
              </code></pre></div></div></li><li>
<span class="text"><b>The keyword argument unpacking operator</b> (also known as the <code>**</code>-operator) involves providing a dictionary to the function, preceded by the <code>**</code> symbol; each named paramter in the function definition will be looked up in the dictionary, and the value associated with that dictionary key will be used as the argument passed to that parameter.</span>
<div class="code"><div class="source"><pre><code class="py">
>>> args = {'z':3, 'x':1, 'y':2}
>>> example(**args)
Invoked.
6
              </code></pre></div></div></li></ul></li><li>
<span class="text"><b>Default parameter values</b> can be specified in any definition. Suppose the following definition is provided.</span>
<div class="code"><div class="source"><pre><code class="py">
def example(x = 1, y = 2, z = 3):
  return x + y + z
          </code></pre></div></div>
<span class="text">The behavior is then as follows: if an argument corresponding to a parameter is not supplied, the default value found in the definition is used. If an argument is supplied, the supplied argument value is used.</span>
<div class="code"><div class="source"><pre><code class="py">
>>> example(0, 0)
3
>>> example(0)
5
>>> example()
6
          </code></pre></div></div></li></ul></div>
  <a name="B.5"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#B.5">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">B.5.</span> Comprehensions</h3>
<span class="text top">Python provides concise notations for defining data structures and performing logical computations. In particular, it support a comprehension notation that can be used to build lists, tuples, sets, and dictionaries.</span><ul class="top"><li>
<span class="text"><b>List comprehensions</b> make it possible to construct a list by iterating over one or more other data structure instances (such as a list, tuple, set, or dictionary) and performing some operation on each element or combination of elements. The resulting list will contain the result of evaluating the body for every combination.</span>
<div class="code"><div class="source"><pre><code class="py">
>>> [ x for x in [1,2,3] ]
[1, 2, 3]
>>> [ 2 * x for x in {1,2,3} ]
[2, 4, 6]
>>> [ x + y for x in {1,2,3} for y in (1,2,3) ]
[2, 3, 4, 3, 4, 5, 4, 5, 6]
          </code></pre></div></div>
<span class="text">It is also possible to add conditions anywhere after the first <code>for</code> clause. This will filter which combinations are actually used to add a value to the resulting list.</span>
<div class="code"><div class="source"><pre><code class="py">
>>> [ x for x in {1,2,3} if x < 3 ]
[1, 2]
>>> [ x + y for x in {1,2,3} for y in (1,2,3) if x > 2 and y > 1 ]
[5, 6]
          </code></pre></div></div></li><li>
<span class="text"><b>Set comprehensions</b> make it possible to construct a set by iterating over one or more other data structure instances (such as a list, tuple, set, or dictionary) and performing some operation on each element or combination of elements. The resulting list will contain the result of evaluating the body for every combination. Notice that the result will contain no duplicates because the result is a set.</span>
<div class="code"><div class="source"><pre><code class="py">
>>> { x for x in [1,2,3,1,2,3] }
{1, 2, 3}
          </code></pre></div></div></li><li>
<span class="text"><b>Dictionary comprehensions</b> make it possible to construct a dictionary by iterating over one or more other data structure instances (such as a list, tuple, set, or dictionary) and performing some operation on each element or combination of elements. The resulting dictionary will contain the result of evaluating the body for every combination.</span>
<div class="code"><div class="source"><pre><code class="py">
>>> { key : 2 for key in ["A","B","C"] }
{'A': 2, 'C': 2, 'B': 2}
          </code></pre></div></div></li></ul></div>
  <a name="B.6"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#B.6">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">B.6.</span> Other useful built-in functions</h3>
<span class="text top">The built-in function <code>type()</code> can be used to determine the type of a value. Below, we provide examples of how to check whether a given expression has one of the common Python types:</span>
<div class="code top"><div class="source"><pre><code class="py">
>>> type(True) == bool
True
>>> type(123) == int
True
>>> type("ABC") == str
True
>>> type([1,2,3]) == list
True
>>> type(("A",1,{1,2})) == tuple
True
>>> type({1,2,3}) == set
True
>>> type({"A":1, "B":2}) == dict
True
      </code></pre></div></div></div>
  <a name="B.7"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#B.7">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">B.7.</span> Common Python definition and control constructs (i.e., Python statements)</h3>
<span class="text top">A Python program is a sequence of Python statements. Each statement is either a function definition, a variable assignment, a conditional statement (i.e., <code>if</code>, <code>else</code>, and/or <code>elif</code>), an iteration construct (i.e., a <code>for</code> or <code>while</code> loop), a <code>return</code> statement, or a <code>break</code> or <code>continue</code> statement.</span><ul class="top"><li>
<span class="text"><b>Variable assignments</b> make it possible to assign a value or object to a variable.</span>
<div class="code"><div class="source"><pre><code class="py">
x = 10
          </code></pre></div></div>
<span class="text">It is also possible to assign a tuple (or any computation that produces a tuple) to another tuple:</span>
<div class="code"><div class="source"><pre><code class="py">
(x, y) = (1, 2)
          </code></pre></div></div></li><li>
<span class="text"><b>Function and procedure definitions</b> consist of the <code>def</code> keyword, followed by the name of the function or procedure, and then by one or more arguments (delimited by parentheses and separated by commas).</span>
<div class="code"><div class="source"><pre><code class="py">
def example(a, b, c):
    return a + b + c
          </code></pre></div></div></li><li>
<span class="text"><b>Conditional statements</b> consist of one or more branches, each with its own boolean expression as the condition (with the exception of <code>else</code>). The body of each branch is an indented sequence of statements.</span>
<div class="code"><div class="source"><pre><code class="py">
def fibonacci(n):
    # Computes the nth Fibonacci number.
    if n <= 0:
        return 0
    elif n <= 2:
        return 1
    else:
        return fibonacci(n-1) + fibonacci(n-2)
          </code></pre></div></div></li><li>
<span class="text"><b>Iteration constructs</b> make it possible to repeat a sequence of statements over and over. The body of an iteration construct is an indented sequence of statements.</span><ul><li>
<span class="text">The <b>while</b> construct has a boolean expression as its condition (much like <code>if</code>). The body is executed over and over until the expression in the condition evaluates to <code>False</code>, or a <code>break</code> statement is encountered.</span>
<div class="code"><div class="source"><pre><code class="py">
def example1(n):
    # Takes an integer n and returns the sum of
    # the integers from 1 to n-1.
    i = 0
    sum = 0
    while i < n:
        sum = sum + i
        i = i + 1
    return sum

def example2(n):
    # Takes an integer n and returns the sum of
    # the integers from 1 to n-1.
    i = 0
    sum = 0
    while True:
        sum = sum + i
        i = i + 1
        if i == n:
            break
    return sum
              </code></pre></div></div></li><li>
<span class="text">The <b>for</b> construct makes it possible to repeat a sequence of statements once for every object in a list, tuple, or set, or once for every key in a dictionary.</span>
<div class="code"><div class="source"><pre><code class="py">
def example3(n):
    # Takes an integer n and returns the sum of
    # the integers from 1 to n-1.
    sum = 0
    for i in range(0,n):
        sum = sum + i
    return sum

def example4(d):
    # Takes a dictionary d that maps keys to
    # integers and returns the sum of the integers.
    sum = 0
    for key in d:
        sum = sum + d[key]
    return sum
              </code></pre></div></div></li></ul></li></ul></div></div><a name="C"></a><div class="appendix"><hr /><h2 class="linked"><span class="link-title">[<a href="#C">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">Appendix C.</span> Haskell Reference</h2>
<span class="text top">The Haskell programming language will be among the languages we use in this course. This language supports the functional programming paradigm, has automatic memory managememt, and natively supports algebraic data types. Haskell is both an interpreted and compiled language.</span>
  <a name="C.1"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#C.1">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">C.1.</span> Obtaining Haskell</h3>
<span class="text top">The latest version of Haskell can be downloaded with the Haskell Platform: <b><a href="http://www.haskell.org/platform/">http://www.haskell.org/platform/</a></b>. The Haskell Platform has been installed on all the <a href="http://www.bu.edu/cs/resources/laboratories/undergraduate-lab/">CS Department's undergraduate computing lab</a> machines, as well as on <code>csa2/csa3</code>.</span></div>
  <a name="C.2"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#C.2">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">C.2.</span> Haskell modules and declarations</h3>
<span class="text top">Haskell code is organized into <i>modules</i>. There is one named module per Haskell file, and the file name should match the module name (e.g., the file <code>Example.hs</code> should contain the <code>Example</code> module definition). The module body consists of a series of declarations, which can appear in any order; the only exception is that if there are multiple declarations for a function, they must all be grouped together.</span>
<div class="code top"><div class="source"><pre><code class="haskell">
module Example where

g (x) = f(x) + f(x);

f (0) = 0;
f (x) = f(x - 1) + 1;

-- This is a comment.
      </code></pre></div></div>
<span class="text top">Each declaration in a Haskell module falls into one of two categories: an expression-level declaration, or a type-level declaration. Any declaration that defines variables or functions is an expression-level declaration; any declaration that defines a type is a type-level declaration.</span>
<div class="code top"><div class="source"><pre><code class="haskell">
-- Expression-level declaration (defines a new function called "f").
f(x) = 2 * x                      

-- Type-level declaration (defines a new data type called "Tree".
data Tree = Leaf | Node Tree Tree 
      </code></pre></div></div></div>
  <a name="C.3"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#C.3">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">C.3.</span> Common data structures (i.e., Haskell expressions)</h3>
<span class="text top">The Haskell <a href="http://hackage.haskell.org/package/base">base</a> library (sometimes also called the "Prelude", and imported implicitly and automatically into every module) has a large number of standard and conventional data type and function declarations. These declarations provide native support for a variety of data structures and operations that we will use throughout this course: integers, strings, lists, and tuples, among others. In this subsection, we present how instances of these data structures are represented in Haskell, as well as the most common operations and functions that can be applied to these data structure instances.</span><ul class="top"><li>
<span class="text">The <b>Bool</b> data type supports two constructors: <code>True</code> and <code>False</code>.</span><ul><li>The usual logical operations are available using the operators <code>&&</code>, <code>||</code>, and <code>not</code>.</li><li>The built-in syntax <code>if ... then ... else ...</code> is also available (similar to Python's <code>... if ... else ...</code> and C/C++/Java's ternary operator <code> ... ? ... : ...</code>.</li></ul>
<div class="code"><div class="source"><pre><code class="haskell">
*> True
True
*> False
False
*> True || False && True && (not False)
True
*> if True then "Yes" else "No"
"Yes"
          </code></pre></div></div></li><li>
<span class="text"><b>Integers</b> are written as in most other programming languages (i.e., as a sequence of digits). Haskell supports a bounded-size type <code>Int</code> and an unbounded-size type <code>Integer</code>.</span><ul><li>The usual arithmetic operations are available using the operators <code>+</code>, <code>*</code>, <code>-</code>, <code>/</code>, and <code>^</code>. The <code>Prelude</code> function <code>div</code> represents integer division. The <code>Prelude</code> functions <code>min</code> and <code>max</code> make it possible to compute the minimum and maximum of two integers, respectively, and the function <code>minimum</code> and <code>maximum</code> make it possible to compute the minimum and maximum of a list of integers. Negative integers are prefixed with the negation operator <code>-</code>.</li><li>The usual relational operators <code>==</code>, <code>/=</code> (not equal), <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> are available.</li></ul>
<div class="code"><div class="source"><pre><code class="haskell">
*> 123
123
*> 1 * (2 + 3) `div` 4 - 5
-4
*> 4 * 5 >= 19
True
*> max 10 20
20
*> minimum [1,2,3]
1
          </code></pre></div></div></li><li>
<span class="text"><b>Strings</b> are delimited by <code>"</code> characters (individual characters are always delimited using <code>'</code>). Strings can be treated as lists of characters.</span><ul><li>The empty string is denoted using <code>""</code>.</li><li>Two strings can be concatenated using <code>++</code>.</li><li>The <code>Prelude</code>function <code>length</code> returns the length of a string.</li></ul>
<div class="code"><div class="source"><pre><code class="haskell">
*> "Example."        -- A string.
"Example."
*> length "ABCD"     -- String length.
4
*> "ABCD" ++ "EFG"   -- String concatenation.
"ABCDEFG"
          </code></pre></div></div></li><li>
<span class="text"><b>Lists</b> are ordered sequences of expressions. The entries of a list must all be of the same type. Lists are delimited using <code>[</code> and <code>]</code>, with the individual list entries separated by commas.</span><ul><li>The empty list is denoted using <code>[]</code>.</li><li>Elements can be added to the front of a list using <code>:</code>.</li><li>Two lists can be concatenated using <code>++</code>.</li><li>The <code>Prelude</code> function <code>length</code> returns the length of a list.</li><li>To check if a value is in a list, use the <code>Prelude</code> function <code>elem</code> (note that this relies on the <code>==</code> operation being defined on the type of the elements in the list).</li></ul>
<div class="code"><div class="source"><pre><code class="haskell">
*> [1,2,3]            -- A list.
[1,2,3]
*> 1 : [2,3]          -- Adding an element to the front.
[1,2,3]
*> [1,2,3] ++ [4,5]   -- Concatenating lists.
[1,2,3,4,5]
*> length [1,2,3,4]   -- List length.
4
*> 1 `elem` [1, 2]    -- List containment check.
True
          </code></pre></div></div></li><li>
<span class="text"><b>Tuples</b> are ordered, and can contain expressions of different types. They are delimited by parentheses <code>(</code> and <code>)</code>, with entries separated by commas.</span><ul><li>The empty tuple is denoted using <code>()</code>.</li><li>There are no tuples containing a single element; <code>(e)</code> is equivalent to <code>e</code> for any Haskell expression <code>e</code>.</li></ul>
<div class="code"><div class="source"><pre><code class="haskell">
*> (1,2,3)  -- A tuple.
(1,2,3)
          </code></pre></div></div></li></ul></div></div>
</div><div id="footer"><div id="author"><a href="http://lapets.io">Andrei Lapets</a></div><div id="sheaflink"><a href="http://sheaf.io">sheaf</a></div></div></body>
</html>
<!--eof-->